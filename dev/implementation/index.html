<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementation Details · SymbolicDiagonalization</title><meta name="title" content="Implementation Details · SymbolicDiagonalization"/><meta property="og:title" content="Implementation Details · SymbolicDiagonalization"/><meta property="twitter:title" content="Implementation Details · SymbolicDiagonalization"/><meta name="description" content="Documentation for SymbolicDiagonalization."/><meta property="og:description" content="Documentation for SymbolicDiagonalization."/><meta property="twitter:description" content="Documentation for SymbolicDiagonalization."/><meta property="og:url" content="https://volkerkarle.github.io/SymbolicDiagonalization.jl/implementation/"/><meta property="twitter:url" content="https://volkerkarle.github.io/SymbolicDiagonalization.jl/implementation/"/><link rel="canonical" href="https://volkerkarle.github.io/SymbolicDiagonalization.jl/implementation/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SymbolicDiagonalization</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../user_guide/">User Guide</a></li><li><a class="tocitem" href="../api_reference/">API Reference</a></li><li><a class="tocitem" href="../pattern_library/">Pattern Library</a></li><li class="is-active"><a class="tocitem" href>Implementation Details</a><ul class="internal"><li><a class="tocitem" href="#Table-of-Contents"><span>Table of Contents</span></a></li><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Characteristic-Polynomial-Computation"><span>Characteristic Polynomial Computation</span></a></li><li><a class="tocitem" href="#Root-Solvers-(Degrees-1-4)"><span>Root Solvers (Degrees 1-4)</span></a></li><li><a class="tocitem" href="#Structure-Detection"><span>Structure Detection</span></a></li><li><a class="tocitem" href="#Special-Pattern-Solvers"><span>Special Pattern Solvers</span></a></li><li><a class="tocitem" href="#Eigenvector-Computation"><span>Eigenvector Computation</span></a></li><li><a class="tocitem" href="#Expression-Management"><span>Expression Management</span></a></li><li><a class="tocitem" href="#Performance-Considerations"><span>Performance Considerations</span></a></li><li><a class="tocitem" href="#Future-Improvements"><span>Future Improvements</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li><li><a class="tocitem" href="#Appendix:-File-Organization"><span>Appendix: File Organization</span></a></li></ul></li><li><a class="tocitem" href="../mathematical_background/">Mathematical Background</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Implementation Details</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Implementation Details</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/volkerkarle/SymbolicDiagonalization.jl/blob/main/docs/src/implementation.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Implementation-Details"><a class="docs-heading-anchor" href="#Implementation-Details">Implementation Details</a><a id="Implementation-Details-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-Details" title="Permalink"></a></h1><p>This document provides technical details about the algorithms and implementation strategies used in SymbolicDiagonalization.jl.</p><h2 id="Table-of-Contents"><a class="docs-heading-anchor" href="#Table-of-Contents">Table of Contents</a><a id="Table-of-Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Table-of-Contents" title="Permalink"></a></h2><ol><li><a href="#overview">Overview</a></li><li><a href="#characteristic-polynomial-computation">Characteristic Polynomial Computation</a></li><li><a href="#root-solvers-degrees-1-4">Root Solvers (Degrees 1-4)</a></li><li><a href="#structure-detection">Structure Detection</a></li><li><a href="#special-pattern-solvers">Special Pattern Solvers</a></li><li><a href="#eigenvector-computation">Eigenvector Computation</a></li><li><a href="#expression-management">Expression Management</a></li><li><a href="#performance-considerations">Performance Considerations</a></li></ol><hr/><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>SymbolicDiagonalization.jl uses a multi-layered approach to compute eigenvalues and eigenvectors:</p><ol><li><strong>Structure Detection</strong>: Identify exploitable matrix patterns</li><li><strong>Pattern-Specific Solvers</strong>: Use specialized algorithms for detected patterns</li><li><strong>Characteristic Polynomial</strong>: Compute det(λI - A) using Bareiss algorithm</li><li><strong>Root Finding</strong>: Solve polynomials up to degree 4 using closed-form formulas</li><li><strong>Eigenvector Computation</strong>: Use RREF-based nullspace or adjugate method</li></ol><p>The implementation prioritizes <strong>symbolic correctness</strong> over numeric efficiency, using fraction-free algorithms and avoiding floating-point operations wherever possible.</p><hr/><h2 id="Characteristic-Polynomial-Computation"><a class="docs-heading-anchor" href="#Characteristic-Polynomial-Computation">Characteristic Polynomial Computation</a><a id="Characteristic-Polynomial-Computation-1"></a><a class="docs-heading-anchor-permalink" href="#Characteristic-Polynomial-Computation" title="Permalink"></a></h2><h3 id="Algorithm:-Bareiss-Determinant"><a class="docs-heading-anchor" href="#Algorithm:-Bareiss-Determinant">Algorithm: Bareiss Determinant</a><a id="Algorithm:-Bareiss-Determinant-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm:-Bareiss-Determinant" title="Permalink"></a></h3><p>The characteristic polynomial det(λI - A) is computed using the <strong>Bareiss algorithm</strong>, a fraction-free variant of Gaussian elimination.</p><p><strong>File</strong>: <code>src/charpoly.jl</code></p><h3 id="Why-Bareiss?"><a class="docs-heading-anchor" href="#Why-Bareiss?">Why Bareiss?</a><a id="Why-Bareiss?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-Bareiss?" title="Permalink"></a></h3><p>Standard Gaussian elimination requires division, which causes intermediate expression blowup in symbolic computation:</p><ul><li><strong>Standard GE</strong>: Expressions grow like O(2^n) due to nested divisions</li><li><strong>Bareiss</strong>: Keeps expressions polynomial-sized by avoiding division until the end</li></ul><h3 id="Algorithm-Description"><a class="docs-heading-anchor" href="#Algorithm-Description">Algorithm Description</a><a id="Algorithm-Description-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-Description" title="Permalink"></a></h3><p>Given matrix M, Bareiss computes det(M) without fractions:</p><pre><code class="language-julia hljs">function _bareiss_det(M)
    n = size(M, 1)
    A = Matrix{eltype(M)}(M)
    prev = one(eltype(M))
    
    for k in 1:n-1
        pivot = A[k, k]
        _issymzero(pivot) &amp;&amp; error(&quot;zero pivot encountered&quot;)
        
        # Update submatrix using division-free formula
        for i in k+1:n, j in k+1:n
            A[i, j] = (A[i, j] * pivot - A[i, k] * A[k, j]) / prev
        end
        
        # Zero out column below pivot
        fill!(view(A, k+1:n, k), zero(eltype(M)))
        prev = pivot
    end
    
    return A[n, n]
end</code></pre><p><strong>Key insight</strong>: The formula <code>(A[i,j] * pivot - A[i,k] * A[k,j]) / prev</code> is always divisible by <code>prev</code> (the previous pivot), so no fractions appear.</p><h3 id="Complexity"><a class="docs-heading-anchor" href="#Complexity">Complexity</a><a id="Complexity-1"></a><a class="docs-heading-anchor-permalink" href="#Complexity" title="Permalink"></a></h3><ul><li><strong>Time</strong>: O(n³) symbolic operations</li><li><strong>Expression size</strong>: Polynomial growth (much better than standard methods)</li><li><strong>Space</strong>: O(n²) for the matrix</li></ul><h3 id="Coefficient-Extraction"><a class="docs-heading-anchor" href="#Coefficient-Extraction">Coefficient Extraction</a><a id="Coefficient-Extraction-1"></a><a class="docs-heading-anchor-permalink" href="#Coefficient-Extraction" title="Permalink"></a></h3><p>Instead of polynomial division (which is brittle for symbolic expressions), we use <strong>derivative-based extraction</strong>:</p><pre><code class="language-julia hljs">function _collect_coefficients(poly, λ, degree)
    coeffs = Vector{Any}(undef, degree + 1)
    coeffs[1] = substitute(poly, λ =&gt; 0)  # Constant term
    
    deriv = poly
    fact = 1
    for k in 1:degree
        deriv = derivative(deriv, λ)
        fact *= k
        coeffs[k + 1] = substitute(deriv, λ =&gt; 0) / fact
    end
    
    return coeffs
end</code></pre><p>This uses the Taylor series expansion: <code>p(λ) = Σ (p^(k)(0) / k!) * λ^k</code></p><hr/><h2 id="Root-Solvers-(Degrees-1-4)"><a class="docs-heading-anchor" href="#Root-Solvers-(Degrees-1-4)">Root Solvers (Degrees 1-4)</a><a id="Root-Solvers-(Degrees-1-4)-1"></a><a class="docs-heading-anchor-permalink" href="#Root-Solvers-(Degrees-1-4)" title="Permalink"></a></h2><h3 id="Overview-2"><a class="docs-heading-anchor" href="#Overview-2">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-2" title="Permalink"></a></h3><p>SymbolicDiagonalization.jl implements closed-form root solvers for polynomials up to degree 4:</p><table><tr><th style="text-align: right">Degree</th><th style="text-align: right">Method</th><th style="text-align: right">Formula Name</th></tr><tr><td style="text-align: right">1</td><td style="text-align: right">Linear</td><td style="text-align: right">Direct</td></tr><tr><td style="text-align: right">2</td><td style="text-align: right">Quadratic</td><td style="text-align: right">Quadratic formula</td></tr><tr><td style="text-align: right">3</td><td style="text-align: right">Cubic</td><td style="text-align: right">Cardano&#39;s method</td></tr><tr><td style="text-align: right">4</td><td style="text-align: right">Quartic</td><td style="text-align: right">Ferrari&#39;s method</td></tr></table><p><strong>File</strong>: <code>src/roots.jl</code></p><h3 id="Linear-Solver-(Degree-1)"><a class="docs-heading-anchor" href="#Linear-Solver-(Degree-1)">Linear Solver (Degree 1)</a><a id="Linear-Solver-(Degree-1)-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Solver-(Degree-1)" title="Permalink"></a></h3><p>For <code>ax + b = 0</code>:</p><pre><code class="language-julia hljs">_roots_linear(c) = [-c[1] / c[2]]  # c = [b, a]</code></pre><p><strong>Complexity</strong>: O(1) symbolic operations</p><h3 id="Quadratic-Solver-(Degree-2)"><a class="docs-heading-anchor" href="#Quadratic-Solver-(Degree-2)">Quadratic Solver (Degree 2)</a><a id="Quadratic-Solver-(Degree-2)-1"></a><a class="docs-heading-anchor-permalink" href="#Quadratic-Solver-(Degree-2)" title="Permalink"></a></h3><p>For <code>ax² + bx + c = 0</code>:</p><pre><code class="language-julia hljs">function _roots_quadratic(c)
    a, b, d = c[3], c[2], c[1]  # d is constant term
    disc = b^2 - 4a*d
    disc = _aggressive_simplify(disc)
    sqrt_disc = sqrt(disc)
    return [(-b - sqrt_disc) / (2a), (-b + sqrt_disc) / (2a)]
end</code></pre><p><strong>Key features</strong>:</p><ul><li>Discriminant simplification to reduce expression size</li><li>Symbolic square root handling</li></ul><p><strong>Complexity</strong>: O(n²) where n is the expression size</p><h3 id="Cubic-Solver-(Degree-3)"><a class="docs-heading-anchor" href="#Cubic-Solver-(Degree-3)">Cubic Solver (Degree 3)</a><a id="Cubic-Solver-(Degree-3)-1"></a><a class="docs-heading-anchor-permalink" href="#Cubic-Solver-(Degree-3)" title="Permalink"></a></h3><p>For <code>ax³ + bx² + cx + d = 0</code>, we use <strong>Cardano&#39;s method</strong>:</p><p><strong>Step 1</strong>: Depress the cubic (eliminate x² term)</p><p>Substitution <code>x = y - b/(3a)</code> transforms to: <code>y³ + py + q = 0</code></p><p>where:</p><ul><li><code>p = c/a - b²/(3a²)</code></li><li><code>q = 2b³/(27a³) - bc/(3a²) + d/a</code></li></ul><p><strong>Step 2</strong>: Compute discriminant</p><p><code>Δ = (q/2)² + (p/3)³</code></p><p><strong>Step 3</strong>: Compute cube roots</p><pre><code class="language-julia hljs">C = cbrt(-q/2 + √Δ)
D = cbrt(-q/2 - √Δ)</code></pre><p><strong>Step 4</strong>: Construct roots</p><p>Let <code>ω = exp(2πi/3) = -1/2 + (√3/2)i</code> be a primitive cube root of unity.</p><pre><code class="language-julia hljs">roots = [
    C + D,
    ω*C + ω²*D,
    ω²*C + ω*D
]</code></pre><p><strong>Step 5</strong>: Shift back</p><p><code>x = y - b/(3a)</code></p><p><strong>Complexity</strong>: O(n³) where n is the expression size</p><p><strong>Implementation notes</strong>:</p><ul><li>Aggressive simplification applied to <code>p</code>, <code>q</code>, and <code>Δ</code></li><li>Complex arithmetic handled symbolically</li><li>Numeric cube roots used with symbolic coefficients</li></ul><h3 id="Quartic-Solver-(Degree-4)"><a class="docs-heading-anchor" href="#Quartic-Solver-(Degree-4)">Quartic Solver (Degree 4)</a><a id="Quartic-Solver-(Degree-4)-1"></a><a class="docs-heading-anchor-permalink" href="#Quartic-Solver-(Degree-4)" title="Permalink"></a></h3><p>For <code>ax⁴ + bx³ + cx² + dx + e = 0</code>, we use <strong>Ferrari&#39;s method</strong> via a resolvent cubic.</p><p><strong>Step 1</strong>: Depress the quartic (eliminate x³ term)</p><p>Substitution <code>x = y - b/(4a)</code> transforms to: <code>y⁴ + py² + qy + r = 0</code></p><p>where:</p><ul><li><code>p = c/a - 3b²/(8a²)</code></li><li><code>q = d/a + b³/(8a³) - bc/(2a²)</code></li><li><code>r = e/a - 3b⁴/(256a⁴) + b²c/(16a³) - bd/(4a²)</code></li></ul><p><strong>Step 2</strong>: Solve resolvent cubic</p><p>The resolvent cubic is: <code>8z³ - 4pz² - 8rz + (4pr - q²) = 0</code></p><p>Let α be any root of this cubic (we use the first one).</p><p><strong>Step 3</strong>: Decompose into two quadratics</p><p>The depressed quartic factors as:</p><p><code>(y² + β*y + (α + γ))(y² - β*y + (α - γ)) = 0</code></p><p>where:</p><ul><li><code>β² = 2α - p</code></li><li><code>γ = -q/(2β)</code></li></ul><p><strong>Step 4</strong>: Solve quadratics</p><p>Each quadratic gives two roots using the quadratic formula.</p><p><strong>Step 5</strong>: Shift back</p><p><code>x = y - b/(4a)</code></p><p><strong>Complexity</strong>: O(n⁴) where n is the expression size</p><p><strong>Implementation details</strong>:</p><pre><code class="language-julia hljs">function _roots_quartic(c)
    # Normalize and extract coefficients
    a, b, cc, d, e = c[5], c[4], c[3], c[2], c[1]
    
    # Depress to y⁴ + py² + qy + r = 0
    p = cc/a - 3b²/(8a²)
    q = d/a + b³/(8a³) - b*cc/(2a²)
    r = e/a - 3b⁴/(256a⁴) + b²*cc/(16a³) - b*d/(4a²)
    
    # Simplify intermediate expressions
    p = _aggressive_simplify(p)
    q = _aggressive_simplify(q)
    r = _aggressive_simplify(r)
    
    # Resolvent cubic coefficients
    resolvent = [4p*r - q², -8r, -4p, 8]
    alphas = _roots_cubic(resolvent)
    alpha = alphas[1]  # Choose first root
    
    # Compute β and γ
    beta_sq = 2alpha - p
    beta_sq = _aggressive_simplify(beta_sq)
    beta = _symbolic_sqrt(beta_sq)
    gamma = -q/(2beta)
    gamma = _aggressive_simplify(gamma)
    
    # Two quadratics: y² ± β*y + (α ± γ)
    t1 = beta² - 4(alpha + gamma)
    t2 = beta² - 4(alpha - gamma)
    t1 = _aggressive_simplify(t1)
    t2 = _aggressive_simplify(t2)
    
    # Solve both quadratics
    roots_y = [
        (-beta - _symbolic_sqrt(t1)) / 2,
        (-beta + _symbolic_sqrt(t1)) / 2,
        (beta - _symbolic_sqrt(t2)) / 2,
        (beta + _symbolic_sqrt(t2)) / 2
    ]
    
    # Shift back
    return roots_y .- b/(4a)
end</code></pre><p><strong>Warning</strong>: Quartic formulas produce <strong>extremely large expressions</strong> for fully symbolic 4×4 matrices (~13.5 MB per eigenvalue).</p><hr/><h2 id="Structure-Detection"><a class="docs-heading-anchor" href="#Structure-Detection">Structure Detection</a><a id="Structure-Detection-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-Detection" title="Permalink"></a></h2><h3 id="Overview-3"><a class="docs-heading-anchor" href="#Overview-3">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-3" title="Permalink"></a></h3><p>Before attempting expensive polynomial root finding, we try to detect exploitable matrix structure.</p><p><strong>File</strong>: <code>src/diagonalize.jl</code> (functions starting with <code>_is_*</code> and <code>_detect_*</code>)</p><h3 id="Detection-Hierarchy"><a class="docs-heading-anchor" href="#Detection-Hierarchy">Detection Hierarchy</a><a id="Detection-Hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Detection-Hierarchy" title="Permalink"></a></h3><pre><code class="nohighlight hljs">Structure Detection
├── Diagonal (_is_diagonal)
├── Triangular (_is_triangular)
├── Block-Diagonal (_detect_multiple_blocks)
├── Persymmetric (_is_persymmetric)
├── Circulant (_is_circulant)
├── Block Circulant (_is_block_circulant)
├── Toeplitz Tridiagonal (_is_toeplitz_tridiagonal)
├── Anti-Diagonal (_is_antidiagonal)
├── Permutation (_is_permutation_matrix)
├── Kronecker Product (_is_kronecker_product)
└── Special 5×5 (_detect_special_5x5_tridiagonal)</code></pre><h3 id="Implementation-Details-2"><a class="docs-heading-anchor" href="#Implementation-Details-2">Implementation Details</a><a class="docs-heading-anchor-permalink" href="#Implementation-Details-2" title="Permalink"></a></h3><h4 id="Symbolic-Zero-Detection"><a class="docs-heading-anchor" href="#Symbolic-Zero-Detection">Symbolic Zero Detection</a><a id="Symbolic-Zero-Detection-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Zero-Detection" title="Permalink"></a></h4><p>All structure detection relies on checking if expressions are zero:</p><pre><code class="language-julia hljs">function _issymzero(x)
    # Try standard iszero
    try
        v = Base.iszero(x)
        if v isa Bool
            return v
        end
    catch
    end
    
    # Try simplify then check
    try
        sx = Symbolics.simplify(x)
        v = Symbolics.iszero(sx)
        return v === true
    catch
    end
    
    # Try direct Symbolics.iszero
    try
        v = Symbolics.iszero(x)
        return v === true
    catch
    end
    
    # Conservative: not proven zero
    return false
end</code></pre><p><strong>Key insight</strong>: We return <code>false</code> if we can&#39;t prove it&#39;s zero (conservative approach).</p><h4 id="Diagonal-Detection"><a class="docs-heading-anchor" href="#Diagonal-Detection">Diagonal Detection</a><a id="Diagonal-Detection-1"></a><a class="docs-heading-anchor-permalink" href="#Diagonal-Detection" title="Permalink"></a></h4><pre><code class="language-julia hljs">function _is_diagonal(mat)
    m, n = size(mat)
    for i in 1:m, j in 1:n
        i == j &amp;&amp; continue
        !_issymzero(mat[i, j]) &amp;&amp; return false
    end
    return true
end</code></pre><p><strong>Complexity</strong>: O(n²) symbolic zero checks</p><h4 id="Block-Diagonal-Detection"><a class="docs-heading-anchor" href="#Block-Diagonal-Detection">Block-Diagonal Detection</a><a id="Block-Diagonal-Detection-1"></a><a class="docs-heading-anchor-permalink" href="#Block-Diagonal-Detection" title="Permalink"></a></h4><p>Finds all block-diagonal structure using a greedy algorithm:</p><pre><code class="language-julia hljs">function _detect_multiple_blocks(mat)
    n = size(mat, 1)
    blocks = Tuple{Int,Int}[]
    current_start = 1
    
    while current_start &lt;= n
        # Find smallest block starting at current_start
        block_end = n  # Default: extend to end
        
        for k in current_start:(n-1)
            # Check if [current_start:k, k+1:n] and [k+1:n, current_start:k] are zero
            upper_right_zero = all(_issymzero, mat[i, j] 
                for i in current_start:k, j in (k+1):n)
            lower_left_zero = all(_issymzero, mat[i, j] 
                for i in (k+1):n, j in current_start:k)
            
            if upper_right_zero &amp;&amp; lower_left_zero
                block_end = k
                break
            end
        end
        
        push!(blocks, (current_start, block_end))
        current_start = block_end + 1
    end
    
    # Only return if we found actual blocks (more than just the whole matrix)
    return length(blocks) &gt; 1 ? blocks : nothing
end</code></pre><p><strong>Complexity</strong>: O(n⁴) symbolic operations in worst case</p><h4 id="Circulant-Detection"><a class="docs-heading-anchor" href="#Circulant-Detection">Circulant Detection</a><a id="Circulant-Detection-1"></a><a class="docs-heading-anchor-permalink" href="#Circulant-Detection" title="Permalink"></a></h4><pre><code class="language-julia hljs">function _is_circulant(mat)
    n = size(mat, 1)
    first_row = mat[1, :]
    
    # Check each row is a cyclic shift of the first row
    for i in 2:n
        for j in 1:n
            expected_idx = mod1(j - (i - 1), n)
            if !_issymzero(mat[i, j] - first_row[expected_idx])
                return false
            end
        end
    end
    
    return true
end</code></pre><p><strong>Complexity</strong>: O(n²) symbolic zero checks</p><h4 id="Block-Circulant-Detection"><a class="docs-heading-anchor" href="#Block-Circulant-Detection">Block Circulant Detection</a><a id="Block-Circulant-Detection-1"></a><a class="docs-heading-anchor-permalink" href="#Block-Circulant-Detection" title="Permalink"></a></h4><p>Tries different block sizes k where n is divisible by k:</p><pre><code class="language-julia hljs">function _is_block_circulant(mat)
    m, n = size(mat)
    m == n || return nothing
    
    # Try different block sizes
    for k in 2:div(m, 2)
        m % k == 0 || continue
        n_blocks = div(m, k)
        
        # Extract blocks from first block row
        blocks = [mat[1:k, (i-1)*k+1:i*k] for i in 1:n_blocks]
        
        # Check if each block row is a cyclic shift
        is_block_circulant = true
        for block_row in 2:n_blocks
            for block_col in 1:n_blocks
                shift_idx = mod1(block_col - (block_row - 1), n_blocks)
                expected_block = blocks[shift_idx]
                actual_block = mat[(block_row-1)*k+1:block_row*k, 
                                  (block_col-1)*k+1:block_col*k]
                
                # Check if blocks match
                if !all(_issymzero(actual_block[i, j] - expected_block[i, j]) 
                       for i in 1:k, j in 1:k)
                    is_block_circulant = false
                    break
                end
            end
            is_block_circulant || break
        end
        
        if is_block_circulant
            return (n_blocks, k, blocks)
        end
    end
    
    return nothing
end</code></pre><p><strong>Complexity</strong>: O(n⁴) in worst case (trying all block sizes)</p><h4 id="Kronecker-Product-Detection"><a class="docs-heading-anchor" href="#Kronecker-Product-Detection">Kronecker Product Detection</a><a id="Kronecker-Product-Detection-1"></a><a class="docs-heading-anchor-permalink" href="#Kronecker-Product-Detection" title="Permalink"></a></h4><p>Tries different factorizations N = m × n:</p><pre><code class="language-julia hljs">function _is_kronecker_product(mat)
    N = size(mat, 1)
    
    # Try factorizations N = m * n
    for m in 2:div(N, 2)
        N % m == 0 || continue
        n = div(N, m)
        
        # Extract candidate B from (1,1) block
        B_candidate = mat[1:n, 1:n]
        
        # Try to extract A by looking at block pattern
        A = zeros(eltype(mat), m, m)
        
        for i_block in 1:m, j_block in 1:m
            block = mat[(i_block-1)*n+1:i_block*n, (j_block-1)*n+1:j_block*n]
            
            # Find scalar such that block = scalar * B_candidate
            scalar = find_scalar_multiple(block, B_candidate)
            
            # Verify block = scalar * B_candidate
            if verify_match(block, scalar, B_candidate)
                A[i_block, j_block] = scalar
            else
                @goto next_factorization
            end
        end
        
        return (A, B_candidate, m, n)
        
        @label next_factorization
    end
    
    return nothing
end</code></pre><p><strong>Complexity</strong>: O(n⁵) in worst case</p><h4 id="Permutation-Matrix-Detection"><a class="docs-heading-anchor" href="#Permutation-Matrix-Detection">Permutation Matrix Detection</a><a id="Permutation-Matrix-Detection-1"></a><a class="docs-heading-anchor-permalink" href="#Permutation-Matrix-Detection" title="Permalink"></a></h4><pre><code class="language-julia hljs">function _is_permutation_matrix(A)
    n = size(A, 1)
    
    # Check each row has exactly one 1 and rest zeros
    for i in 1:n
        count_ones = sum(_issymzero(A[i, j] - 1) for j in 1:n)
        count_ones == 1 || return false
        
        # Check rest are zeros
        for j in 1:n
            !_issymzero(A[i, j] - 1) &amp;&amp; !_issymzero(A[i, j]) &amp;&amp; return false
        end
    end
    
    # Check each column has exactly one 1
    for j in 1:n
        count_ones = sum(_issymzero(A[i, j] - 1) for i in 1:n)
        count_ones == 1 || return false
    end
    
    return true
end</code></pre><p><strong>Complexity</strong>: O(n²) symbolic zero checks</p><hr/><h2 id="Special-Pattern-Solvers"><a class="docs-heading-anchor" href="#Special-Pattern-Solvers">Special Pattern Solvers</a><a id="Special-Pattern-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Special-Pattern-Solvers" title="Permalink"></a></h2><h3 id="Circulant-Matrices"><a class="docs-heading-anchor" href="#Circulant-Matrices">Circulant Matrices</a><a id="Circulant-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Circulant-Matrices" title="Permalink"></a></h3><p><strong>Theory</strong>: A circulant matrix has eigenvalues given by the DFT of its first row.</p><p>For circulant matrix C = circ(c₀, c₁, ..., c_{n-1}):</p><p><code>λⱼ = Σₖ cₖ ωʲᵏ</code> for j = 0, 1, ..., n-1</p><p>where ω = exp(2πi/n).</p><pre><code class="language-julia hljs">function _circulant_eigenvalues(mat)
    n = size(mat, 1)
    first_row = mat[1, :]
    eigenvalues = Vector{Any}(undef, n)
    
    for j in 0:(n-1)
        λ = first_row[1]  # c₀ term
        
        for k in 1:(n-1)
            θ = 2π * j * k / n
            ω_power = cos(θ) + im * sin(θ)
            λ += first_row[k+1] * ω_power
        end
        
        eigenvalues[j+1] = Symbolics.simplify(λ)
    end
    
    return eigenvalues
end</code></pre><p><strong>Complexity</strong>: O(n²) symbolic operations (much better than O(n³) for general case)</p><h3 id="Block-Circulant-Matrices"><a class="docs-heading-anchor" href="#Block-Circulant-Matrices">Block Circulant Matrices</a><a id="Block-Circulant-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Block-Circulant-Matrices" title="Permalink"></a></h3><p><strong>Theory</strong>: Block circulant reduces to n separate k×k eigenvalue problems.</p><p>For block circulant with blocks [A₀, A₁, ..., A_{n-1}]:</p><p>Eigenvalues = ⋃ⱼ eigvals(Dⱼ)</p><p>where <code>Dⱼ = Σₖ ωʲᵏ Aₖ</code> and ω = exp(2πi/n).</p><pre><code class="language-julia hljs">function _block_circulant_eigenvalues(mat, n_blocks, block_size, blocks)
    all_eigenvalues = []
    
    for j in 0:(n_blocks-1)
        # Compute Dⱼ = Σₖ ωʲᵏ Aₖ
        D_j = zeros(eltype(mat), block_size, block_size)
        
        for k in 0:(n_blocks-1)
            θ = 2π * j * k / n_blocks
            ω_power = cos(θ) + im * sin(θ)
            D_j .+= ω_power .* blocks[k + 1]
        end
        
        # Recursively solve k×k eigenvalue problem
        D_j = Symbolics.simplify.(D_j)
        vals_j, _, _ = symbolic_eigenvalues(D_j)
        append!(all_eigenvalues, vals_j)
    end
    
    return all_eigenvalues
end</code></pre><p><strong>Complexity</strong>: O(n × T(k)) where T(k) is time to solve k×k matrix</p><h3 id="Toeplitz-Tridiagonal-Matrices"><a class="docs-heading-anchor" href="#Toeplitz-Tridiagonal-Matrices">Toeplitz Tridiagonal Matrices</a><a id="Toeplitz-Tridiagonal-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Toeplitz-Tridiagonal-Matrices" title="Permalink"></a></h3><p><strong>Theory</strong>: Symmetric Toeplitz tridiagonal has closed-form eigenvalues via orthogonal polynomials.</p><p>For matrix with diagonal a and off-diagonals b:</p><p><code>λₖ = a + 2b cos(kπ/(n+1))</code> for k = 1, 2, ..., n</p><pre><code class="language-julia hljs">function _toeplitz_tridiagonal_eigenvalues(n, a, b, c)
    eigenvalues = Vector{Any}(undef, n)
    
    for k in 1:n
        θ = k * π / (n + 1)
        λₖ = a + 2 * b * cos(θ)
        eigenvalues[k] = Symbolics.simplify(λₖ)
    end
    
    return eigenvalues
end</code></pre><p><strong>Complexity</strong>: O(n) symbolic operations (optimal!)</p><h3 id="Kronecker-Products"><a class="docs-heading-anchor" href="#Kronecker-Products">Kronecker Products</a><a id="Kronecker-Products-1"></a><a class="docs-heading-anchor-permalink" href="#Kronecker-Products" title="Permalink"></a></h3><p><strong>Theory</strong>: If A has eigenvalues {λᵢ} and B has eigenvalues {μⱼ}, then A ⊗ B has eigenvalues {λᵢ μⱼ}.</p><pre><code class="language-julia hljs">function _kronecker_eigenvalues(A, B, m, n)
    # Compute eigenvalues of A
    λ_A, _, _ = symbolic_eigenvalues(A)
    
    # Compute eigenvalues of B
    λ_B, _, _ = symbolic_eigenvalues(B)
    
    # Compute all products λᵢ * μⱼ
    eigenvalues = []
    for λ in λ_A, μ in λ_B
        push!(eigenvalues, λ * μ)
    end
    
    return eigenvalues
end</code></pre><p><strong>Complexity</strong>: O(T(m) + T(n) + mn) where T(k) is time to solve k×k matrix</p><h3 id="Permutation-Matrices"><a class="docs-heading-anchor" href="#Permutation-Matrices">Permutation Matrices</a><a id="Permutation-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Permutation-Matrices" title="Permalink"></a></h3><p><strong>Theory</strong>: Eigenvalues are roots of unity determined by cycle structure.</p><p>For a cycle of length k: eigenvalues are <code>exp(2πij/k)</code> for j = 0, 1, ..., k-1</p><pre><code class="language-julia hljs">function _compute_permutation_eigenvalues(A)
    cycles = _permutation_to_cycles(A)
    eigenvalues = []
    
    for cycle_length in cycles
        if cycle_length == 1
            push!(eigenvalues, 1)  # Fixed point
        elseif cycle_length == 2
            push!(eigenvalues, 1, -1)  # Transposition
        else
            # k-th roots of unity
            for j in 0:(cycle_length - 1)
                angle = 2π * j / cycle_length
                push!(eigenvalues, exp(im * angle))
            end
        end
    end
    
    return eigenvalues
end</code></pre><p><strong>Complexity</strong>: O(n) to find cycles, O(n) to generate eigenvalues</p><h3 id="Anti-Diagonal-Matrices"><a class="docs-heading-anchor" href="#Anti-Diagonal-Matrices">Anti-Diagonal Matrices</a><a id="Anti-Diagonal-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Anti-Diagonal-Matrices" title="Permalink"></a></h3><p><strong>Theory</strong>: Symmetric anti-diagonal has eigenvalues in ±pairs.</p><p>For anti-diagonal entries [a₁, a₂, ..., aₙ]:</p><ul><li>Odd n: eigenvalues are [a<em>{mid}, ±a₁, ±a₂, ..., ±a</em>{mid-1}]</li><li>Even n: eigenvalues are [±a₁, ±a₂, ..., ±a_{n/2}]</li></ul><pre><code class="language-julia hljs">function _antidiagonal_eigenvalues(mat)
    n = size(mat, 1)
    antidiag = [mat[i, n + 1 - i] for i in 1:n]
    
    if n % 2 == 1
        # Odd: one middle eigenvalue, rest in pairs
        mid = (n + 1) ÷ 2
        eigenvalues = [antidiag[mid]]
        for i in 1:mid-1
            push!(eigenvalues, antidiag[i], -antidiag[i])
        end
    else
        # Even: all in pairs
        eigenvalues = []
        for i in 1:n÷2
            push!(eigenvalues, antidiag[i], -antidiag[i])
        end
    end
    
    return eigenvalues
end</code></pre><p><strong>Complexity</strong>: O(n) symbolic operations</p><h3 id="Persymmetric-Splitting"><a class="docs-heading-anchor" href="#Persymmetric-Splitting">Persymmetric Splitting</a><a id="Persymmetric-Splitting-1"></a><a class="docs-heading-anchor-permalink" href="#Persymmetric-Splitting" title="Permalink"></a></h3><p><strong>Theory</strong>: Symmetric persymmetric matrices (Q[i,j] = Q[n+1-j, n+1-i]) can be split into two half-sized blocks.</p><pre><code class="language-julia hljs">function _persymmetric_split(mat)
    n = size(mat, 1)
    n % 2 != 0 &amp;&amp; return nothing  # Only for even n
    
    # Build transformation matrix P = [(I+J)/√2, (I-J)/√2]
    # where J is the exchange matrix (anti-identity)
    
    half = div(n, 2)
    P = zeros(eltype(mat), n, n)
    
    # First half: e_i + e_{n+1-i}
    for i in 1:half
        P[i, i] = 1
        P[n+1-i, i] = 1
    end
    
    # Second half: e_i - e_{n+1-i}
    for i in 1:half
        P[i, half+i] = 1
        P[n+1-i, half+i] = -1
    end
    
    # Transform: Q_new = P^T * Q * P
    Q_transformed = transpose(P) * mat * P
    
    # Extract blocks (and divide by 2 for normalization)
    block1 = Q_transformed[1:half, 1:half] ./ 2
    block2 = Q_transformed[half+1:end, half+1:end] ./ 2
    
    return (block1, block2, P)
end</code></pre><p><strong>Complexity</strong>: O(n³) for matrix multiplication</p><hr/><h2 id="Eigenvector-Computation"><a class="docs-heading-anchor" href="#Eigenvector-Computation">Eigenvector Computation</a><a id="Eigenvector-Computation-1"></a><a class="docs-heading-anchor-permalink" href="#Eigenvector-Computation" title="Permalink"></a></h2><h3 id="Two-Approaches"><a class="docs-heading-anchor" href="#Two-Approaches">Two Approaches</a><a id="Two-Approaches-1"></a><a class="docs-heading-anchor-permalink" href="#Two-Approaches" title="Permalink"></a></h3><p>SymbolicDiagonalization.jl uses two complementary methods:</p><ol><li><strong>Adjugate method</strong> (for small matrices, ≤ 3×3)</li><li><strong>RREF-based nullspace</strong> (general case)</li></ol><p><strong>File</strong>: <code>src/rref.jl</code>, <code>src/diagonalize.jl</code></p><h3 id="Adjugate-Method"><a class="docs-heading-anchor" href="#Adjugate-Method">Adjugate Method</a><a id="Adjugate-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Adjugate-Method" title="Permalink"></a></h3><p>For A - λI singular (λ is eigenvalue), the adjugate matrix adj(A - λI) has all columns in the nullspace.</p><pre><code class="language-julia hljs">function _adjugate_vectors(M)
    n = size(M, 1)
    n &lt;= 3 || return []  # Only for small matrices
    
    adj = _adjugate(M)
    
    # Return first non-zero column
    for j in 1:n
        col = Symbolics.simplify.(adj[:, j])
        all(_issymzero, col) &amp;&amp; continue
        return [col]  # Return immediately
    end
    
    return []
end

function _adjugate(M)
    n = size(M, 1)
    adj = Matrix{eltype(M)}(undef, n, n)
    
    for i in 1:n, j in 1:n
        minor_det = _minor_det(M, i, j)
        adj[j, i] = (-1)^(i + j) * minor_det
    end
    
    return Symbolics.simplify.(adj)
end</code></pre><p><strong>Advantages</strong>:</p><ul><li>Avoids RREF pivoting issues</li><li>More compact expressions for small matrices</li></ul><p><strong>Disadvantages</strong>:</p><ul><li>Only works for n ≤ 3 (determinant computation explodes)</li><li>May return zero vector if unlucky</li></ul><h3 id="RREF-Based-Nullspace"><a class="docs-heading-anchor" href="#RREF-Based-Nullspace">RREF-Based Nullspace</a><a id="RREF-Based-Nullspace-1"></a><a class="docs-heading-anchor-permalink" href="#RREF-Based-Nullspace" title="Permalink"></a></h3><p>General method that works for any size:</p><pre><code class="language-julia hljs">function _nullspace(M)
    # Simplify entries first
    simplified = Symbolics.simplify.(M)
    
    # Compute RREF
    R, pivots = _rref(Symbolics.expand.(simplified))
    
    m, n = size(R)
    free = setdiff(1:n, pivots)  # Free variables
    
    vectors = []
    for f in free
        # Set free variable to 1, solve for pivot variables
        v = fill(zero(eltype(R)), n)
        v[f] = one(eltype(R))
        
        for (row, pivot_col) in enumerate(pivots)
            v[pivot_col] = Symbolics.simplify(-R[row, f])
        end
        
        push!(vectors, Symbolics.simplify.(v))
    end
    
    return vectors
end</code></pre><p><strong>Complexity</strong>: O(n³) symbolic operations</p><h3 id="RREF-Algorithm"><a class="docs-heading-anchor" href="#RREF-Algorithm">RREF Algorithm</a><a id="RREF-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#RREF-Algorithm" title="Permalink"></a></h3><p>Row reduction to reduced row echelon form:</p><pre><code class="language-julia hljs">function _rref(M)
    A = copy(Matrix(M))
    m, n = size(A)
    pivots = Int[]
    row = 1
    
    for col in 1:n
        # Find pivot
        pivot_row = _find_pivot(A, row, col)
        isnothing(pivot_row) &amp;&amp; continue
        
        # Swap rows
        if pivot_row != row
            A[row, :], A[pivot_row, :] = A[pivot_row, :], A[row, :]
        end
        
        # Normalize pivot row
        pivot = Symbolics.simplify(A[row, col])
        A[row, :] .= Symbolics.simplify.(A[row, :] ./ pivot)
        
        # Eliminate column in all other rows
        for r in 1:m
            r == row &amp;&amp; continue
            factor = A[r, col]
            _issymzero(factor) &amp;&amp; continue
            A[r, :] .= Symbolics.simplify.(A[r, :] .- factor .* A[row, :])
        end
        
        push!(pivots, col)
        row += 1
        row &gt; m &amp;&amp; break
    end
    
    return A, pivots
end</code></pre><p><strong>Key features</strong>:</p><ul><li>Simplification after each operation to keep expressions manageable</li><li>Symbolic pivot selection (uses <code>_issymzero</code>)</li><li>Full row elimination (not just below pivot)</li></ul><p><strong>Complexity</strong>: O(mn² × s) where s is average expression size</p><hr/><h2 id="Expression-Management"><a class="docs-heading-anchor" href="#Expression-Management">Expression Management</a><a id="Expression-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Expression-Management" title="Permalink"></a></h2><h3 id="The-Expression-Explosion-Problem"><a class="docs-heading-anchor" href="#The-Expression-Explosion-Problem">The Expression Explosion Problem</a><a id="The-Expression-Explosion-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#The-Expression-Explosion-Problem" title="Permalink"></a></h3><p>Symbolic computation faces a fundamental challenge: <strong>expressions grow exponentially</strong> without careful management.</p><p>Example: A 3×3 symbolic matrix can produce eigenvalues with 1000+ terms. A 4×4 symbolic matrix can produce eigenvalues with 10,000+ terms (~13.5 MB each!).</p><h3 id="Strategy:-Aggressive-Simplification"><a class="docs-heading-anchor" href="#Strategy:-Aggressive-Simplification">Strategy: Aggressive Simplification</a><a id="Strategy:-Aggressive-Simplification-1"></a><a class="docs-heading-anchor-permalink" href="#Strategy:-Aggressive-Simplification" title="Permalink"></a></h3><p>We apply simplification at <strong>every intermediate step</strong> of computation:</p><pre><code class="language-julia hljs">function _aggressive_simplify(expr; max_terms = 10000)
    !_is_symbolic_coeff(expr) &amp;&amp; return expr
    
    # Expand first to collect all terms
    expanded = Symbolics.expand(expr)
    
    # Check complexity
    _check_expression_size(expanded, max_terms)
    
    # Simplify
    simplified = Symbolics.simplify(expanded)
    
    # Try to factor perfect squares (TODO: not yet implemented)
    factored = _try_factor_perfect_square(simplified)
    
    return factored
end</code></pre><p><strong>Applied in</strong>:</p><ul><li>Quadratic discriminant</li><li>Cubic coefficients p, q, Δ</li><li>Quartic coefficients p, q, r, and intermediate β², γ, t₁, t₂</li><li>RREF operations</li><li>Eigenvector construction</li></ul><h3 id="Expression-Size-Estimation"><a class="docs-heading-anchor" href="#Expression-Size-Estimation">Expression Size Estimation</a><a id="Expression-Size-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Expression-Size-Estimation" title="Permalink"></a></h3><p>We estimate expression complexity by counting operations:</p><pre><code class="language-julia hljs">function _estimate_expr_size(expr)
    !_is_symbolic_coeff(expr) &amp;&amp; return 1
    
    try
        unwrapped = Symbolics.unwrap(expr)
        return _count_operations(unwrapped)
    catch
        return 1
    end
end

function _count_operations(x)
    # Base case: leaf node
    if x isa Number || !isdefined(x, :f)
        return 1
    end
    
    # Recursive case: count children
    if isdefined(x, :arguments)
        args = getfield(x, :arguments)
        return 1 + sum(_count_operations, args; init=0)
    end
    
    return 1
end</code></pre><h3 id="Complexity-Threshold-Errors"><a class="docs-heading-anchor" href="#Complexity-Threshold-Errors">Complexity Threshold Errors</a><a id="Complexity-Threshold-Errors-1"></a><a class="docs-heading-anchor-permalink" href="#Complexity-Threshold-Errors" title="Permalink"></a></h3><p>When expressions exceed limits, we throw helpful errors:</p><pre><code class="language-julia hljs">throw(ExpressionComplexityError(
    &quot;&quot;&quot;Expression has grown too large (≈$size terms, limit: $max_terms).
    
    Suggestions:
    1. Reduce matrix size (try 2×2 or 3×3 instead of 4×4)
    2. Use fewer symbolic variables
    3. Exploit matrix structure
    4. Use numeric eigenvalues
    5. Increase limit with max_terms parameter (caution!)
    &quot;&quot;&quot;
))</code></pre><h3 id="Timeout-Mechanism"><a class="docs-heading-anchor" href="#Timeout-Mechanism">Timeout Mechanism</a><a id="Timeout-Mechanism-1"></a><a class="docs-heading-anchor-permalink" href="#Timeout-Mechanism" title="Permalink"></a></h3><p>Long-running computations can be interrupted:</p><pre><code class="language-julia hljs">function _with_timeout(f, timeout_seconds, degree)
    task = @async f()
    timeout_task = @async (sleep(timeout_seconds); true)
    
    # Wait for either task or timeout
    while !istaskdone(task) &amp;&amp; !istaskdone(timeout_task)
        sleep(0.1)
    end
    
    if istaskdone(timeout_task)
        # Timeout occurred
        schedule(task, InterruptException(), error=true)
        throw(ComputationTimeoutError(&quot;Computation exceeded $timeout_seconds seconds&quot;))
    end
    
    return fetch(task)
end</code></pre><p><strong>Default timeout</strong>: 300 seconds (5 minutes) <strong>Can be disabled</strong>: Set <code>timeout = nothing</code></p><h3 id="Symbolic-Square-Root-for-Complex-Numbers"><a class="docs-heading-anchor" href="#Symbolic-Square-Root-for-Complex-Numbers">Symbolic Square Root for Complex Numbers</a><a id="Symbolic-Square-Root-for-Complex-Numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Square-Root-for-Complex-Numbers" title="Permalink"></a></h3><p>Julia&#39;s <code>sqrt(::Complex)</code> has boolean checks that fail for symbolic values. We implement it directly:</p><pre><code class="language-julia hljs">function _symbolic_sqrt(x)
    !(x isa Complex) &amp;&amp; return sqrt(x)
    
    # For Complex{Num}, implement formula manually:
    # sqrt(a + bi) = sqrt((r+a)/2) + i*sign(b)*sqrt((r-a)/2)
    # where r = sqrt(a² + b²)
    
    a = real(x)
    b = imag(x)
    r = sqrt(a^2 + b^2)
    
    real_part = sqrt((r + a) / 2)
    imag_part = sqrt((r - a) / 2)
    
    return Complex(real_part, imag_part)
end</code></pre><hr/><h2 id="Performance-Considerations"><a class="docs-heading-anchor" href="#Performance-Considerations">Performance Considerations</a><a id="Performance-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Considerations" title="Permalink"></a></h2><h3 id="Complexity-Summary"><a class="docs-heading-anchor" href="#Complexity-Summary">Complexity Summary</a><a id="Complexity-Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Complexity-Summary" title="Permalink"></a></h3><table><tr><th style="text-align: right">Operation</th><th style="text-align: right">Complexity</th><th style="text-align: right">Notes</th></tr><tr><td style="text-align: right">Bareiss determinant</td><td style="text-align: right">O(n³)</td><td style="text-align: right">Polynomial expression growth</td></tr><tr><td style="text-align: right">Coefficient extraction</td><td style="text-align: right">O(n)</td><td style="text-align: right">Using derivatives</td></tr><tr><td style="text-align: right">Quadratic formula</td><td style="text-align: right">O(n²)</td><td style="text-align: right">Expression size grows quadratically</td></tr><tr><td style="text-align: right">Cubic formula</td><td style="text-align: right">O(n³)</td><td style="text-align: right">Cardano&#39;s method</td></tr><tr><td style="text-align: right">Quartic formula</td><td style="text-align: right">O(n⁴)</td><td style="text-align: right">Ferrari&#39;s method</td></tr><tr><td style="text-align: right">RREF</td><td style="text-align: right">O(mn² × s)</td><td style="text-align: right">s = average expression size</td></tr><tr><td style="text-align: right">Nullspace</td><td style="text-align: right">O(n³ × s)</td><td style="text-align: right">After RREF</td></tr><tr><td style="text-align: right">Circulant eigenvalues</td><td style="text-align: right">O(n²)</td><td style="text-align: right">DFT-based</td></tr><tr><td style="text-align: right">Tridiagonal eigenvalues</td><td style="text-align: right">O(n)</td><td style="text-align: right">Closed-form formula</td></tr><tr><td style="text-align: right">Block decomposition</td><td style="text-align: right">O(k × T(n/k))</td><td style="text-align: right">k blocks of size n/k</td></tr></table><h3 id="Bottlenecks"><a class="docs-heading-anchor" href="#Bottlenecks">Bottlenecks</a><a id="Bottlenecks-1"></a><a class="docs-heading-anchor-permalink" href="#Bottlenecks" title="Permalink"></a></h3><ol><li><strong>Quartic formula</strong>: Produces massive expressions for fully symbolic 4×4 matrices</li><li><strong>RREF</strong>: Simplification at each step can be slow for large expressions</li><li><strong>Structure detection</strong>: O(n⁴) for some patterns (block circulant, Kronecker)</li><li><strong>Symbolic simplification</strong>: Symbolics.jl simplification is not always fast</li></ol><h3 id="Optimization-Strategies"><a class="docs-heading-anchor" href="#Optimization-Strategies">Optimization Strategies</a><a id="Optimization-Strategies-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Strategies" title="Permalink"></a></h3><p><strong>For users</strong>:</p><ol><li>Use structured matrices (block-diagonal, circulant, tridiagonal)</li><li>Substitute numeric values for some variables</li><li>Request eigenvalues only (skip eigenvectors)</li><li>Use smaller matrices (2×2, 3×3 much faster than 4×4)</li><li>Set <code>expand=false</code> to skip polynomial expansion</li></ol><p><strong>For developers</strong>:</p><ol><li>Add more special pattern detectors</li><li>Improve expression simplification (factor perfect squares, etc.)</li><li>Cache intermediate results</li><li>Parallelize independent computations (when thread-safe)</li><li>Add more structural decompositions (Schur complement, etc.)</li></ol><h3 id="Memory-Usage"><a class="docs-heading-anchor" href="#Memory-Usage">Memory Usage</a><a id="Memory-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Usage" title="Permalink"></a></h3><p>Approximate memory usage for fully symbolic n×n matrices:</p><table><tr><th style="text-align: right">Size</th><th style="text-align: right">Eigenvalues</th><th style="text-align: right">With Eigenvectors</th></tr><tr><td style="text-align: right">2×2</td><td style="text-align: right">~1 KB</td><td style="text-align: right">~5 KB</td></tr><tr><td style="text-align: right">3×3</td><td style="text-align: right">~100 KB</td><td style="text-align: right">~500 KB</td></tr><tr><td style="text-align: right">4×4</td><td style="text-align: right">~50 MB</td><td style="text-align: right">~200 MB</td></tr><tr><td style="text-align: right">5×5</td><td style="text-align: right">N/A*</td><td style="text-align: right">N/A*</td></tr></table><p>*5×5 requires special structure (not general case)</p><h3 id="Parallelization-Challenges"><a class="docs-heading-anchor" href="#Parallelization-Challenges">Parallelization Challenges</a><a id="Parallelization-Challenges-1"></a><a class="docs-heading-anchor-permalink" href="#Parallelization-Challenges" title="Permalink"></a></h3><p><strong>Why we don&#39;t parallelize</strong>:</p><p>Symbolics.jl uses <strong>task-local storage</strong> for hashconsing (expression deduplication), which is <strong>not thread-safe</strong>.</p><p>Attempting to use <code>Threads.@threads</code> causes crashes:</p><pre><code class="language-julia hljs"># DON&#39;T DO THIS:
Threads.@threads for v in vals
    vecs = _nullspace(mat .- v .* I)  # CRASHES!
end</code></pre><p><strong>Potential solution</strong>: Use process-based parallelism (Distributed.jl) instead of threads.</p><h3 id="Test-Coverage"><a class="docs-heading-anchor" href="#Test-Coverage">Test Coverage</a><a id="Test-Coverage-1"></a><a class="docs-heading-anchor-permalink" href="#Test-Coverage" title="Permalink"></a></h3><p>The test suite includes 172 tests covering:</p><ul><li>All root solvers (linear through quartic)</li><li>All structure detectors</li><li>All special pattern solvers</li><li>Edge cases (zero matrices, identity, etc.)</li><li>Error handling (timeouts, complexity errors)</li></ul><p><strong>Execution time</strong>: 37.4 seconds</p><hr/><h2 id="Future-Improvements"><a class="docs-heading-anchor" href="#Future-Improvements">Future Improvements</a><a id="Future-Improvements-1"></a><a class="docs-heading-anchor-permalink" href="#Future-Improvements" title="Permalink"></a></h2><h3 id="Algorithm-Enhancements"><a class="docs-heading-anchor" href="#Algorithm-Enhancements">Algorithm Enhancements</a><a id="Algorithm-Enhancements-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-Enhancements" title="Permalink"></a></h3><ol><li><strong>Schur decomposition</strong>: For upper triangular form</li><li><strong>QR algorithm</strong>: Iterative eigenvalue refinement</li><li><strong>Lanczos algorithm</strong>: For large sparse matrices</li><li><strong>Power method</strong>: For dominant eigenvalue</li></ol><h3 id="Pattern-Detection"><a class="docs-heading-anchor" href="#Pattern-Detection">Pattern Detection</a><a id="Pattern-Detection-1"></a><a class="docs-heading-anchor-permalink" href="#Pattern-Detection" title="Permalink"></a></h3><ol><li><strong>Hamiltonian matrices</strong>: J-orthogonal structure</li><li><strong>Hankel matrices</strong>: Related to Toeplitz</li><li><strong>Cauchy matrices</strong>: Explicit determinant formulas</li><li><strong>Vandermonde matrices</strong>: Closed-form determinant</li></ol><h3 id="Expression-Optimization"><a class="docs-heading-anchor" href="#Expression-Optimization">Expression Optimization</a><a id="Expression-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Expression-Optimization" title="Permalink"></a></h3><ol><li><strong>Perfect square factoring</strong>: Detect and factor (a-b)² + c²</li><li><strong>Common subexpression elimination</strong>: Deduplicate repeated subexpressions</li><li><strong>Gröbner basis reduction</strong>: Polynomial ideal membership</li><li><strong>Numerical stability analysis</strong>: Detect ill-conditioned expressions</li></ol><h3 id="User-Experience"><a class="docs-heading-anchor" href="#User-Experience">User Experience</a><a id="User-Experience-1"></a><a class="docs-heading-anchor-permalink" href="#User-Experience" title="Permalink"></a></h3><ol><li><strong>Progress bars</strong>: For long computations</li><li><strong>Incremental results</strong>: Return partial results before timeout</li><li><strong>Symbolic assumptions</strong>: Propagate assumptions (real, positive, etc.)</li><li><strong>Pretty printing</strong>: Better display of large expressions</li></ol><hr/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><h3 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h3><ol><li><p><strong>Bareiss, E.H.</strong> (1968). &quot;Sylvester&#39;s identity and multistep integer-preserving Gaussian elimination.&quot; <em>Mathematics of Computation</em> 22(103): 565-578.</p></li><li><p><strong>Cardano, G.</strong> (1545). <em>Ars Magna</em> (The Great Art). Closed-form solution for cubic equations.</p></li><li><p><strong>Ferrari, L.</strong> (1545). Solution of quartic equations (published in Cardano&#39;s Ars Magna).</p></li><li><p><strong>Davis, P.J.</strong> (1979). <em>Circulant Matrices</em>. Wiley-Interscience. Theory of circulant eigenvalues.</p></li><li><p><strong>Trench, W.F.</strong> (1999). &quot;Numerical solution of the eigenvalue problem for Hermitian Toeplitz matrices.&quot; <em>SIAM Journal on Matrix Analysis and Applications</em> 10(2): 135-146.</p></li></ol><h3 id="Mathematical-Background"><a class="docs-heading-anchor" href="#Mathematical-Background">Mathematical Background</a><a id="Mathematical-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Background" title="Permalink"></a></h3><ol><li><p><strong>Abel, N.H.</strong> (1826). &quot;Beweis der Unmöglichkeit, algebraische Gleichungen von höheren Graden als dem vierten allgemein aufzulösen.&quot; Proof that degree ≥5 has no general formula.</p></li><li><p><strong>Galois, É.</strong> (1832). &quot;Mémoire sur les conditions de résolubilité des équations par radicaux.&quot; Galois theory foundation.</p></li><li><p><strong>Horn, R.A. &amp; Johnson, C.R.</strong> (2013). <em>Matrix Analysis</em> (2nd ed.). Cambridge University Press. Comprehensive matrix theory reference.</p></li></ol><h3 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h3><ol><li><p><strong>Symbolics.jl Documentation</strong>. https://symbolics.juliasymbolics.org/</p></li><li><p><strong>SymbolicUtils.jl</strong>. https://symbolicutils.juliasymbolics.org/</p></li></ol><hr/><h2 id="Appendix:-File-Organization"><a class="docs-heading-anchor" href="#Appendix:-File-Organization">Appendix: File Organization</a><a id="Appendix:-File-Organization-1"></a><a class="docs-heading-anchor-permalink" href="#Appendix:-File-Organization" title="Permalink"></a></h2><pre><code class="nohighlight hljs">src/
├── SymbolicDiagonalization.jl  # Module definition and exports
├── charpoly.jl                 # Characteristic polynomial (Bareiss)
├── roots.jl                    # Root solvers (degrees 1-4)
├── rref.jl                     # RREF and nullspace computation
└── diagonalize.jl              # Main API and pattern detection
    ├── Public API (eigen, eigvals, symbolic_*)
    ├── Structure Detection (_is_*, _detect_*)
    ├── Special Pattern Solvers (_*_eigenvalues)
    ├── Eigenvector Computation (_adjugate, _nullspace)
    └── Utility Functions</code></pre><p><strong>Lines of code</strong>:</p><ul><li><code>charpoly.jl</code>: ~60 lines</li><li><code>roots.jl</code>: ~390 lines</li><li><code>rref.jl</code>: ~75 lines</li><li><code>diagonalize.jl</code>: ~1495 lines</li><li><strong>Total</strong>: ~2020 lines of implementation code</li></ul><hr/><p><em>This implementation documentation was last updated: December 11, 2025</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pattern_library/">« Pattern Library</a><a class="docs-footer-nextpage" href="../mathematical_background/">Mathematical Background »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 11 December 2025 18:26">Thursday 11 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

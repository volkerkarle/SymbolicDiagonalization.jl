var documenterSearchIndex = {"docs":
[{"location":"api_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"Complete API documentation for SymbolicDiagonalization.jl.","category":"section"},{"location":"api_reference/#Table-of-Contents","page":"API Reference","title":"Table of Contents","text":"User-Facing API\nLinearAlgebra Interface\nDirect Eigenvalue API\nCharacteristic Polynomial\nRoot Solvers\nKeyword Arguments\nException Types\nInternal API\n\n","category":"section"},{"location":"api_reference/#User-Facing-API","page":"API Reference","title":"User-Facing API","text":"","category":"section"},{"location":"api_reference/#LinearAlgebra-Interface","page":"API Reference","title":"LinearAlgebra Interface","text":"The recommended interface for most users. Extends LinearAlgebra.jl with symbolic matrix support.","category":"section"},{"location":"api_reference/#LinearAlgebra.eigen","page":"API Reference","title":"LinearAlgebra.eigen","text":"eigen(A; kwargs...) → Eigen\n\nComputes eigenvalues and eigenvectors of symbolic matrix A.\n\nArguments:\n\nA::Matrix{Union{Num, Complex{Num}}} - Symbolic matrix to diagonalize\n\nKeyword Arguments: See Keyword Arguments section\n\nReturns: Eigen object with fields:\n\n.values - Vector of eigenvalues\n.vectors - Matrix of eigenvectors (as columns)\n\nExample:\n\nusing Symbolics, SymbolicDiagonalization, LinearAlgebra\n\n@variables a b c\nmat = [a 1 0; 0 b 1; 0 0 c]\n\nE = eigen(mat)\nE.values   # [a, b, c]\nE.vectors  # 3×3 eigenvector matrix\n\nNotes:\n\nUse eigvals() instead if you only need eigenvalues (faster)\nThrows error if matrix is not diagonalizable\nEigenvectors are columns of the returned matrix\n\n","category":"section"},{"location":"api_reference/#LinearAlgebra.eigvals","page":"API Reference","title":"LinearAlgebra.eigvals","text":"eigvals(A; kwargs...) → Vector\n\nComputes eigenvalues of symbolic matrix A (faster than eigen since it skips eigenvectors).\n\nArguments:\n\nA::Matrix{Union{Num, Complex{Num}}} - Symbolic matrix\n\nKeyword Arguments: See Keyword Arguments section\n\nReturns: Vector of eigenvalue expressions\n\nExample:\n\n@variables a b\nmat = [a b; b a]\n\nλ = eigvals(mat)  # [a + b, a - b]\n\nNotes:\n\nRecommended when eigenvectors not needed\nMuch faster than eigen() for large matrices\nSame structure detection and special pattern solvers\n\n","category":"section"},{"location":"api_reference/#Direct-Eigenvalue-API","page":"API Reference","title":"Direct Eigenvalue API","text":"Lower-level API for advanced users who need more control.","category":"section"},{"location":"api_reference/#symbolic_eigenvalues","page":"API Reference","title":"symbolic_eigenvalues","text":"symbolic_eigenvalues(A; kwargs...) → (values, poly, λ)\n\nComputes eigenvalues along with characteristic polynomial.\n\nArguments:\n\nA::Matrix - Symbolic matrix\n\nKeyword Arguments: See Keyword Arguments section\n\nReturns: Tuple of:\n\nvalues - Vector of eigenvalue expressions\npoly - Characteristic polynomial det(λI - A)\nλ - Symbolic variable used in polynomial\n\nExample:\n\n@variables a b\nmat = [a b; b a]\n\nvals, poly, λ = symbolic_eigenvalues(mat)\n# vals: [a+b, a-b]\n# poly: (λ - a)² - b²\n# λ: symbolic variable\n\nUse cases:\n\nNeed both eigenvalues and characteristic polynomial\nWant to manipulate polynomial directly\nNeed the eigenvalue variable for further computation\n\n","category":"section"},{"location":"api_reference/#symbolic_eigenpairs","page":"API Reference","title":"symbolic_eigenpairs","text":"symbolic_eigenpairs(A; kwargs...) → Vector{Tuple{Num, Vector{Vector{Num}}}}\n\nComputes eigenvalue-eigenvector pairs with multiplicity handling.\n\nArguments:\n\nA::Matrix - Symbolic matrix\n\nKeyword Arguments: \n\ncompute_vectors::Bool = true - Whether to compute eigenvectors\nPlus all standard kwargs\n\nReturns: Vector of tuples (eigenvalue, eigenvectors):\n\nEach eigenvalue may have multiple eigenvectors (geometric multiplicity)\nEigenvectors are vectors, not matrix columns\n\nExample:\n\n@variables a b\nmat = [a b; b a]\n\npairs = symbolic_eigenpairs(mat)\n# [(a+b, [v₁]), (a-b, [v₂])]\n\n# Access first eigenvalue and its eigenvectors\nλ₁, vecs₁ = pairs[1]\n\nUse cases:\n\nNeed explicit multiplicity information\nWant eigenvalues grouped with their eigenvectors\nNeed to handle degenerate cases\n\n","category":"section"},{"location":"api_reference/#symbolic_diagonalize","page":"API Reference","title":"symbolic_diagonalize","text":"symbolic_diagonalize(A; kwargs...) → (P, D, pairs)\n\nComputes full diagonalization A = P D P⁻¹.\n\nArguments:\n\nA::Matrix - Symbolic matrix\n\nKeyword Arguments: See Keyword Arguments section\n\nReturns: Tuple of:\n\nP - Matrix of eigenvectors (columns)\nD - Diagonal matrix of eigenvalues\npairs - Same as symbolic_eigenpairs() output\n\nExample:\n\n@variables a b\nmat = [a b; b a]\n\nP, D, pairs = symbolic_diagonalize(mat)\n# Verify: mat ≈ P * D * inv(P)\n\nThrows:\n\nArgumentError if matrix is not diagonalizable\nArgumentError if insufficient eigenvectors found\n\nUse cases:\n\nNeed explicit matrix factorization\nWant to verify diagonalizability\nNeed P and D matrices for further computation\n\n","category":"section"},{"location":"api_reference/#Characteristic-Polynomial","page":"API Reference","title":"Characteristic Polynomial","text":"","category":"section"},{"location":"api_reference/#characteristic_polynomial","page":"API Reference","title":"characteristic_polynomial","text":"characteristic_polynomial(A; var=nothing) → (poly, coeffs, λ)\n\nComputes characteristic polynomial det(λI - A) using Bareiss algorithm.\n\nArguments:\n\nA::Matrix - Symbolic matrix\nvar - Optional symbolic variable to use (auto-generated if not provided)\n\nReturns: Tuple of:\n\npoly - Polynomial expression det(λI - A)\ncoeffs - Vector of polynomial coefficients [c₀, c₁, ..., cₙ]\nλ - Symbolic variable\n\nExample:\n\n@variables a b\nmat = [a b; b a]\n\npoly, coeffs, λ = characteristic_polynomial(mat)\n# poly: λ² - 2a·λ + (a² - b²)\n# coeffs: [a² - b², -2a, 1]\n\nImplementation details:\n\nUses Bareiss fraction-free determinant for efficiency\nAvoids expression explosion from cofactor expansion\nCoefficients extracted by differentiation at λ = 0\n\nUse cases:\n\nNeed characteristic polynomial for analysis\nWant polynomial coefficients explicitly\nImplementing custom root-finding methods\n\n","category":"section"},{"location":"api_reference/#Root-Solvers","page":"API Reference","title":"Root Solvers","text":"","category":"section"},{"location":"api_reference/#symbolic_roots","page":"API Reference","title":"symbolic_roots","text":"symbolic_roots(poly, λ; expand=true, max_terms=10000) → Vector\n\nFinds symbolic roots of polynomial using closed-form formulas (degrees 1-4).\n\nArguments:\n\npoly - Polynomial expression in variable λ\nλ - Symbolic variable\nexpand::Bool = true - Whether to expand expressions\nmax_terms::Int = 10000 - Maximum expression complexity\n\nReturns: Vector of symbolic root expressions\n\nExample:\n\n@variables λ a b\npoly = λ^2 - 2a*λ + (a^2 - b^2)\n\nroots = symbolic_roots(poly, λ)\n# [a + b, a - b]\n\nSupported degrees:\n\nDegree 1: Linear formula\nDegree 2: Quadratic formula\nDegree 3: Cardano's cubic formula\nDegree 4: Ferrari's quartic formula\nDegree ≥ 5: Throws error (Abel-Ruffini theorem)\n\nThrows:\n\nArgumentError if degree ≥ 5 and no structure detected\nExpressionComplexityError if expression exceeds max_terms\n\nNotes:\n\nQuartic formula produces very large expressions\nConsider structure detection for degree ≥ 4\nFor degree 4, expressions can be ~13.5 MB each\n\n","category":"section"},{"location":"api_reference/#Keyword-Arguments","page":"API Reference","title":"Keyword Arguments","text":"All main functions (eigen, eigvals, symbolic_eigenvalues, etc.) accept these keyword arguments:","category":"section"},{"location":"api_reference/#var::Union{Nothing,-Num}","page":"API Reference","title":"var::Union{Nothing, Num}","text":"Default: nothing (auto-generate)\n\nSymbolic variable to use for eigenvalue. If nothing, a fresh variable is created.\n\nExample:\n\n@variables λ\nvals = eigvals(mat, var=λ)\n\nUse cases: \n\nNeed specific variable name\nIntegrating with existing symbolic expressions\nWant to control variable scope\n\n","category":"section"},{"location":"api_reference/#structure::Symbol","page":"API Reference","title":"structure::Symbol","text":"Default: :auto\n\nHint about matrix structure for optimization.\n\nOptions:\n\n:auto - Automatic structure detection (default)\n:hermitian - Hermitian matrix (A† = A)\n:symmetric - Real symmetric (Aᵀ = A)\n:unitary - Unitary matrix (A† = A⁻¹)\n:general - No structure assumptions\n\nExample:\n\n# Tell solver that matrix is Hermitian\nvals = eigvals(hermitian_mat, structure=:hermitian)\n\nNotes:\n\nProviding correct hint can speed up computation\nIncorrect hint may give wrong results\n:auto is safe but may be slower\n\n","category":"section"},{"location":"api_reference/#expand::Bool","page":"API Reference","title":"expand::Bool","text":"Default: true\n\nWhether to expand polynomial expressions.\n\nOptions:\n\ntrue - Expand products and powers\nfalse - Keep factored form when possible\n\nExample:\n\n# Factored form (if available)\nvals = eigvals(mat, expand=false)\n\nUse cases:\n\nFactored form may be simpler\nExpanded form needed for numerical evaluation\nDebugging expression structure\n\n","category":"section"},{"location":"api_reference/#complexity_threshold::Int","page":"API Reference","title":"complexity_threshold::Int","text":"Default: 5\n\nWarn if matrix contains more than this many symbolic variables.\n\nExample:\n\n# Suppress warning for 10-variable matrix\nvals = eigvals(large_mat, complexity_threshold=10)\n\nPurpose: Prevent accidentally running huge symbolic computations that may timeout or produce enormous expressions.\n\nRecommendation: \n\nKeep ≤ 5 for general matrices\nCan increase for structured matrices\nSet to Inf to disable warnings\n\n","category":"section"},{"location":"api_reference/#timeout::Int","page":"API Reference","title":"timeout::Int","text":"Default: 300 (5 minutes)\n\nMaximum computation time in seconds.\n\nExample:\n\n# Allow only 60 seconds\nvals = eigvals(mat, timeout=60)\n\nThrows: ComputationTimeoutError if exceeded\n\nUse cases:\n\nPrevent runaway computations\nTesting with time limits\nInteractive use with quick feedback\n\n","category":"section"},{"location":"api_reference/#max_terms::Int","page":"API Reference","title":"max_terms::Int","text":"Default: 10000\n\nMaximum number of terms allowed in symbolic expressions.\n\nExample:\n\n# Allow more complex expressions\nvals = eigvals(mat, max_terms=50000)\n\nThrows: ExpressionComplexityError if exceeded\n\nPurpose: Prevent expression explosion (especially in quartic formula)\n\nRecommendation:\n\nKeep default for most cases\nIncrease for structured matrices\nWatch memory usage if increasing\n\n","category":"section"},{"location":"api_reference/#Exception-Types","page":"API Reference","title":"Exception Types","text":"","category":"section"},{"location":"api_reference/#ExpressionComplexityError","page":"API Reference","title":"ExpressionComplexityError","text":"Thrown when symbolic expression exceeds complexity limit.\n\nFields:\n\nmsg::String - Error message\nterms::Int - Number of terms encountered\nlimit::Int - Configured limit\n\nExample:\n\ntry\n    vals = eigvals(huge_mat, max_terms=1000)\ncatch e\n    if e isa ExpressionComplexityError\n        println(\"Expression too complex: $(e.terms) terms (limit: $(e.limit))\")\n    end\nend\n\nCommon causes:\n\nFully symbolic 4×4 matrices (quartic formula)\nLack of detected structure\nNested radical expressions\n\nSolutions:\n\nAdd structure to matrix\nUse partial numeric substitution\nIncrease max_terms (watch memory!)\nUse numerical methods instead\n\n","category":"section"},{"location":"api_reference/#ComputationTimeoutError","page":"API Reference","title":"ComputationTimeoutError","text":"Thrown when computation exceeds time limit.\n\nFields:\n\nmsg::String - Error message\ntimeout::Int - Configured timeout in seconds\n\nExample:\n\ntry\n    vals = eigvals(mat, timeout=30)\ncatch e\n    if e isa ComputationTimeoutError\n        println(\"Timed out after $(e.timeout) seconds\")\n    end\nend\n\nCommon causes:\n\nVery large symbolic matrices\nComplex expression simplification\nExpensive structure detection\n\nSolutions:\n\nIncrease timeout\nSimplify matrix structure\nUse numerical methods\nPre-substitute some variables\n\n","category":"section"},{"location":"api_reference/#Internal-API","page":"API Reference","title":"Internal API","text":"These functions are not exported but may be useful for advanced users or contributors.","category":"section"},{"location":"api_reference/#Structure-Detection","page":"API Reference","title":"Structure Detection","text":"","category":"section"},{"location":"api_reference/#_detect_structure(mat)","page":"API Reference","title":"_detect_structure(mat)","text":"Automatically detects matrix structure (diagonal, triangular, block-diagonal, etc.)","category":"section"},{"location":"api_reference/#_is_diagonal(mat)","page":"API Reference","title":"_is_diagonal(mat)","text":"Tests if matrix is diagonal","category":"section"},{"location":"api_reference/#_is_triangular(mat)","page":"API Reference","title":"_is_triangular(mat)","text":"Tests if matrix is upper or lower triangular","category":"section"},{"location":"api_reference/#_is_hermitian(mat)","page":"API Reference","title":"_is_hermitian(mat)","text":"Tests if matrix is Hermitian (A† = A)","category":"section"},{"location":"api_reference/#_is_symmetric(mat)","page":"API Reference","title":"_is_symmetric(mat)","text":"Tests if matrix is real symmetric","category":"section"},{"location":"api_reference/#_is_persymmetric(mat)","page":"API Reference","title":"_is_persymmetric(mat)","text":"Tests if matrix has persymmetric structure Q[i,j] = Q[n+1-j,n+1-i]\n\n","category":"section"},{"location":"api_reference/#Special-Pattern-Detectors","page":"API Reference","title":"Special Pattern Detectors","text":"","category":"section"},{"location":"api_reference/#_is_circulant(mat)","page":"API Reference","title":"_is_circulant(mat)","text":"Tests if matrix is circulant (each row cyclic shift of previous)","category":"section"},{"location":"api_reference/#_is_block_circulant(mat)","page":"API Reference","title":"_is_block_circulant(mat)","text":"Tests if matrix is block circulant, returns (true, n_blocks, block_size, blocks) or (false, ...)","category":"section"},{"location":"api_reference/#_is_kronecker_product(mat)","page":"API Reference","title":"_is_kronecker_product(mat)","text":"Tests if matrix is Kronecker product, returns (true, A, B, m, n) or (false, ...)","category":"section"},{"location":"api_reference/#_is_toeplitz_tridiagonal(mat)","page":"API Reference","title":"_is_toeplitz_tridiagonal(mat)","text":"Tests if matrix is symmetric Toeplitz tridiagonal","category":"section"},{"location":"api_reference/#_is_antidiagonal(mat)","page":"API Reference","title":"_is_antidiagonal(mat)","text":"Tests if matrix is symmetric anti-diagonal","category":"section"},{"location":"api_reference/#_is_permutation_matrix(mat)","page":"API Reference","title":"_is_permutation_matrix(mat)","text":"Tests if matrix is a permutation matrix","category":"section"},{"location":"api_reference/#_detect_special_5x5_tridiagonal(mat)","page":"API Reference","title":"_detect_special_5x5_tridiagonal(mat)","text":"Tests for special 5×5 patterns with known eigenvalues\n\n","category":"section"},{"location":"api_reference/#Special-Pattern-Solvers","page":"API Reference","title":"Special Pattern Solvers","text":"","category":"section"},{"location":"api_reference/#_circulant_eigenvalues(mat)","page":"API Reference","title":"_circulant_eigenvalues(mat)","text":"Computes eigenvalues of circulant matrix using DFT","category":"section"},{"location":"api_reference/#_block_circulant_eigenvalues(mat,-n_blocks,-block_size,-blocks;-...)","page":"API Reference","title":"_block_circulant_eigenvalues(mat, n_blocks, block_size, blocks; ...)","text":"Computes eigenvalues of block circulant matrix","category":"section"},{"location":"api_reference/#_kronecker_eigenvalues(A,-B,-m,-n;-...)","page":"API Reference","title":"_kronecker_eigenvalues(A, B, m, n; ...)","text":"Computes eigenvalues of Kronecker product A ⊗ B","category":"section"},{"location":"api_reference/#_toeplitz_tridiagonal_eigenvalues(n,-a,-b,-c)","page":"API Reference","title":"_toeplitz_tridiagonal_eigenvalues(n, a, b, c)","text":"Computes eigenvalues of symmetric Toeplitz tridiagonal","category":"section"},{"location":"api_reference/#_antidiagonal_eigenvalues(mat)","page":"API Reference","title":"_antidiagonal_eigenvalues(mat)","text":"Computes eigenvalues of symmetric anti-diagonal matrix","category":"section"},{"location":"api_reference/#_compute_permutation_eigenvalues(A)","page":"API Reference","title":"_compute_permutation_eigenvalues(A)","text":"Computes eigenvalues of permutation matrix via cycle decomposition\n\n","category":"section"},{"location":"api_reference/#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"","category":"section"},{"location":"api_reference/#_block_split(mat)","page":"API Reference","title":"_block_split(mat)","text":"Detects and splits block-diagonal structure","category":"section"},{"location":"api_reference/#_persymmetric_split(mat)","page":"API Reference","title":"_persymmetric_split(mat)","text":"Splits persymmetric matrix into half-sized problems","category":"section"},{"location":"api_reference/#_count_symbolic_vars(A)","page":"API Reference","title":"_count_symbolic_vars(A)","text":"Counts number of unique symbolic variables in matrix","category":"section"},{"location":"api_reference/#_check_complexity(A;-threshold,-quiet)","page":"API Reference","title":"_check_complexity(A; threshold, quiet)","text":"Checks if matrix exceeds complexity threshold, optionally warns\n\n","category":"section"},{"location":"api_reference/#Usage-Examples","page":"API Reference","title":"Usage Examples","text":"","category":"section"},{"location":"api_reference/#Example-1:-Basic-Eigenvalues","page":"API Reference","title":"Example 1: Basic Eigenvalues","text":"using Symbolics, SymbolicDiagonalization, LinearAlgebra\n\n@variables a b c\nmat = [a 0 0; 0 b 0; 0 0 c]\n\nλ = eigvals(mat)  # [a, b, c]","category":"section"},{"location":"api_reference/#Example-2:-With-Structure-Hint","page":"API Reference","title":"Example 2: With Structure Hint","text":"@variables a b\nH = [a b; conj(b) a]  # Hermitian\n\nE = eigen(H, structure=:hermitian)","category":"section"},{"location":"api_reference/#Example-3:-Error-Handling","page":"API Reference","title":"Example 3: Error Handling","text":"@variables a b c d e\nmat = [a b c d e;\n       b a c d e;\n       c c a d e;\n       d d d a e;\n       e e e e a]\n\ntry\n    λ = eigvals(mat, timeout=60, max_terms=5000)\ncatch e\n    if e isa ComputationTimeoutError\n        println(\"Computation timed out\")\n    elseif e isa ExpressionComplexityError\n        println(\"Expression too complex\")\n    else\n        rethrow(e)\n    end\nend","category":"section"},{"location":"api_reference/#Example-4:-Characteristic-Polynomial","page":"API Reference","title":"Example 4: Characteristic Polynomial","text":"@variables a b\nmat = [a b; b a]\n\npoly, coeffs, λ = characteristic_polynomial(mat)\n# poly = λ² - 2a·λ + (a² - b²)\n\n# Now solve manually if desired\nroots = symbolic_roots(poly, λ)","category":"section"},{"location":"api_reference/#Example-5:-Full-Diagonalization","page":"API Reference","title":"Example 5: Full Diagonalization","text":"@variables a b\nmat = [a b; b a]\n\nP, D, pairs = symbolic_diagonalize(mat)\n\n# Verify: mat ≈ P * D * inv(P)\n# P contains eigenvectors as columns\n# D is diagonal with eigenvalues\n\n","category":"section"},{"location":"api_reference/#See-Also","page":"API Reference","title":"See Also","text":"User Guide - Practical examples and workflows\nPattern Library - Special patterns and their eigenvalues\nImplementation - Algorithm details\nMathematical Background - Theory and proofs","category":"section"},{"location":"mathematical_background/#Mathematical-Background","page":"Mathematical Background","title":"Mathematical Background","text":"This document explains the mathematical foundations underlying SymbolicDiagonalization.jl.","category":"section"},{"location":"mathematical_background/#Table-of-Contents","page":"Mathematical Background","title":"Table of Contents","text":"The Eigenvalue Problem\nThe Abel-Ruffini Theorem\nWhy Structure Matters\nClosed-Form Root Formulas\nSpecial Pattern Theory","category":"section"},{"location":"mathematical_background/#The-Eigenvalue-Problem","page":"Mathematical Background","title":"The Eigenvalue Problem","text":"","category":"section"},{"location":"mathematical_background/#Definition","page":"Mathematical Background","title":"Definition","text":"Given an n times n matrix mathbfA, we seek scalars lambda (eigenvalues) and non-zero vectors mathbfv (eigenvectors) satisfying:\n\nmathbfA mathbfv = lambda mathbfv\n\nEquivalently, we need:\n\n(mathbfA - lambda mathbfI) mathbfv = mathbf0\n\nFor non-trivial solutions, the matrix (mathbfA - lambda mathbfI) must be singular:\n\ndet(mathbfA - lambda mathbfI) = 0\n\nThis determinant is a polynomial in lambda called the characteristic polynomial:\n\np(lambda) = det(lambda mathbfI - mathbfA) = lambda^n + c_n-1lambda^n-1 + cdots + c_1lambda + c_0\n\nThe eigenvalue problem reduces to finding roots of a polynomial.","category":"section"},{"location":"mathematical_background/#Why-Eigenvalues-Matter","page":"Mathematical Background","title":"Why Eigenvalues Matter","text":"Eigenvalues reveal fundamental properties of linear transformations:\n\nDynamics: Matrix powers mathbfA^n grow/decay based on eigenvalue magnitudes\nStability: System stability determined by eigenvalue real parts\nGeometry: Eigenvalues measure stretching/compression along eigenvector directions\nSpectral decomposition: mathbfA = mathbfPmathbfDmathbfP^-1 where mathbfD is diagonal (if mathbfA is diagonalizable)","category":"section"},{"location":"mathematical_background/#The-Fundamental-Challenge","page":"Mathematical Background","title":"The Fundamental Challenge","text":"For general matrices:\n\n2 times 2\n→ degree-2 polynomial (quadratic formula)\n3 times 3\n→ degree-3 polynomial (cubic formula)\n4 times 4\n→ degree-4 polynomial (quartic formula)\n5 times 5\n→ degree-5 polynomial (no general formula!)\nn times n\n→ degree-n polynomial (no general formula for n geq 5)\n\nThis limitation is not computational—it's a fundamental impossibility proven by the Abel-Ruffini theorem.","category":"section"},{"location":"mathematical_background/#The-Abel-Ruffini-Theorem","page":"Mathematical Background","title":"The Abel-Ruffini Theorem","text":"","category":"section"},{"location":"mathematical_background/#Statement","page":"Mathematical Background","title":"Statement","text":"Theorem (Abel-Ruffini, 1824): There is no general algebraic solution (using radicals) for polynomial equations of degree 5 or higher.","category":"section"},{"location":"mathematical_background/#What-This-Means","page":"Mathematical Background","title":"What This Means","text":"Degree leq 4: Closed-form formulas exist using +, -, times, div, and nth roots\nDegree geq 5: No general formula exists using these operations\nSpecific polynomials: May still have closed-form solutions (e.g., lambda^5 - 1 = 0)","category":"section"},{"location":"mathematical_background/#Implications-for-Symbolic-Eigenvalues","page":"Mathematical Background","title":"Implications for Symbolic Eigenvalues","text":"✅ Can solve symbolically:\n\nAll 1 times 1, 2 times 2, 3 times 3, 4 times 4 general matrices\nLarger matrices with exploitable structure\n\n❌ Cannot solve symbolically (in general):\n\nGeneric 5 times 5, 6 times 6, ..., n times n matrices\nMatrices whose structure doesn't reduce to degree leq 4","category":"section"},{"location":"mathematical_background/#Galois-Theory-Background","page":"Mathematical Background","title":"Galois Theory Background","text":"The Abel-Ruffini theorem is a consequence of Galois theory:\n\nSolvable groups: Polynomial roots can be expressed in radicals iff its Galois group is solvable\nSymmetric groups: The generic degree-n polynomial has Galois group S_n (symmetric group)\nNon-solvability: S_n is not solvable for n geq 5\nConclusion: No general radical formula for degree geq 5\n\nKey insight: Specific polynomials may have special Galois groups that ARE solvable, even for degree geq 5. This is why structure detection is crucial.","category":"section"},{"location":"mathematical_background/#Why-Structure-Matters","page":"Mathematical Background","title":"Why Structure Matters","text":"","category":"section"},{"location":"mathematical_background/#The-Structure-Exploitation-Strategy","page":"Mathematical Background","title":"The Structure-Exploitation Strategy","text":"Since we can't solve general n times n matrices for n geq 5, we must:\n\nDetect structure in the matrix\nExploit structure to reduce problem complexity\nSolve using available methods","category":"section"},{"location":"mathematical_background/#Types-of-Exploitable-Structure","page":"Mathematical Background","title":"Types of Exploitable Structure","text":"","category":"section"},{"location":"mathematical_background/#1.-Reducible-Structure","page":"Mathematical Background","title":"1. Reducible Structure","text":"Block-diagonal matrices:\n\nmathbfA = beginbmatrix\nmathbfA_1  mathbf0  mathbf0 \nmathbf0  mathbfA_2  mathbf0 \nmathbf0  mathbf0  mathbfA_3\nendbmatrix\n\nEigenvalues: lambda(mathbfA) = lambda(mathbfA_1) cup lambda(mathbfA_2) cup lambda(mathbfA_3)\n\nWhy this helps: An 8 times 8 block diagonal with 2 times 2 blocks requires solving 4 quadratic equations, not one degree-8 equation.","category":"section"},{"location":"mathematical_background/#2.-Symmetry-Structure","page":"Mathematical Background","title":"2. Symmetry Structure","text":"Circulant matrices: Each row is cyclic shift of previous\n\nmathbfC = beginbmatrix\nc_0  c_1  c_2  cdots  c_n-1 \nc_n-1  c_0  c_1  cdots  c_n-2 \nc_n-2  c_n-1  c_0  cdots  c_n-3 \nvdots  vdots  vdots  ddots  vdots\nendbmatrix\n\nEigenvalues: lambda_k = sum_j=0^n-1 c_j cdot omega^kj where omega = exp(2pi in)\n\nWhy this helps: The DFT matrix diagonalizes ALL circulant matrices, giving closed form for any n.","category":"section"},{"location":"mathematical_background/#3.-Tensor-Product-Structure","page":"Mathematical Background","title":"3. Tensor Product Structure","text":"Kronecker products: mathbfA otimes mathbfB\n\nmathbfA otimes mathbfB = beginbmatrix\na_11mathbfB  a_12mathbfB  cdots \na_21mathbfB  a_22mathbfB  cdots \nvdots  vdots  ddots\nendbmatrix\n\nEigenvalues: lambda(mathbfA otimes mathbfB) = lambda_i(mathbfA) cdot lambda_j(mathbfB)  textall  ij\n\nWhy this helps: A 6 times 6 = (2 times 2) otimes (3 times 3) reduces to quadratic + cubic, not degree-6.","category":"section"},{"location":"mathematical_background/#4.-Special-Pattern-Structure","page":"Mathematical Background","title":"4. Special Pattern Structure","text":"Symmetric Toeplitz tridiagonal: Constant diagonals\n\nmathbfT = beginbmatrix\na  b  0  0  cdots  0 \nb  a  b  0  cdots  0 \n0  b  a  b  cdots  0 \nvdots  vdots  vdots  vdots  ddots  vdots\nendbmatrix\n\nEigenvalues: lambda_k = a + 2b cosleft(frackpin+1right) for k = 1 2 ldots n\n\nWhy this helps: Known eigenvector basis (discrete sine transform) gives closed-form eigenvalues.","category":"section"},{"location":"mathematical_background/#The-Key-Principle","page":"Mathematical Background","title":"The Key Principle","text":"Matrices with structure have special Galois groups.\n\nThe characteristic polynomial of a structured matrix isn't generic—it has symmetries that make its Galois group smaller or more solvable, even for degree geq 5.\n\nExamples:\n\nCirculant n times n: Galois group is cyclic mathbbZ_n (always solvable)\nGeneric n times n: Galois group is symmetric S_n (not solvable for n geq 5)","category":"section"},{"location":"mathematical_background/#Closed-Form-Root-Formulas","page":"Mathematical Background","title":"Closed-Form Root Formulas","text":"","category":"section"},{"location":"mathematical_background/#Degree-1:-Linear","page":"Mathematical Background","title":"Degree 1: Linear","text":"Equation: lambda + c_0 = 0\n\nSolution: lambda = -c_0","category":"section"},{"location":"mathematical_background/#Degree-2:-Quadratic","page":"Mathematical Background","title":"Degree 2: Quadratic","text":"Equation: lambda^2 + c_1lambda + c_0 = 0\n\nSolution (Quadratic formula):\n\nlambda = frac-c_1 pm sqrtc_1^2 - 4c_02\n\nDiscriminant: Delta = c_1^2 - 4c_0\n\nDelta  0\n: Two real roots\nDelta = 0\n: One repeated root\nDelta  0\n: Two complex conjugate roots","category":"section"},{"location":"mathematical_background/#Degree-3:-Cubic-(Cardano's-Formula)","page":"Mathematical Background","title":"Degree 3: Cubic (Cardano's Formula)","text":"Equation: lambda^3 + c_2lambda^2 + c_1lambda + c_0 = 0\n\nStrategy: Eliminate quadratic term via substitution lambda = t - c_23\n\nReduced form: t^3 + pt + q = 0\n\nSolution:\n\nt = sqrt3-fracq2 + sqrtfracq^24 + fracp^327 + sqrt3-fracq2 - sqrtfracq^24 + fracp^327\n\nDiscriminant: Delta = -4p^3 - 27q^2\n\nDelta  0\n: Three distinct real roots\nDelta = 0\n: Repeated root\nDelta  0\n: One real root, two complex conjugates\n\nHistorical note: Cardano published this in 1545, but Tartaglia discovered it earlier.","category":"section"},{"location":"mathematical_background/#Degree-4:-Quartic-(Ferrari's-Method)","page":"Mathematical Background","title":"Degree 4: Quartic (Ferrari's Method)","text":"Equation: lambda^4 + c_3lambda^3 + c_2lambda^2 + c_1lambda + c_0 = 0\n\nStrategy: \n\nEliminate cubic term: lambda = t - c_34\nAdd and subtract clever term to create perfect squares\nReduce to solving a cubic (Cardano) plus quadratics\n\nSolution (simplified outline):\n\nSolve cubic resolvent: y^3 + p_2y^2 + p_1y + p_0 = 0 (use Cardano)\nUse root y to decompose into two quadratics\nSolve quadratics for final four roots\n\nComplexity: Formula involves nested cube roots and square roots, producing extremely large expressions.\n\nExpression size: For fully symbolic 4 times 4 matrix, each eigenvalue is ~13.5 MB of symbolic expressions!","category":"section"},{"location":"mathematical_background/#Degree-5:-No-General-Formula","page":"Mathematical Background","title":"Degree ≥ 5: No General Formula","text":"Abel-Ruffini Theorem: No algebraic solution using radicals.\n\nOur approach: Detect structure and apply specialized methods.","category":"section"},{"location":"mathematical_background/#Special-Pattern-Theory","page":"Mathematical Background","title":"Special Pattern Theory","text":"","category":"section"},{"location":"mathematical_background/#Why-Certain-Patterns-Have-Closed-Forms","page":"Mathematical Background","title":"Why Certain Patterns Have Closed Forms","text":"A matrix pattern has closed-form eigenvalues if one of these conditions holds:","category":"section"},{"location":"mathematical_background/#1.-Commutes-with-Known-Transformation","page":"Mathematical Background","title":"1. Commutes with Known Transformation","text":"If mathbfAmathbfU = mathbfUmathbfLambda where:\n\nmathbfU\nis a known unitary matrix (independent of matrix entries)\nmathbfLambda\nis diagonal\n\nThen mathbfU diagonalizes mathbfA, and eigenvalues are diagonal entries of mathbfLambda = mathbfU^daggermathbfAmathbfU.\n\nExamples:\n\nCirculant: mathbfU = DFT matrix\nSymmetric Toeplitz tridiagonal: mathbfU = discrete sine transform","category":"section"},{"location":"mathematical_background/#2.-Reducible-via-Transformation","page":"Mathematical Background","title":"2. Reducible via Transformation","text":"If a known transformation splits mathbfA into independent subproblems of degree leq 4.\n\nExamples:\n\nBlock-diagonal: Already split\nPersymmetric: Symmetry transformation splits into half-sized problems\nBlock circulant: Block DFT reduces to smaller problems","category":"section"},{"location":"mathematical_background/#3.-Tensor-Product-Structure-2","page":"Mathematical Background","title":"3. Tensor Product Structure","text":"If mathbfA = mathbfB otimes mathbfC, then lambda(mathbfA) = lambda_i(mathbfB) cdot lambda_j(mathbfC).\n\nWorks when: Can detect Kronecker product structure.","category":"section"},{"location":"mathematical_background/#4.-Polynomial-in-Simple-Matrix","page":"Mathematical Background","title":"4. Polynomial in Simple Matrix","text":"If mathbfA = f(mathbfJ) where mathbfJ is a simple matrix (e.g., shift operator, permutation).\n\nExamples:\n\nCirculant: Polynomial in cyclic shift matrix\nSymmetric Toeplitz tridiagonal: Related to Chebyshev polynomials","category":"section"},{"location":"mathematical_background/#5.-Special-Symmetry-Group","page":"Mathematical Background","title":"5. Special Symmetry Group","text":"If the matrix has a symmetry group that:\n\nConstrains eigenvalue structure\nReduces to solvable subproblems\n\nExamples:\n\nAnti-diagonal: Persymmetric symmetry forces pm pairs\nPermutation: Cycle structure gives roots of unity","category":"section"},{"location":"mathematical_background/#The-Discovery-Process","page":"Mathematical Background","title":"The Discovery Process","text":"Finding new patterns requires:\n\nPattern hypothesis: Guess a family of matrices\nNumerical testing: Check if eigenvalues have simple form\nSymbolic verification: Verify closed form holds symbolically\nMathematical justification: Explain WHY it works (find the structure)\nGeneralization: Identify what structural property makes it work\n\nSee notes/DISCOVERY_METHODOLOGY.md for practical exploration techniques.","category":"section"},{"location":"mathematical_background/#Current-Limitations","page":"Mathematical Background","title":"Current Limitations","text":"Unknown patterns: Many patterns with closed forms remain undiscovered.\n\nDetection is hard: Even when pattern has closed form, detecting it automatically is challenging.\n\nPartial solutions: Some patterns have partial closed forms (e.g., some eigenvalues closed, others not).","category":"section"},{"location":"mathematical_background/#Further-Reading","page":"Mathematical Background","title":"Further Reading","text":"","category":"section"},{"location":"mathematical_background/#Classic-References","page":"Mathematical Background","title":"Classic References","text":"Galois Theory: \nStewart, I. (2015). Galois Theory (4th ed.). Chapman and Hall/CRC.\nMatrix Theory:\nHorn, R. A., & Johnson, C. R. (2012). Matrix Analysis (2nd ed.). Cambridge University Press.\nSpecial Matrices:\nDavis, P. J. (1979). Circulant Matrices (2nd ed.). AMS Chelsea Publishing.","category":"section"},{"location":"mathematical_background/#Online-Resources","page":"Mathematical Background","title":"Online Resources","text":"Galois Theory Explained\nAbel-Ruffini Theorem\nCirculant Matrices\nKronecker Product","category":"section"},{"location":"mathematical_background/#Research-Papers","page":"Mathematical Background","title":"Research Papers","text":"For specific patterns implemented in this package, see references in notes/PATTERN_DISCOVERIES.md.","category":"section"},{"location":"contributing/#Contributing-to-SymbolicDiagonalization.jl","page":"Contributing","title":"Contributing to SymbolicDiagonalization.jl","text":"Thank you for your interest in contributing! This guide covers development setup, coding standards, testing requirements, and how to add new patterns.","category":"section"},{"location":"contributing/#Development-Setup","page":"Contributing","title":"Development Setup","text":"","category":"section"},{"location":"contributing/#Prerequisites","page":"Contributing","title":"Prerequisites","text":"Julia ≥1.6\nGit (if the project becomes a repository)\nRecommended: VSCode with Julia extension","category":"section"},{"location":"contributing/#Installation-for-Development","page":"Contributing","title":"Installation for Development","text":"# Clone or navigate to the package directory\ncd SymbolicDiagonalization.jl\n\n# Activate the project environment\njulia --project=.\n\n# Install dependencies\njulia> using Pkg\njulia> Pkg.instantiate()\n\n# Run tests to verify setup\njulia> Pkg.test()","category":"section"},{"location":"contributing/#Project-Structure","page":"Contributing","title":"Project Structure","text":"SymbolicDiagonalization.jl/\n├── src/\n│   ├── SymbolicDiagonalization.jl  # Main module\n│   ├── characteristic_poly.jl       # Bareiss determinant\n│   ├── root_solvers.jl              # Closed-form root formulas (1-4)\n│   ├── structure_detection.jl       # Pattern detection algorithms\n│   ├── special_patterns.jl          # Pattern-specific eigensolvers\n│   ├── eigenvectors.jl              # Nullspace computation\n│   └── utils.jl                     # Helper functions\n├── test/\n│   ├── runtests.jl                  # Test suite entry point\n│   ├── test_basic.jl                # Small matrix tests\n│   ├── test_structures.jl           # Pattern-specific tests\n│   └── test_edge_cases.jl           # Edge case coverage\n├── docs/\n│   ├── src/                         # Documentation source\n│   └── make.jl                      # Documentation builder\n└── examples/\n    └── explore_patterns.jl          # Interactive pattern exploration","category":"section"},{"location":"contributing/#Code-Style-Guidelines","page":"Contributing","title":"Code Style Guidelines","text":"","category":"section"},{"location":"contributing/#General-Principles","page":"Contributing","title":"General Principles","text":"Clarity over cleverness: Readable code is maintainable code\nType stability: Avoid type instabilities for performance\nDocument intent: Comments should explain why, not what\nFail fast: Use early error checks with clear messages","category":"section"},{"location":"contributing/#Naming-Conventions","page":"Contributing","title":"Naming Conventions","text":"Functions: snake_case (e.g., detect_block_diagonal)\nTypes: PascalCase (e.g., EigenPair)\nConstants: SCREAMING_SNAKE_CASE (e.g., MAX_ITERATIONS)\nPrivate functions: Prefix with _ (e.g., _compute_helper)","category":"section"},{"location":"contributing/#Code-Formatting","page":"Contributing","title":"Code Formatting","text":"# Good: Clear structure, well-documented\nfunction detect_circulant(A::AbstractMatrix{T}) where T\n    n = size(A, 1)\n    n == size(A, 2) || return false\n    \n    # Check if all rows are cyclic shifts of first row\n    for i in 2:n\n        for j in 1:n\n            if A[i, j] != A[1, mod1(j - i + 1, n)]\n                return false\n            end\n        end\n    end\n    return true\nend\n\n# Bad: Dense, unclear, no documentation\nfunction detect_circulant(A::AbstractMatrix{T}) where T;n=size(A,1);n==size(A,2)||return false;for i in 2:n;for j in 1:n;A[i,j]!=A[1,mod1(j-i+1,n)]&&return false;end;end;true;end","category":"section"},{"location":"contributing/#Documentation-Strings","page":"Contributing","title":"Documentation Strings","text":"Every exported function must have a docstring following this template:\n\n\"\"\"\n    function_name(arg1, arg2; kwarg1=default)\n\nBrief one-line description.\n\nExtended description with usage details, algorithm notes, and complexity.\n\n# Arguments\n- `arg1`: Description of arg1\n- `arg2`: Description of arg2\n\n# Keywords\n- `kwarg1`: Description and default value\n\n# Returns\nDescription of return value(s)\n\n# Examples\n\njulia julia> using SymbolicDiagonalization, Symbolics julia> @variables a b julia> result = function_name([a b; b a]) [a + b, a - b]\n\n\n# Complexity\nTime and space complexity analysis\n\n# References\n- [Author Year] Paper title, Journal/Conference\n\"\"\"\nfunction function_name(arg1, arg2; kwarg1=default)\n    # Implementation\nend","category":"section"},{"location":"contributing/#Testing-Requirements","page":"Contributing","title":"Testing Requirements","text":"","category":"section"},{"location":"contributing/#Test-Coverage-Standards","page":"Contributing","title":"Test Coverage Standards","text":"All new functions: Must have at least one test\nPattern detectors: Test true positives AND false negatives\nEigensolvers: Test correctness (Av = λv) and completeness (all eigenvalues found)\nEdge cases: Empty matrices, 1×1 matrices, repeated eigenvalues","category":"section"},{"location":"contributing/#Writing-Tests","page":"Contributing","title":"Writing Tests","text":"Use the @testset macro to organize tests:\n\n@testset \"Circulant Matrices\" begin\n    @testset \"Detection\" begin\n        # Test positive detection\n        @variables a b c\n        circ = [a b c; c a b; b c a]\n        @test detect_circulant(circ) == true\n        \n        # Test negative detection\n        non_circ = [a b c; c a b; a c b]\n        @test detect_circulant(non_circ) == false\n    end\n    \n    @testset \"Eigenvalues\" begin\n        # Test known eigenvalue formula\n        circ = [1 2 3; 3 1 2; 2 3 1]\n        λ = eigvals(circ)\n        \n        # Verify A*v = λ*v for each eigenvalue\n        for (i, val) in enumerate(λ)\n            v = eigvecs(circ)[:, i]\n            @test circ * v ≈ val * v atol=1e-10\n        end\n    end\n    \n    @testset \"Size Scaling\" begin\n        # Test pattern works for various sizes\n        for n in [3, 5, 7, 10]\n            A = circulant_matrix(n)\n            λ = eigvals(A)\n            @test length(λ) == n\n        end\n    end\nend","category":"section"},{"location":"contributing/#Running-Tests","page":"Contributing","title":"Running Tests","text":"# Run full test suite\njulia> using Pkg; Pkg.test()\n\n# Run specific test file\njulia> include(\"test/test_structures.jl\")\n\n# Run with coverage\njulia --code-coverage=user -e 'using Pkg; Pkg.test()'","category":"section"},{"location":"contributing/#Adding-New-Patterns","page":"Contributing","title":"Adding New Patterns","text":"Follow this 5-step process to add a new matrix pattern:","category":"section"},{"location":"contributing/#Step-1:-Detection-Function","page":"Contributing","title":"Step 1: Detection Function","text":"Create a detector in src/structure_detection.jl:\n\n\"\"\"\n    detect_my_pattern(A::AbstractMatrix) -> Bool\n\nDetect if matrix A has MyPattern structure.\n\nMyPattern is defined as [mathematical definition].\n\n# Complexity\nO(n²) - Checks all matrix entries\n\"\"\"\nfunction detect_my_pattern(A::AbstractMatrix{T}) where T\n    n = size(A, 1)\n    n == size(A, 2) || return false\n    \n    # Check pattern-specific properties\n    for i in 1:n, j in 1:n\n        # Pattern condition\n        if !condition(A[i,j])\n            return false\n        end\n    end\n    return true\nend","category":"section"},{"location":"contributing/#Step-2:-Eigensolver-Function","page":"Contributing","title":"Step 2: Eigensolver Function","text":"Create a solver in src/special_patterns.jl:\n\n\"\"\"\n    solve_my_pattern(A::AbstractMatrix; kwargs...) -> Vector\n\nCompute eigenvalues of MyPattern matrices using [algorithm name].\n\n# Algorithm\nBrief description of the algorithm and its basis (e.g., DFT, closed-form formula).\n\n# Complexity\n- Time: O(f(n))\n- Space: O(g(n))\n\n# References\n- [Author Year] Paper title\n\"\"\"\nfunction solve_my_pattern(A::AbstractMatrix{T}; kwargs...) where T\n    n = size(A, 1)\n    \n    # Extract pattern parameters\n    params = extract_parameters(A)\n    \n    # Compute eigenvalues using pattern-specific algorithm\n    eigenvalues = compute_eigenvalues(params)\n    \n    return eigenvalues\nend","category":"section"},{"location":"contributing/#Step-3:-Integration","page":"Contributing","title":"Step 3: Integration","text":"Add pattern to detection chain in src/structure_detection.jl:\n\nfunction detect_and_solve(A::AbstractMatrix; kwargs...)\n    # ... existing patterns ...\n    \n    # Add new pattern\n    if detect_my_pattern(A)\n        return solve_my_pattern(A; kwargs...)\n    end\n    \n    # ... fallback ...\nend","category":"section"},{"location":"contributing/#Step-4:-Testing","page":"Contributing","title":"Step 4: Testing","text":"Create comprehensive tests in test/test_structures.jl:\n\n@testset \"MyPattern Matrices\" begin\n    @testset \"Detection\" begin\n        # True positive\n        @variables a b\n        mat = construct_my_pattern(a, b)\n        @test detect_my_pattern(mat) == true\n        \n        # False negative\n        non_mat = [a b; b a]\n        @test detect_my_pattern(non_mat) == false\n    end\n    \n    @testset \"Known Eigenvalues\" begin\n        # Test with known theoretical eigenvalues\n        A = [concrete example]\n        λ = eigvals(A)\n        expected = [known eigenvalues]\n        @test sort(λ) ≈ sort(expected)\n    end\n    \n    @testset \"Eigenvector Verification\" begin\n        # Verify A*v = λ*v\n        A = construct_my_pattern(...)\n        E = eigen(A)\n        for i in 1:length(E.values)\n            @test A * E.vectors[:, i] ≈ E.values[i] * E.vectors[:, i]\n        end\n    end\n    \n    @testset \"Size Scaling\" begin\n        # Test multiple sizes\n        for n in [3, 5, 10, 20]\n            A = construct_my_pattern(n)\n            λ = eigvals(A)\n            @test length(λ) == n\n        end\n    end\nend","category":"section"},{"location":"contributing/#Step-5:-Documentation","page":"Contributing","title":"Step 5: Documentation","text":"Add pattern to docs/src/pattern_library.md:\n\n## MyPattern\n\n### Definition\nMathematical definition with notation.\n\n### Properties\n- Property 1\n- Property 2\n\n### Eigenvalue Formula\nClosed-form expression or algorithm description.\n\n### Example\n\\```julia\n@variables a b\nA = [matrix construction]\nλ = eigvals(A)\n# Result: [eigenvalues]\n\\```\n\n### Complexity\n- Detection: O(n²)\n- Eigenvalues: O(f(n))\n- Eigenvectors: O(g(n))\n\n### Implementation Details\nAlgorithm notes, numerical considerations, limitations.\n\n### References\n- [Author Year] Paper title","category":"section"},{"location":"contributing/#Pattern-Submission-Template","page":"Contributing","title":"Pattern Submission Template","text":"When proposing a new pattern, open an issue with:\n\n## Pattern Name: [Name]\n\n### Mathematical Definition\nLaTeX or clear description of the pattern\n\n### Eigenvalue Formula\nKnown closed-form formula or algorithm\n\n### Complexity\nExpected time/space complexity\n\n### References\nPapers or textbooks describing the pattern\n\n### Example\nConcrete example matrix and its eigenvalues\n\n### Implementation Notes\nAny special considerations (numerical stability, edge cases, etc.)","category":"section"},{"location":"contributing/#Git-Workflow-(When-Applicable)","page":"Contributing","title":"Git Workflow (When Applicable)","text":"If this project becomes a Git repository:","category":"section"},{"location":"contributing/#Branch-Naming","page":"Contributing","title":"Branch Naming","text":"feature/pattern-name - New pattern implementations\nfix/issue-description - Bug fixes\ndocs/topic - Documentation updates\nperf/optimization-area - Performance improvements","category":"section"},{"location":"contributing/#Commit-Messages","page":"Contributing","title":"Commit Messages","text":"Follow conventional commits:\n\ntype(scope): Brief description\n\nDetailed explanation of changes and motivation.\n\nFixes #issue-number\n\nTypes: feat, fix, docs, test, perf, refactor, style","category":"section"},{"location":"contributing/#Pull-Request-Process","page":"Contributing","title":"Pull Request Process","text":"Fork and branch from main\nImplement with tests and documentation\nRun tests - All must pass\nUpdate docs - Add examples and API references\nOpen PR with clear description\nAddress review comments\nSquash and merge when approved","category":"section"},{"location":"contributing/#Code-Review-Guidelines","page":"Contributing","title":"Code Review Guidelines","text":"","category":"section"},{"location":"contributing/#For-Reviewers","page":"Contributing","title":"For Reviewers","text":"Check correctness: Verify algorithm implementation against references\nTest coverage: Ensure all code paths are tested\nDocumentation: Confirm docstrings and examples are clear\nPerformance: Look for obvious inefficiencies\nStyle: Check adherence to guidelines","category":"section"},{"location":"contributing/#For-Authors","page":"Contributing","title":"For Authors","text":"Self-review first: Read your own changes critically\nRespond promptly: Address feedback quickly\nBe open: Accept constructive criticism gracefully\nTest thoroughly: Don't rely on reviewers to find bugs","category":"section"},{"location":"contributing/#Performance-Optimization-Guidelines","page":"Contributing","title":"Performance Optimization Guidelines","text":"","category":"section"},{"location":"contributing/#Profiling","page":"Contributing","title":"Profiling","text":"using Profile, ProfileView\n\n# Profile a function\n@profile eigvals(large_matrix)\nProfileView.view()\n\n# Benchmark with BenchmarkTools\nusing BenchmarkTools\n@benchmark eigvals($matrix)","category":"section"},{"location":"contributing/#Common-Optimizations","page":"Contributing","title":"Common Optimizations","text":"Avoid allocations: Use in-place operations where possible\nType stability: Ensure functions return consistent types\nLoop order: Access arrays in column-major order\nSIMD: Use @simd for vectorizable loops\nPreallocation: Allocate output arrays before loops","category":"section"},{"location":"contributing/#Example-Optimization","page":"Contributing","title":"Example Optimization","text":"# Slow: Allocates in loop\nfunction slow_transform(A)\n    result = []\n    for i in 1:size(A, 1)\n        push!(result, transform(A[i, :]))\n    end\n    return result\nend\n\n# Fast: Preallocated, type-stable\nfunction fast_transform(A::Matrix{T}) where T\n    n = size(A, 1)\n    result = Vector{T}(undef, n)\n    for i in 1:n\n        result[i] = transform(view(A, i, :))\n    end\n    return result\nend","category":"section"},{"location":"contributing/#Documentation-Building","page":"Contributing","title":"Documentation Building","text":"","category":"section"},{"location":"contributing/#Local-Documentation","page":"Contributing","title":"Local Documentation","text":"# Build documentation\njulia --project=docs docs/make.jl\n\n# View in browser with HTTP server (required for navigation links to work)\ncd docs\n./serve.sh\n# Then open http://localhost:8000","category":"section"},{"location":"contributing/#Documentation-Style","page":"Contributing","title":"Documentation Style","text":"Be concise: Short sentences, clear structure\nUse examples: Show, don't just tell\nLink references: Cross-reference related functions\nUpdate regularly: Keep docs in sync with code","category":"section"},{"location":"contributing/#CI/CD-Setup-for-GitHub","page":"Contributing","title":"CI/CD Setup for GitHub","text":"","category":"section"},{"location":"contributing/#Automatic-Documentation-Deployment","page":"Contributing","title":"Automatic Documentation Deployment","text":"The package includes GitHub Actions workflow for automatic documentation deployment to GitHub Pages.","category":"section"},{"location":"contributing/#Initial-Setup-(One-Time)","page":"Contributing","title":"Initial Setup (One-Time)","text":"1. Generate SSH Deploy Key\n\n# Install DocumenterTools if needed\njulia -e 'using Pkg; Pkg.add(\"DocumenterTools\")'\n\n# Generate deploy key\njulia -e 'using DocumenterTools; DocumenterTools.genkeys()'\n\nThis creates:\n\ndocs/src/.documenter (private key - do NOT commit)\nPublic key displayed in terminal\n\n2. Add Deploy Key to GitHub\n\nGo to your repository on GitHub\nNavigate to: Settings → Deploy keys → Add deploy key\nTitle: documenter-key\nKey: Paste the public key from step 1\n✅ Check \"Allow write access\"\nClick Add key\n\n3. Add Private Key as GitHub Secret\n\nCopy the contents of docs/src/.documenter (the private key file)\nGo to: Settings → Secrets and variables → Actions\nClick New repository secret\nName: DOCUMENTER_KEY\nValue: Paste the entire private key contents\nClick Add secret\n\n4. Update Repository URLs in docs/make.jl\n\nReplace YOUR_USERNAME with your GitHub username:\n\nrepo = \"https://github.com/YOUR_USERNAME/SymbolicDiagonalization.jl/blob/{commit}{path}#{line}\",\ncanonical = \"https://YOUR_USERNAME.github.io/SymbolicDiagonalization.jl\",\n\nAnd:\n\ndeploydocs(;\n    repo = \"github.com/YOUR_USERNAME/SymbolicDiagonalization.jl\",\n\n5. Enable GitHub Pages\n\nGo to: Settings → Pages\nSource: Deploy from a branch\nBranch: gh-pages / root\nClick Save","category":"section"},{"location":"contributing/#How-It-Works","page":"Contributing","title":"How It Works","text":"On push to main: Builds and deploys docs to gh-pages branch\nOn pull requests: Builds docs to verify they work (doesn't deploy)\nOn tags: Deploys versioned documentation\n\nYour documentation will be available at:\n\nhttps://YOUR_USERNAME.github.io/SymbolicDiagonalization.jl/","category":"section"},{"location":"contributing/#Testing-CI-Locally","page":"Contributing","title":"Testing CI Locally","text":"You can test that the CI build will work:\n\n# Simulate CI environment\nCI=true julia --project=docs -e '\n    using Pkg\n    Pkg.develop(PackageSpec(path=pwd()))\n    Pkg.instantiate()\n'\nCI=true julia --project=docs docs/make.jl","category":"section"},{"location":"contributing/#Troubleshooting","page":"Contributing","title":"Troubleshooting","text":"\"SSH key authentication failed\"\n\nEnsure DOCUMENTER_KEY secret contains the entire private key\nVerify deploy key has write access enabled\n\n\"gh-pages branch not found\"\n\nFirst deployment creates the branch automatically\nWait a few minutes after first push\n\n\"Documentation build failed\"\n\nCheck the Actions tab for error logs\nEnsure all dependencies are in docs/Project.toml\nTest locally with CI=true as shown above\n\n\"Pages not updating\"\n\nCheck GitHub Pages is enabled and pointing to gh-pages\nMay take 5-10 minutes for changes to appear\nCheck Pages build status in Actions tab","category":"section"},{"location":"contributing/#Getting-Help","page":"Contributing","title":"Getting Help","text":"","category":"section"},{"location":"contributing/#Resources","page":"Contributing","title":"Resources","text":"Julia Discourse: https://discourse.julialang.org/\nJulia Slack: Get invited at https://julialang.org/slack/\nSymbolics.jl Docs: https://symbolics.juliasymbolics.org/","category":"section"},{"location":"contributing/#Questions?","page":"Contributing","title":"Questions?","text":"Open an issue with:\n\nClear description of the problem\nMinimal reproducible example\nJulia version and package versions (Pkg.status())\nExpected vs actual behavior","category":"section"},{"location":"contributing/#License","page":"Contributing","title":"License","text":"Contributions are assumed to be licensed under the same license as the package (MIT).\n\nBy contributing, you agree that your contributions will be licensed under the MIT License.\n\n\n\nThank you for contributing to SymbolicDiagonalization.jl!","category":"section"},{"location":"user_guide/#User-Guide","page":"User Guide","title":"User Guide","text":"Practical guide to using SymbolicDiagonalization.jl effectively.","category":"section"},{"location":"user_guide/#Table-of-Contents","page":"User Guide","title":"Table of Contents","text":"Getting Started\nBasic Workflows\nWorking with Special Patterns\nPerformance Optimization\nTroubleshooting\nAdvanced Usage\n\n","category":"section"},{"location":"user_guide/#Getting-Started","page":"User Guide","title":"Getting Started","text":"","category":"section"},{"location":"user_guide/#Installation","page":"User Guide","title":"Installation","text":"# From package directory\ncd SymbolicDiagonalization.jl\njulia --project -e 'using Pkg; Pkg.instantiate()'","category":"section"},{"location":"user_guide/#Basic-Setup","page":"User Guide","title":"Basic Setup","text":"using Symbolics\nusing SymbolicDiagonalization\nusing LinearAlgebra\n\n# Define symbolic variables\n@variables a b c d\n\n# Create a matrix\nM = [a b; b a]\n\n# Compute eigenvalues\nλ = eigvals(M)  # [a+b, a-b]","category":"section"},{"location":"user_guide/#Quick-Reference","page":"User Guide","title":"Quick Reference","text":"# Eigenvalues only (fast)\nλ = eigvals(A)\n\n# Eigenvalues + eigenvectors\nE = eigen(A)\nE.values    # eigenvalues\nE.vectors   # eigenvectors as columns\n\n# With options\nλ = eigvals(A, structure=:hermitian, timeout=60)\n\n","category":"section"},{"location":"user_guide/#Basic-Workflows","page":"User Guide","title":"Basic Workflows","text":"","category":"section"},{"location":"user_guide/#Workflow-1:-Analyze-Small-Matrices-(-44)","page":"User Guide","title":"Workflow 1: Analyze Small Matrices (≤ 4×4)","text":"When to use: You have a symbolic matrix up to 4×4 and need exact eigenvalues.\n\nSteps:\n\n@variables a b c d\n\n# Create your matrix\nM = [a  b  0  0;\n     b  a  0  0;\n     0  0  c  d;\n     0  0  d  c]\n\n# Get eigenvalues (structure auto-detected)\nλ = eigvals(M)\n# Output: [a+b, a-b, c+d, c-d]\n\n# Get eigenvectors too\nE = eigen(M)\n\nTips:\n\nMatrices ≤ 3×3 compute quickly\n4×4 may be slow for fully symbolic (use structure!)\nAdd structure when possible (zeros, blocks)\n\n","category":"section"},{"location":"user_guide/#Workflow-2:-Block-Diagonal-Matrices","page":"User Guide","title":"Workflow 2: Block-Diagonal Matrices","text":"When to use: Your matrix has block structure with zeros off the blocks.\n\nSteps:\n\n# Large matrix with block structure\n@variables a b c d e f\n\nM = [a  b  0  0  0  0;\n     b  a  0  0  0  0;\n     0  0  c  d  0  0;\n     0  0  d  c  0  0;\n     0  0  0  0  e  f;\n     0  0  0  0  f  e]\n\n# Automatic block detection\nλ = eigvals(M)\n# Solves three 2×2 blocks independently\n\nWhy this is fast: 6×6 would normally require degree-6 polynomial (impossible), but block structure reduces to three quadratics.\n\nHow to recognize: Look for zero-blocks separating independent subsystems.\n\n","category":"section"},{"location":"user_guide/#Workflow-3:-Circulant-Matrices","page":"User Guide","title":"Workflow 3: Circulant Matrices","text":"When to use: Each row is a cyclic shift of the previous row.\n\nSteps:\n\n@variables a b c d\n\n# 4×4 circulant\nC = [a b c d;\n     d a b c;\n     c d a b;\n     b c d a]\n\n# DFT-based closed form (works for ANY size!)\nλ = eigvals(C)\n\nPattern recognition:\n\nRow 1: [a b c d]\nRow 2: [d a b c]  ← shift right by 1\nRow 3: [c d a b]  ← shift right by 2\nRow 4: [b c d a]  ← shift right by 3\n\nWorks for huge matrices: Even 100×100 circulant has closed form!\n\n","category":"section"},{"location":"user_guide/#Workflow-4:-Tridiagonal-Matrices","page":"User Guide","title":"Workflow 4: Tridiagonal Matrices","text":"When to use: Matrix is tridiagonal with constant diagonals.\n\nSteps:\n\n@variables a b\n\n# Symmetric Toeplitz tridiagonal\nn = 5\nT = diagm(0 => fill(a, n), \n          1 => fill(b, n-1),\n         -1 => fill(b, n-1))\n\n# Closed-form via cosines\nλ = eigvals(T)\n# λₖ = a + 2b·cos(kπ/(n+1)) for k=1,...,n\n\nPattern recognition:\n\nAll diagonal entries the same: a\nAll super-diagonal the same: b\nAll sub-diagonal the same: b\nSymmetric\n\n","category":"section"},{"location":"user_guide/#Workflow-5:-Kronecker-Products","page":"User Guide","title":"Workflow 5: Kronecker Products","text":"When to use: Matrix is a tensor product A ⊗ B.\n\nSteps:\n\n@variables a b c d\n\n# Two small matrices\nA = [a 0; 0 b]  # 2×2\nB = [c 0; 0 d]  # 2×2\n\n# Kronecker product (4×4)\nK = kron(A, B)\n\n# Eigenvalues are products\nλ = eigvals(K)\n# [ac, ad, bc, bd]\n\nWhy this works: 4×4 is manageable, but what if A and B were larger?\n\nExample: 6×6 = (2×2) ⊗ (3×3)\n\nA = [a b; b a]          # 2×2, eigenvalues {a+b, a-b}\nB = [c d 0; d c d; 0 d c]  # 3×3, eigenvalues computed via cubic\n\nK = kron(A, B)  # 6×6 matrix\n\nλ = eigvals(K)\n# Computes eigenvalues of A and B separately\n# Then forms all products λᵢ(A) · λⱼ(B)\n\nWithout Kronecker structure, degree-6 polynomial is impossible!\n\n","category":"section"},{"location":"user_guide/#Working-with-Special-Patterns","page":"User Guide","title":"Working with Special Patterns","text":"","category":"section"},{"location":"user_guide/#Hermitian-Matrices","page":"User Guide","title":"Hermitian Matrices","text":"@variables a::Real b::Real\n\n# Hermitian matrix (complex conjugate symmetric)\nH = [a b; conj(b) a]\n\n# Hint that it's Hermitian for optimizations\nλ = eigvals(H, structure=:hermitian)\n\nProperties:\n\nAlways real eigenvalues\nOrthogonal eigenvectors\nDiagonalizable\n\n","category":"section"},{"location":"user_guide/#Permutation-Matrices","page":"User Guide","title":"Permutation Matrices","text":"# 5×5 permutation: (1→2→3→1), (4↔5)\nP = [0 1 0 0 0;   # 1→2\n     0 0 1 0 0;   # 2→3\n     1 0 0 0 0;   # 3→1\n     0 0 0 0 1;   # 4→5\n     0 0 0 1 0]   # 5→4\n\nλ = eigvals(P)\n# 3-cycle: {1, ω, ω²} where ω = exp(2πi/3)\n# 2-cycle: {1, -1}\n# Total: {1, 1, 1, -1, ω, ω²}\n\nKey insight: All eigenvalues are roots of unity (magnitude 1).\n\n","category":"section"},{"location":"user_guide/#Anti-Diagonal-Matrices","page":"User Guide","title":"Anti-Diagonal Matrices","text":"@variables a b c\n\n# 5×5 anti-diagonal\nA = [0 0 0 0 a;\n     0 0 0 b 0;\n     0 0 c 0 0;\n     0 b 0 0 0;\n     a 0 0 0 0]\n\nλ = eigvals(A)\n# {c, ±a, ±b}\n\nPattern: Eigenvalues come in ±pairs (except center for odd n).\n\n","category":"section"},{"location":"user_guide/#Performance-Optimization","page":"User Guide","title":"Performance Optimization","text":"","category":"section"},{"location":"user_guide/#Tip-1:-Use-Structure-Hints","page":"User Guide","title":"Tip 1: Use Structure Hints","text":"# Without hint (may be slower)\nλ₁ = eigvals(M)\n\n# With hint (faster)\nλ₂ = eigvals(M, structure=:hermitian)\n\nWhen to use:\n\n:hermitian - Hermitian matrices\n:symmetric - Real symmetric\n:unitary - Unitary matrices\n:general - No assumptions\n\n","category":"section"},{"location":"user_guide/#Tip-2:-Eigenvalues-Only","page":"User Guide","title":"Tip 2: Eigenvalues Only","text":"# Slow: computes eigenvectors\nE = eigen(M)\nλ = E.values\n\n# Fast: eigenvalues only\nλ = eigvals(M)\n\nSpeedup: 2-5x for medium matrices, more for large ones.\n\n","category":"section"},{"location":"user_guide/#Tip-3:-Partial-Substitution","page":"User Guide","title":"Tip 3: Partial Substitution","text":"If your matrix has many symbolic variables but some can be numeric:\n\n@variables a b c d e f g h\n\n# Fully symbolic 4×4 (slow, huge expressions)\nM = [a b c d; e f g h; ...]\n\n# Substitute some variables\nusing Symbolics: substitute\nM_partial = substitute(M, Dict(\n    c => 0, d => 0,  # Add structure with zeros\n    e => 0, g => 0\n))\n\n# Now much faster\nλ = eigvals(M_partial)\n\n","category":"section"},{"location":"user_guide/#Tip-4:-Increase-Timeout-for-Complex-Matrices","page":"User Guide","title":"Tip 4: Increase Timeout for Complex Matrices","text":"# Default timeout: 300 seconds\nλ = eigvals(M)\n\n# Allow more time\nλ = eigvals(M, timeout=600)\n\n","category":"section"},{"location":"user_guide/#Tip-5:-Simplify-Results","page":"User Guide","title":"Tip 5: Simplify Results","text":"using Symbolics: simplify\n\nλ = eigvals(M)\n\n# Simplify expressions\nλ_simple = simplify.(λ)\n\n","category":"section"},{"location":"user_guide/#Troubleshooting","page":"User Guide","title":"Troubleshooting","text":"","category":"section"},{"location":"user_guide/#Problem:-\"Cannot-solve-degree-n-5-without-structure\"","page":"User Guide","title":"Problem: \"Cannot solve degree n ≥ 5 without structure\"","text":"Cause: Matrix is 5×5+ with no detected structure.\n\nSolutions:\n\nCheck for block structure:\n\n# Add zeros to create blocks\nM_blocked = [A zeros(2,2); zeros(3,2) B]\n\nLook for special patterns: Is it circulant? Tridiagonal? Kronecker product?\nUse numeric substitution:\n\n# Substitute some variables with numbers\nM_numeric = substitute(M, Dict(a => 1, b => 2))\n\nUse numerical methods:\n\n# Convert to Float64 and solve numerically\nM_float = Float64.(substitute(M, Dict(...)))\nλ_numeric = eigvals(M_float)  # Standard LinearAlgebra\n\n","category":"section"},{"location":"user_guide/#Problem:-Expression-Complexity-Error","page":"User Guide","title":"Problem: Expression Complexity Error","text":"Cause: Expressions exceed max_terms limit (default 10,000).\n\nSolutions:\n\nIncrease limit (watch memory!):\n\nλ = eigvals(M, max_terms=50000)\n\nAdd structure:\n\n# Replace off-block elements with zeros\nM_sparse = ...\n\nUse expand=false:\n\nλ = eigvals(M, expand=false)\n\n","category":"section"},{"location":"user_guide/#Problem:-Computation-Timeout","page":"User Guide","title":"Problem: Computation Timeout","text":"Cause: Exceeded time limit (default 300s).\n\nSolutions:\n\nIncrease timeout:\n\nλ = eigvals(M, timeout=900)  # 15 minutes\n\nSimplify matrix:\n\n# Use fewer variables\n# Add structure (zeros, blocks)\n# Partial numeric substitution\n\nCheck matrix size: 4×4 fully symbolic takes ~minutes. 5×5+ may be impossible.\n\n","category":"section"},{"location":"user_guide/#Problem:-Wrong-Eigenvalues","page":"User Guide","title":"Problem: Wrong Eigenvalues","text":"Cause: Incorrect structure hint or numerical issues.\n\nSolutions:\n\nRemove structure hint:\n\nλ = eigvals(M)  # Auto-detect\n\nVerify numerically:\n\n# Substitute numeric values\nM_test = substitute(M, Dict(a=>1, b=>2, c=>3))\nλ_numeric = eigvals(M_test)\n\n# Check against symbolic\nλ_sym = eigvals(M)\nλ_sym_test = substitute.(λ_sym, Ref(Dict(a=>1, b=>2, c=>3)))\n\n# Compare\n@assert isapprox(sort(λ_numeric), sort(λ_sym_test))\n\n","category":"section"},{"location":"user_guide/#Problem:-Expression-Too-Large-(Memory-Issues)","page":"User Guide","title":"Problem: Expression Too Large (Memory Issues)","text":"Cause: Quartic formula on fully symbolic 4×4 produces ~13.5 MB per eigenvalue.\n\nSolutions:\n\nDon't use fully symbolic 4×4: Add structure!\nPartial substitution:\n\nM_partial = substitute(M, Dict(\n    # Set some entries to simple values\n    M[1,3] => 0,\n    M[1,4] => 0,\n    M[2,4] => 0\n))\n\nUse block structure:\n\n# Instead of 4×4, use 2×2 blocks\nM = [A zeros(2,2); zeros(2,2) B]\n\n","category":"section"},{"location":"user_guide/#Advanced-Usage","page":"User Guide","title":"Advanced Usage","text":"","category":"section"},{"location":"user_guide/#Custom-Eigenvalue-Variables","page":"User Guide","title":"Custom Eigenvalue Variables","text":"@variables λ a b\n\nM = [a b; b a]\n\n# Use specific variable name\nvals, poly, λ_var = symbolic_eigenvalues(M, var=λ)\n\n","category":"section"},{"location":"user_guide/#Characteristic-Polynomial-Only","page":"User Guide","title":"Characteristic Polynomial Only","text":"M = [a b; b a]\n\npoly, coeffs, λ = characteristic_polynomial(M)\n# poly: λ² - 2a·λ + (a² - b²)\n# coeffs: [a² - b², -2a, 1]\n\n","category":"section"},{"location":"user_guide/#Eigenpairs-with-Multiplicity","page":"User Guide","title":"Eigenpairs with Multiplicity","text":"M = [a 0 0; 0 a 1; 0 0 a]  # Jordan block\n\npairs = symbolic_eigenpairs(M)\n# [(a, [v₁, v₂, ...])]  # May have multiple eigenvectors\n\n","category":"section"},{"location":"user_guide/#Verification","page":"User Guide","title":"Verification","text":"P, D, pairs = symbolic_diagonalize(M)\n\n# Verify: M = P * D * P⁻¹\nusing Symbolics: simplify\nerr = simplify.(M - P * D * inv(P))\n@assert all(iszero, err)\n\n","category":"section"},{"location":"user_guide/#Mixed-Numeric-Symbolic","page":"User Guide","title":"Mixed Numeric-Symbolic","text":"# Some entries numeric, some symbolic\n@variables a b\n\nM = [a   1.5  0   0;\n     1.5 b    0   0;\n     0   0    2.0 1.0;\n     0   0    1.0 3.0]\n\nλ = eigvals(M)  # Works fine!\n\n","category":"section"},{"location":"user_guide/#Practical-Examples","page":"User Guide","title":"Practical Examples","text":"","category":"section"},{"location":"user_guide/#Example-1:-Vibrating-String","page":"User Guide","title":"Example 1: Vibrating String","text":"Discrete model of vibrating string with n masses:\n\n@variables k m ω\n\nn = 5\n# Stiffness matrix (tridiagonal)\nK = diagm(0 => fill(2k, n),\n          1 => fill(-k, n-1),\n         -1 => fill(-k, n-1))\n\n# Eigenfrequencies: ω² = λ/m\nλ = eigvals(K)\nω_squared = λ ./ m\n\n# ωₖ = √(λₖ/m) = √(k/m) · √(4sin²(kπ/(2(n+1))))\n\n","category":"section"},{"location":"user_guide/#Example-2:-Quantum-Tight-Binding-Model","page":"User Guide","title":"Example 2: Quantum Tight-Binding Model","text":"1D tight-binding Hamiltonian:\n\n@variables t ε\n\nn = 4\nH = diagm(0 => fill(ε, n),\n          1 => fill(-t, n-1),\n         -1 => fill(-t, n-1))\n\n# Energy eigenvalues\nE = eigvals(H)\n# Eₖ = ε - 2t·cos(kπ/(n+1))\n\n","category":"section"},{"location":"user_guide/#Example-3:-Graph-Laplacian-(Cycle)","page":"User Guide","title":"Example 3: Graph Laplacian (Cycle)","text":"Laplacian of cycle graph Cₙ:\n\n@variables d\n\nn = 6\n# Cycle graph Laplacian (circulant!)\nL = [2d -d  0   0  0  -d;\n     -d 2d -d   0  0   0;\n      0 -d 2d  -d  0   0;\n      0  0 -d  2d -d   0;\n      0  0  0  -d 2d  -d;\n     -d  0  0   0 -d  2d]\n\n# Eigenvalues via circulant formula\nλ = eigvals(L)\n# λₖ = 2d(1 - cos(2πk/n)) for k=0,...,n-1\n\n","category":"section"},{"location":"user_guide/#Example-4:-Coupled-Oscillators","page":"User Guide","title":"Example 4: Coupled Oscillators","text":"Two coupled 2D oscillators:\n\n@variables k₁ k₂ κ m\n\n# Each oscillator: 2×2 block\nA = [k₁ 0; 0 k₁] / m\nB = [k₂ 0; 0 k₂] / m\n\n# Coupling\nC = [κ 0; 0 κ] / m\n\n# Full system (4×4)\nM = [A C; C B]\n\n# If κ=0: decoupled (block-diagonal)\n# If κ≠0: analyze coupled system\n\nλ = eigvals(M)\n\n","category":"section"},{"location":"user_guide/#Next-Steps","page":"User Guide","title":"Next Steps","text":"API Reference - Complete function documentation\nPattern Library - All special patterns\nMathematical Background - Theory\nImplementation - Algorithm details\nContributing - How to add new patterns\n\n","category":"section"},{"location":"user_guide/#Getting-Help","page":"User Guide","title":"Getting Help","text":"Check documentation: API reference, pattern library\nVerify numerically: Test with numeric values first\nSimplify problem: Remove variables, add structure\nReport issues: GitHub issues with minimal reproducible example","category":"section"},{"location":"pattern_library/#Pattern-Library","page":"Pattern Library","title":"Pattern Library","text":"Complete catalog of all special matrix patterns with closed-form eigenvalue solutions implemented in SymbolicDiagonalization.jl.","category":"section"},{"location":"pattern_library/#Table-of-Contents","page":"Pattern Library","title":"Table of Contents","text":"Basic Patterns\nDiagonal Matrices\nTriangular Matrices\nJordan Blocks\nStructure-Based Patterns\nBlock-Diagonal\nPersymmetric\nSymmetry-Based Patterns\nCirculant Matrices\nBlock Circulant\nAnti-Diagonal\nTensor Product Patterns\nKronecker Products\nTridiagonal Patterns\nSymmetric Toeplitz Tridiagonal\nSpecial 5×5 Patterns\nPermutation Patterns\nPermutation Matrices\n\n","category":"section"},{"location":"pattern_library/#Basic-Patterns","page":"Pattern Library","title":"Basic Patterns","text":"","category":"section"},{"location":"pattern_library/#Diagonal-Matrices","page":"Pattern Library","title":"Diagonal Matrices","text":"Structure: Non-zero only on main diagonal\n\nMatrix Form:\n\nmathbfD = beginbmatrix\nd_1  0  0  cdots  0 \n0  d_2  0  cdots  0 \n0  0  d_3  cdots  0 \nvdots  vdots  vdots  ddots  vdots \n0  0  0  cdots  d_n\nendbmatrix\n\nEigenvalues: d_1 d_2 d_3 ldots d_n (diagonal entries)\n\nEigenvectors: Standard basis vectors mathbfe_i\n\nComplexity: O(n) - direct reading\n\nExample:\n\n@variables a b c\nD = [a 0 0; 0 b 0; 0 0 c]\n\neigvals(D)  # [a, b, c]\n\nWhy this works: Diagonal matrices are already in eigenvalue form. The eigenvalue equation mathbfDmathbfv = lambdamathbfv is satisfied by standard basis vectors.\n\nMathematical properties:\n\nAlways diagonalizable\nEigenvectors are orthogonal\nSimple eigenvalue structure\n\n","category":"section"},{"location":"pattern_library/#Triangular-Matrices","page":"Pattern Library","title":"Triangular Matrices","text":"Structure: Upper or lower triangular (zeros below or above diagonal)\n\nUpper Triangular Form:\n\nmathbfU = beginbmatrix\nu_11  u_12  u_13  cdots  u_1n \n0  u_22  u_23  cdots  u_2n \n0  0  u_33  cdots  u_3n \nvdots  vdots  vdots  ddots  vdots \n0  0  0  cdots  u_nn\nendbmatrix\n\nEigenvalues: u_11 u_22 u_33 ldots u_nn (diagonal entries)\n\nEigenvectors: Computed via back-substitution\n\nComplexity: O(n) for eigenvalues, O(n^2) for eigenvectors\n\nExample:\n\n@variables a b c\nU = [a 1 2; 0 b 3; 0 0 c]\n\neigvals(U)  # [a, b, c]\n\nWhy this works: For triangular matrices, det(lambdamathbfI - mathbfU) is a product of diagonal terms (lambda - u_ii), so eigenvalues are exactly the diagonal entries.\n\nMathematical properties:\n\nMay not be diagonalizable (if repeated eigenvalues)\nEigenvalues independent of off-diagonal entries\nCharacteristic polynomial factorizes immediately\n\n","category":"section"},{"location":"pattern_library/#Jordan-Blocks","page":"Pattern Library","title":"Jordan Blocks","text":"Structure: Single repeated eigenvalue on diagonal, ones on superdiagonal\n\nMatrix Form:\n\nmathbfJ(lambda n) = beginbmatrix\nlambda  1  0  cdots  0 \n0  lambda  1  cdots  0 \n0  0  lambda  cdots  0 \nvdots  vdots  vdots  ddots  vdots \n0  0  0  cdots  lambda\nendbmatrix\n\nEigenvalues: lambda with algebraic multiplicity n\n\nEigenvectors: Only ONE eigenvector (not diagonalizable for n  1)\n\nComplexity: O(1) for eigenvalues\n\nExample:\n\n@variables λ\nJ = [λ 1 0; 0 λ 1; 0 0 λ]\n\neigvals(J)  # [λ, λ, λ]\n\nWhy this works: det(tmathbfI - mathbfJ) = (t - lambda)^n, giving repeated root lambda. Geometric multiplicity is 1 (rank deficiency).\n\nMathematical properties:\n\nNot diagonalizable (unless n = 1)\nPrototype of non-diagonalizable matrices\nAppears in Jordan normal form decomposition\n\nCaution: symbolic_diagonalize() will throw error since Jordan blocks (n  1) are not diagonalizable.\n\n","category":"section"},{"location":"pattern_library/#Structure-Based-Patterns","page":"Pattern Library","title":"Structure-Based Patterns","text":"","category":"section"},{"location":"pattern_library/#Block-Diagonal-Matrices","page":"Pattern Library","title":"Block-Diagonal Matrices","text":"Structure: Non-zero only in diagonal blocks\n\nMatrix Form:\n\nmathbfB = beginbmatrix\nmathbfA_1  mathbf0  mathbf0  cdots  mathbf0 \nmathbf0  mathbfA_2  mathbf0  cdots  mathbf0 \nmathbf0  mathbf0  mathbfA_3  cdots  mathbf0 \nvdots  vdots  vdots  ddots  vdots \nmathbf0  mathbf0  mathbf0  cdots  mathbfA_k\nendbmatrix\n\nwhere each mathbfA_i is a square matrix (possibly different sizes).\n\nEigenvalues: lambda(mathbfB) = lambda(mathbfA_1) cup lambda(mathbfA_2) cup cdots cup lambda(mathbfA_k)\n\nComplexity: O(sum_i f(n_i)) where f(n) is cost to solve size-n block\n\nExample:\n\n@variables a b c d\nB = [a  b  0  0;\n     b  a  0  0;\n     0  0  c  d;\n     0  0  d  c]\n\neigvals(B)  # [a+b, a-b, c+d, c-d]\n\nWhy this works: The characteristic polynomial factorizes:\n\ndet(lambdamathbfI - mathbfB) = det(lambdamathbfI - mathbfA_1) cdot det(lambdamathbfI - mathbfA_2) cdot ldots cdot det(lambdamathbfI - mathbfA_k)\n\nSo eigenvalues are union of eigenvalues of each block.\n\nDetection algorithm:\n\nFind connected components of non-zero structure\nRecursively solve each block independently\nConcatenate eigenvalues\n\nPractical importance: An 8 times 8 matrix with four 2 times 2 blocks requires solving 4 quadratics, not one degree-8 polynomial!\n\nMathematical properties:\n\nDiagonalizable iff all blocks are diagonalizable\nEigenvectors are block-structured\nExtremely common in practice (physical subsystems, symmetry blocks)\n\n","category":"section"},{"location":"pattern_library/#Persymmetric-Matrices","page":"Pattern Library","title":"Persymmetric Matrices","text":"Structure: Symmetric about anti-diagonal: Qij = Qn+1-j n+1-i\n\nMatrix Form (4 times 4 example):\n\nmathbfP = beginbmatrix\na  b  c  d \nb  e  f  c \nc  f  e  b \nd  c  b  a\nendbmatrix\n\nEigenvalues: Computed by splitting into half-sized problems\n\nComplexity: O(f(n2)) where f is cost for size n2\n\nExample:\n\n@variables a b c d e f\nP = [a b c d; b e f c; c f e b; d c b a]\n\neigvals(P)  # Splits into two 2×2 problems\n\nWhy this works: Persymmetric structure allows transformation:\n\nmathbfQ = mathbfJ mathbfP mathbfJ quad text(where  mathbfJ text is anti-diagonal identity)\n\nThis creates block structure in eigenvector space, splitting problem in half.\n\nTransformation details:\n\nLet mathbfJ be the flip matrix (anti-diagonal identity)\nForm symmetric combinations: (mathbfP pm mathbfJPJ)2\nThese commute and can be simultaneously diagonalized\nReduces to two half-sized eigenvalue problems\n\nDetection: Check if Qij = Qn+1-j n+1-i for all ij\n\nMathematical properties:\n\nAlways diagonalizable (if symmetric)\nEigenspaces split into symmetric/antisymmetric subspaces\nOften appears in signal processing, centrosymmetric matrices\n\nLimitation: Current implementation handles some but not all persymmetric cases.\n\n","category":"section"},{"location":"pattern_library/#Symmetry-Based-Patterns","page":"Pattern Library","title":"Symmetry-Based Patterns","text":"","category":"section"},{"location":"pattern_library/#Circulant-Matrices","page":"Pattern Library","title":"Circulant Matrices","text":"Structure: Each row is cyclic shift of previous row\n\nMatrix Form:\n\nmathbfC = beginbmatrix\nc_0  c_1  c_2  cdots  c_n-1 \nc_n-1  c_0  c_1  cdots  c_n-2 \nc_n-2  c_n-1  c_0  cdots  c_n-3 \nvdots  vdots  vdots  ddots  vdots \nc_1  c_2  c_3  cdots  c_0\nendbmatrix\n\nEigenvalues (closed-form for any n):\n\nlambda_k = sum_j=0^n-1 c_j cdot omega^kj quad textfor  k = 0 1 ldots n-1\n\nwhere omega = exp(2pi in) is the nth root of unity.\n\nEigenvectors: Columns of DFT matrix (independent of entries!)\n\nComplexity: O(n) to compute all n eigenvalues\n\nExample (3 times 3):\n\n@variables a b c\nC = [a b c; c a b; b c a]\n\n# ω = exp(2πi/3)\neigvals(C)  # [a+b+c, a+b*ω+c*ω², a+b*ω²+c*ω]\n\nWhy this works: Circulant matrices commute with cyclic shifts. The DFT diagonalizes ALL circulant matrices simultaneously. The eigenvalues are exactly the Discrete Fourier Transform of the first row.\n\nMathematical foundation:\n\nCirculant matrices form a commutative algebra\nAll share the same eigenvectors (DFT basis)\nMultiplication in circulant space = convolution in sequence space\nDiagonalization in DFT space = pointwise multiplication\n\nDetection algorithm:\n\nCheck if Cij = C(i-1) bmod n (j-1) bmod n for all ij\nExtract first row c_0 c_1 ldots c_n-1\nApply DFT formula\n\nApplications:\n\nSignal processing (circular convolution)\nTime series analysis (periodic processes)\nGraph Laplacians (cycle graphs)\nCoding theory\n\nPractical notes:\n\nWorks for ANY size n (even n = 100+!)\nGeneric n times n requires degree-n polynomial (impossible for n geq 5)\nCirculant structure bypasses Abel-Ruffini limitation\n\nVariants:\n\nSkew-circulant: Last element negated on each shift\ng-circulant: Generalized with group operation\nBlock circulant: See next section\n\n","category":"section"},{"location":"pattern_library/#Block-Circulant-Matrices","page":"Pattern Library","title":"Block Circulant Matrices","text":"Structure: Block version of circulant (blocks shift instead of elements)\n\nMatrix Form (4 blocks, size k times k each):\n\nmathbfBC = beginbmatrix\nmathbfA_0  mathbfA_1  mathbfA_2  mathbfA_3 \nmathbfA_3  mathbfA_0  mathbfA_1  mathbfA_2 \nmathbfA_2  mathbfA_3  mathbfA_0  mathbfA_1 \nmathbfA_1  mathbfA_2  mathbfA_3  mathbfA_0\nendbmatrix\n\nEigenvalues: Compute by solving n eigenvalue problems of size k times k:\n\nlambda(mathbfBC) = bigcup_m=0^n-1 lambdaleft(sum_j=0^n-1 mathbfA_j cdot omega^mjright)\n\nwhere omega = exp(2pi in).\n\nComplexity: O(n cdot f(k)) where f(k) is cost for k times k matrix\n\nExample (4 times 4 with 2 times 2 blocks):\n\n@variables a b c d\nA = [a b; c d]\nB = [1 0; 0 1]\n\n# 4×4 block circulant [A B; B A]\nBC = [a b 1 0;\n      c d 0 1;\n      1 0 a b;\n      0 1 c d]\n\neigvals(BC)  # Solves 2 problems of size 2×2\n\nWhy this works: Block circulant matrices are diagonalized by block DFT. The reduction formula creates n different k times k matrices (linear combinations of blocks with DFT coefficients), which can be solved independently.\n\nMathematical foundation:\n\nGeneralization of circulant to matrix entries\nBlock DFT plays same role as regular DFT\nEigenvalue problem decouples into n independent k times k problems\n\nDetection algorithm:\n\nCheck block structure (equal-sized blocks)\nVerify block circulant property\nExtract blocks mathbfA_0 mathbfA_1 ldots mathbfA_n-1\nForm n combinations with DFT weights\nSolve each k times k system\n\nKey examples:\n\n12 times 12 with 3 times 3 blocks: 4 blocks → solve 4 cubic equations (feasible)\n8 times 8 with 4 times 4 blocks: 2 blocks → solve 2 quartic equations (feasible but large)\n16 times 16 with 2 times 2 blocks: 8 blocks → solve 8 quadratic equations (easy)\n\nWithout block structure, these would require degree-12, degree-8, and degree-16 polynomials (impossible)!\n\nApplications:\n\nMulti-channel signal processing\nBlock Toeplitz systems\nVectorized circulant operations\nKronecker-structured problems\n\nLimitation: Requires k leq 4 for closed form (unless further structure in blocks).\n\n","category":"section"},{"location":"pattern_library/#Anti-Diagonal-Matrices","page":"Pattern Library","title":"Anti-Diagonal Matrices","text":"Structure: Non-zero only on anti-diagonal, with symmetry\n\nMatrix Form (n times n, symmetric about anti-diagonal):\n\nmathbfA = beginbmatrix\n0  0  0  cdots  0  a_n \n0  0  0  cdots  a_n-1  0 \n0  0  0  cdots  0  0 \nvdots  vdots  vdots  ddots  vdots  vdots \na_n-1  0  0  cdots  0  0 \na_n  0  0  cdots  0  0\nendbmatrix\n\nwith symmetry: Aij = An+1-j n+1-i\n\nEigenvalues (closed-form for any n):\n\nOdd n: a_k -a_k for k = 1 ldots (n-1)2, plus a_(n+1)2 (center element)\nEven n: a_k -a_k for k = 1 ldots n2\n\nEigenvector structure: pm pairs with specific symmetry\n\nComplexity: O(n) - direct computation\n\nExample (5 times 5):\n\n@variables a b c\nA = [0 0 0 0 a;\n     0 0 0 b 0;\n     0 0 c 0 0;\n     0 b 0 0 0;\n     a 0 0 0 0]\n\neigvals(A)  # {c, ±a, ±b}\n\nWhy this works: The persymmetric symmetry combined with anti-diagonal structure forces eigenvalues into pm pairs. The transformation mathbfJmathbfA (flip matrix) equals pmmathbfA, creating symmetric/antisymmetric subspaces.\n\nMathematical foundation:\n\nAnti-diagonal flip symmetry: mathbfJAJ^dagger = pmmathbfA\nEigenvectors come in symmetric/antisymmetric pairs\nEigenvalue equation: If mathbfAmathbfv = lambdamathbfv, then mathbfA(mathbfJmathbfv) = -lambda(mathbfJmathbfv)\n\nDetection algorithm:\n\nCheck if zeros everywhere except anti-diagonal\nVerify symmetry: Ai n+1-i = An+1-i i\nExtract anti-diagonal elements\nForm pm pairs (center unpaired if odd n)\n\nApplications:\n\nExchange matrices\nReversal operators\nSymmetric perturbations of identity\nQuantum mechanics (parity operators)\n\nMathematical properties:\n\nAlways diagonalizable\nReal eigenvalues if entries are real\nOrthogonal eigenvectors (pairs)\n\n","category":"section"},{"location":"pattern_library/#Tensor-Product-Patterns","page":"Pattern Library","title":"Tensor Product Patterns","text":"","category":"section"},{"location":"pattern_library/#Kronecker-Products","page":"Pattern Library","title":"Kronecker Products","text":"Structure: Tensor product mathbfA otimes mathbfB = a_ijmathbfB\n\nMatrix Form (2 times 2 otimes 2 times 2 example):\n\nmathbfA otimes mathbfB = beginbmatrix\na_11mathbfB  a_12mathbfB \na_21mathbfB  a_22mathbfB\nendbmatrix\n\nwhere each entry a_ijmathbfB is a block.\n\nEigenvalues (closed-form for any sizes m, n):\n\nlambda(mathbfA otimes mathbfB) = lambda_i(mathbfA) cdot lambda_j(mathbfB)  i = 1ldots m j = 1ldots n\n\nAll m cdot n products of eigenvalues of mathbfA and mathbfB.\n\nEigenvectors: mathbfv_ij = mathbfv_i(mathbfA) otimes mathbfv_j(mathbfB) (tensor products)\n\nComplexity: O(f(m) + f(n)) where f is cost for each factor\n\nExample (4 times 4 = 2 times 2 otimes 2 times 2):\n\n@variables a b c d\nA = [a 0; 0 b]  # eigenvalues {a, b}\nB = [c 0; 0 d]  # eigenvalues {c, d}\n\nK = kron(A, B)  # 4×4 matrix\n\neigvals(K)  # {ac, ad, bc, bd}\n\nWhy this works: The eigenvalue equation for Kronecker products:\n\n(mathbfA otimes mathbfB)(mathbfu otimes mathbfv) = (mathbfAmathbfu) otimes (mathbfBmathbfv) = (lambda_umathbfu) otimes (lambda_vmathbfv) = (lambda_ulambda_v)(mathbfu otimes mathbfv)\n\nSo if mathbfu is eigenvector of mathbfA with eigenvalue lambda_u, and mathbfv is eigenvector of mathbfB with eigenvalue lambda_v, then mathbfuotimesmathbfv is eigenvector of mathbfAotimesmathbfB with eigenvalue lambda_ulambda_v.\n\nMathematical foundation:\n\nTensor product structure in linear algebra\nFactorization of eigenspaces: E(mathbfAotimesmathbfB) = E(mathbfA) otimes E(mathbfB)\nMultiplicative property of eigenvalues\n\nDetection algorithm:\n\nCheck block pattern: equal-sized blocks\nVerify scaling relationship between blocks\nExtract factor matrices mathbfA and mathbfB\nSolve eigenvalues of mathbfA and mathbfB independently\nForm all products lambda_i(mathbfA) cdot lambda_j(mathbfB)\n\nKey examples:\n\n6 times 6 = 2 times 2 otimes 3 times 3: Quadratic times cubic = feasible\n12 times 12 = 3 times 3 otimes 4 times 4: Cubic times quartic = feasible (but large)\n12 times 12 = 4 times 4 otimes 3 times 3: Same as above\n\nWithout Kronecker structure, degree-6 and degree-12 would be impossible!\n\nApplications:\n\nMulti-dimensional systems (separable PDEs)\nQuantum mechanics (composite systems)\nGraph products (Cartesian product graphs)\nMulti-way tensor analysis\n\nDetection challenges:\n\nRequires exact scaling pattern recognition\nFloating-point errors can break detection\nCurrent implementation: basic pattern matching\n\n","category":"section"},{"location":"pattern_library/#Tridiagonal-Patterns","page":"Pattern Library","title":"Tridiagonal Patterns","text":"","category":"section"},{"location":"pattern_library/#Symmetric-Toeplitz-Tridiagonal","page":"Pattern Library","title":"Symmetric Toeplitz Tridiagonal","text":"Structure: Tridiagonal with constant diagonals (Toeplitz + tridiagonal)\n\nMatrix Form:\n\nmathbfT = beginbmatrix\na  b  0  0  cdots  0 \nb  a  b  0  cdots  0 \n0  b  a  b  cdots  0 \nvdots  vdots  vdots  vdots  ddots  vdots\nendbmatrix\n\nEigenvalues (closed-form for any n):\n\nlambda_k = a + 2bcosleft(frackpin+1right) quad textfor  k = 1 2 ldots n\n\nEigenvectors (known analytically):\n\nv_k(j) = sinleft(fracjkpin+1right) quad textfor  j = 1 ldots n\n\nComplexity: O(n) to compute all eigenvalues\n\nExample (4 times 4):\n\n@variables a b\nT = [a b 0 0;\n     b a b 0;\n     0 b a b;\n     0 0 b a]\n\n# λₖ = a + 2b·cos(kπ/5) for k=1,2,3,4\neigvals(T)\n\nWhy this works: The eigenvectors are discrete sine functions, which are known eigenfunctions of the discrete Laplacian operator. The eigenvalues come from the cosine terms in the eigenvalue equation.\n\nMathematical foundation:\n\nRelated to discrete Laplacian operator\nEigenvectors are Discrete Sine Transform (DST) basis\nConnection to Chebyshev polynomials\nComes from finite-difference discretization of d^2dx^2\n\nDerivation: The eigenvalue equation mathbfTmathbfv = lambdamathbfv with mathbfv = sin(kpi(n+1)) sin(2kpi(n+1)) ldots sin(nkpi(n+1)) gives:\n\nasinleft(fracjkpin+1right) + bsinleft(frac(j-1)kpin+1right) + bsinleft(frac(j+1)kpin+1right) = lambda_ksinleft(fracjkpin+1right)\n\nUsing trigonometric identity sin(alpha)+sin(beta) = 2sin((alpha+beta)2)cos((alpha-beta)2), this simplifies to lambda_k = a + 2bcos(kpi(n+1)).\n\nDetection algorithm:\n\nCheck tridiagonal structure (zeros beyond sub/super-diagonals)\nVerify constant diagonals: all diagonal = a, all off-diagonal = b\nVerify symmetry: sub-diagonal = super-diagonal\nApply formula for k = 1 ldots n\n\nApplications:\n\nFinite difference methods (1D Laplacian)\nVibrating string (discrete model)\nHeat equation discretization\nGraph Laplacian (path graph)\nQuantum mechanics (tight-binding model)\n\nGeneralizations:\n\nNon-symmetric: Different super/sub-diagonals (no closed form in general)\nPeriodic: Adds corner elements (circulant tridiagonal)\nNon-Toeplitz: Variable diagonals (generally no closed form)\n\nWhy it scales to any n: The eigenvector basis is KNOWN and independent of matrix size. We don't need to solve polynomial—we directly compute eigenvalues from formula.\n\n","category":"section"},{"location":"pattern_library/#Special-55-Tridiagonal-Patterns","page":"Pattern Library","title":"Special 5×5 Tridiagonal Patterns","text":"Structure: Tridiagonal 5 times 5 with one \"perturbation\" from constant pattern\n\nTwo specific patterns have been discovered with closed-form eigenvalues.","category":"section"},{"location":"pattern_library/#Pattern-1:-[b,-d,-b,-b]","page":"Pattern Library","title":"Pattern 1: [b, d, b, b]","text":"Matrix Form:\n\nmathbfM = beginbmatrix\na  b  0  0  0 \nb  a  d  0  0 \n0  d  a  b  0 \n0  0  b  a  b \n0  0  0  b  a\nendbmatrix\n\nOff-diagonal sequence: b d b b\n\nEigenvalues (closed-form):\n\nlefta + sqrt2b^2 + d^2  a - sqrt2b^2 + d^2  a + b  a - b  aright\n\nExample:\n\n@variables a b d\nM = [a b 0 0 0; b a d 0 0; 0 d a b 0; 0 0 b a b; 0 0 0 b a]\n\neigvals(M)  # {a ± √(2b² + d²), a ± b, a}","category":"section"},{"location":"pattern_library/#Pattern-2:-[b,-b,-d,-b]","page":"Pattern Library","title":"Pattern 2: [b, b, d, b]","text":"Matrix Form:\n\nmathbfM = beginbmatrix\na  b  0  0  0 \nb  a  b  0  0 \n0  b  a  d  0 \n0  0  d  a  b \n0  0  0  b  a\nendbmatrix\n\nOff-diagonal sequence: b b d b\n\nEigenvalues (closed-form - SAME as Pattern 1!):\n\nlefta + sqrt2b^2 + d^2  a - sqrt2b^2 + d^2  a + b  a - b  aright\n\nExample:\n\n@variables a b d\nM = [a b 0 0 0; b a b 0 0; 0 b a d 0; 0 0 d a b; 0 0 0 b a]\n\neigvals(M)  # {a ± √(2b² + d²), a ± b, a}  (identical to Pattern 1!)\n\nRemarkable discovery: Despite different positions of perturbation d, both patterns yield IDENTICAL eigenvalues!\n\nWhy this works: Unknown! This is an empirical discovery. The mathematical explanation likely involves:\n\nHidden symmetry in characteristic polynomial\nIsospectrality (different matrices, same spectrum)\nPossibly related to Chebyshev polynomial structure\n\nWhat doesn't work (patterns without closed form):\n\nd b b b: Boundary perturbation at position 0\nb b b d: Boundary perturbation at position 3\nd d b b, b d d b: Multiple perturbations\nc d e f: General perturbations\n\nKey insight from research: Interior perturbations (positions 1-2) admit closed forms, but boundary perturbations (positions 0, 3) break the pattern.\n\nDetection algorithm:\n\nCheck 5 times 5 tridiagonal structure\nExtract super-diagonal sequence\nMatch against known patterns bdbb or bbdb\nVerify constant diagonal = a\nApply closed-form formula\n\nApplications:\n\nPerturbed vibrating strings\nDefects in 1D lattice models\nSpecific quantum systems\n\nResearch opportunity: \n\nWhy do these specific patterns work?\nAre there similar 7 times 7 or 9 times 9 patterns?\nCan we characterize all solvable perturbation patterns?\n\nSee notes/PATTERN_DISCOVERIES.md for more details on discovery methodology.\n\n","category":"section"},{"location":"pattern_library/#Permutation-Patterns","page":"Pattern Library","title":"Permutation Patterns","text":"","category":"section"},{"location":"pattern_library/#Permutation-Matrices","page":"Pattern Library","title":"Permutation Matrices","text":"Structure: Exactly one 1 in each row and column, rest zeros\n\nMatrix Form (example: permutation 1 to 2, 2 to 3, 3 to 1):\n\nmathbfP = beginbmatrix\n0  1  0 \n0  0  1 \n1  0  0\nendbmatrix\n\nEigenvalues (closed-form for any permutation):\n\nEach k-cycle contributes k-th roots of unity: 1 omega omega^2 ldots omega^k-1 where omega = exp(2pi ik)\nAll eigenvalues have magnitude 1 (on unit circle)\n\nComplexity: O(n) to compute cycle decomposition and roots\n\nExample (6 times 6 with 3-cycle, 2-cycle, fixed point):\n\n# Permutation: (1→2→3→1), (4↔5), (6)\nP = [0 1 0 0 0 0;   # 1→2\n     0 0 1 0 0 0;   # 2→3\n     1 0 0 0 0 0;   # 3→1\n     0 0 0 0 1 0;   # 4→5\n     0 0 0 1 0 0;   # 5→4\n     0 0 0 0 0 1]   # 6→6\n\neigvals(P)\n# 3-cycle contributes: {1, ω, ω²} where ω = exp(2πi/3)\n# 2-cycle contributes: {1, -1}\n# Fixed point contributes: {1}\n# Total: {1, 1, 1, -1, ω, ω²}\n\nWhy this works: \n\nPermutation matrices have finite order: mathbfP^k = mathbfI for some k\nIf mathbfP^kmathbfv = mathbfv, then mathbfP has eigenvalues that are k-th roots of unity\nCycle decomposition determines which roots appear\n\nMathematical foundation:\n\nCayley's theorem: Every permutation decomposes into disjoint cycles\nRoot of unity property: If mathbfP^k = mathbfI, then lambda^k = 1, so lambda is a k-th root of unity\nCycle length = root order: k-cycle gives k-th roots of unity\n\nCycle decomposition algorithm:\n\nFind permutation: which column has 1 in each row\nFollow cycle: start at 1, go to P(1), then P(P(1)), until back to 1\nRepeat for unvisited elements\nCount cycle lengths\n\nEigenvalue computation: For each k-cycle, add k eigenvalues exp(2pi ijk)  j = 0 ldots k-1\n\nApplications:\n\nSorting algorithms (permutation analysis)\nGroup theory (symmetric group representations)\nGraph automorphisms\nCoding theory (permutation codes)\nFourier analysis on symmetric group\n\nMathematical properties:\n\nAlways orthogonal: mathbfP^daggermathbfP = mathbfI\nEigenvalues on unit circle: lambda = 1\nDiagonalizable (orthogonally)\nDeterminant = pm 1 (sign of permutation)\n\nSpecial cases:\n\nIdentity: One n-cycle → eigenvalue 1 with multiplicity n\nFull cycle: One n-cycle → all n-th roots of unity exp(2pi ikn)  k=0ldots n-1\nTransposition: (2-cycle) → eigenvalues 1 -1\nFixed points: Contribute eigenvalue 1\n\nDetection algorithm:\n\nCheck if matrix has exactly one 1 per row and column\nAll other entries must be 0\nExtract permutation mapping\nCompute cycle decomposition\nGenerate roots of unity for each cycle\n\n","category":"section"},{"location":"pattern_library/#Summary-Table","page":"Pattern Library","title":"Summary Table","text":"Pattern Size Limit Complexity Key Property\nDiagonal Any n O(n) Direct reading\nTriangular Any n O(n) Diagonal entries\nJordan Block Any n O(1) Single eigenvalue\nBlock-Diagonal Any n sum O(n_i) Union of blocks\nPersymmetric Any n O(n2) Half-size split\nCirculant Any n O(n) DFT formula\nBlock Circulant Any n (k leq 4) O(n cdot k) Block DFT\nKronecker mathbfAotimesmathbfB Any mn (leq 4) O(m+n) Product rule\nToeplitz Tridiag Any n O(n) Cosine formula\nAnti-Diagonal Any n O(n) pm pairs\nPermutation Any n O(n) Roots of unity\nSpecial 5 times 5 [b,d,b,b] 5 times 5 only O(1) Empirical\nSpecial 5 times 5 [b,b,d,b] 5 times 5 only O(1) Empirical\n\n","category":"section"},{"location":"pattern_library/#Pattern-Discovery-Resources","page":"Pattern Library","title":"Pattern Discovery Resources","text":"Additional resources available in the repository:\n\nPATTERN_DISCOVERIES.md (notes/PATTERN_DISCOVERIES.md) - Detailed discovery notes and mathematical justifications\nDISCOVERY_METHODOLOGY.md (notes/DISCOVERY_METHODOLOGY.md) - How to discover new patterns\nRESEARCH_SUMMARY.md (notes/RESEARCH_SUMMARY.md) - Summary of research findings\nexplore_patterns.jl (examples/explore_patterns.jl) - Interactive pattern exploration tools\n\n","category":"section"},{"location":"pattern_library/#Contributing-New-Patterns","page":"Pattern Library","title":"Contributing New Patterns","text":"If you discover a new pattern, please:\n\nVerify numerically (at least 3 test cases)\nVerify symbolically (check characteristic polynomial)\nExplain WHY it works (mathematical justification)\nImplement detector and solver\nAdd comprehensive tests\nDocument in this file\n\nSee Contributing Guide for details.","category":"section"},{"location":"#SymbolicDiagonalization.jl","page":"Home","title":"SymbolicDiagonalization.jl","text":"(Image: Logo)\n\nStatus: Functional Prototype\n\nSymbolicDiagonalization.jl provides symbolic matrix diagonalization for Julia using Symbolics.jl with closed-form root solvers and structure detection.","category":"section"},{"location":"#Vision","page":"Home","title":"Vision","text":"The Abel-Ruffini theorem limits closed-form solutions to polynomials of degree leq 4, meaning general 5 times 5+ matrices cannot be solved symbolically. However, many real-world matrices have exploitable structure.\n\nGoal: Build automatic structure detection to solve larger symbolic problems by recognizing and exploiting special patterns (block-diagonal, persymmetric, tridiagonal, circulant, Kronecker products, etc.).\n\nCurrent state: Functional prototype with 9 special pattern solvers working for any size n. Comprehensive test coverage (172 tests, all passing). Ready for experimental use.","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using SymbolicDiagonalization\nusing LinearAlgebra\nusing Symbolics\n\n@variables a b c\nmat = [a 1 0; 0 b 1; 0 0 c]\n\nE = eigen(mat)        # Eigen object with .values and .vectors\nλ = eigvals(mat)      # eigenvalues only (faster)","category":"section"},{"location":"#API-Overview","page":"Home","title":"API Overview","text":"","category":"section"},{"location":"#LinearAlgebra-Interface-(Recommended)","page":"Home","title":"LinearAlgebra Interface (Recommended)","text":"eigen(A; kwargs...) - Returns Eigen object with .values and .vectors fields\neigvals(A; kwargs...) - Returns eigenvalues only (skips eigenvector computation)","category":"section"},{"location":"#Direct-API-(Advanced)","page":"Home","title":"Direct API (Advanced)","text":"characteristic_polynomial(A; var) → (poly, coeffs, λ)\nsymbolic_eigenvalues(A; kwargs...) → (vals, poly, λ)\nsymbolic_eigenpairs(A; kwargs...) → eigenvalue-eigenvector pairs\nsymbolic_diagonalize(A; kwargs...) → (P, D, pairs) (throws if not diagonalizable)","category":"section"},{"location":"#Common-Options","page":"Home","title":"Common Options","text":"structure - Matrix type hint: :auto, :hermitian, :symmetric, :unitary\nexpand - Expand polynomial coefficients (default: true)\nsimplify - Simplify eigenvalues/eigenvectors (default: false)\ntimeout - Maximum computation time in seconds (default: 300)\nmax_terms - Expression complexity limit (default: 10000)\ncomplexity_threshold - Warn when symbolic variable count exceeds this (default: 5)\ncheck_diagonalizable - Verify eigenvectors are independent (default: true)\nvar - Custom variable for characteristic polynomial (default: auto-generated)","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"#Block-Diagonal-Matrix","page":"Home","title":"Block-Diagonal Matrix","text":"@variables a b c d λ\nmat = [a  b  0  0;\n       b  a  0  0;\n       0  0  c  d;\n       0  0  d  c]\n\nvals = eigvals(mat)\n# Result: [a+b, a-b, c+d, c-d]","category":"section"},{"location":"#Circulant-Matrix-(Any-Size)","page":"Home","title":"Circulant Matrix (Any Size)","text":"@variables a b c\nmat = [a  b  c;\n       c  a  b;\n       b  c  a]\n\nvals = eigvals(mat)\n# Uses DFT: eigenvalues are linear combinations with roots of unity","category":"section"},{"location":"#Kronecker-Product","page":"Home","title":"Kronecker Product","text":"@variables a b c d\nA = [a 0; 0 b]\nB = [c 0; 0 d]\nmat = kron(A, B)  # 4×4 matrix\n\nvals = eigvals(mat)\n# Result: [a*c, a*d, b*c, b*d] (products of eigenvalues)","category":"section"},{"location":"#Symmetric-Toeplitz-Tridiagonal","page":"Home","title":"Symmetric Toeplitz Tridiagonal","text":"@variables a b\nmat = [a  b  0;\n       b  a  b;\n       0  b  a]\n\nvals = eigvals(mat)\n# Closed-form using cosine formula: a + 2b*cos(kπ/(n+1))","category":"section"},{"location":"#Permutation-Matrix","page":"Home","title":"Permutation Matrix","text":"# 3-cycle permutation\nmat = [0  1  0;\n       0  0  1;\n       1  0  0]\n\nvals = eigvals(mat)\n# Result: roots of unity [1, ω, ω²] where ω = exp(2πi/3)","category":"section"},{"location":"#Implementation-Details","page":"Home","title":"Implementation Details","text":"","category":"section"},{"location":"#Characteristic-Polynomial","page":"Home","title":"Characteristic Polynomial","text":"Computed via fraction-free Bareiss determinant on lambda I - A\nCoefficients extracted by differentiating at lambda = 0\nWorks with symbolic rings","category":"section"},{"location":"#Closed-Form-Root-Solvers-(Degrees-1-4)","page":"Home","title":"Closed-Form Root Solvers (Degrees 1-4)","text":"Linear, quadratic, cubic (Cardano), quartic (Ferrari)\nQuartic produces very large expressions for fully symbolic matrices\nDegrees geq 5 require structure detection or throw error","category":"section"},{"location":"#Structure-Detection-(13-Patterns-Implemented)","page":"Home","title":"Structure Detection (13 Patterns Implemented)","text":"Successfully implemented patterns:\n\nDiagonal - Trivial O(n) eigenvalue extraction\nTriangular - Diagonal elements are eigenvalues\nBlock-Diagonal - Recursive detection and solving (works with any block sizes)\nPersymmetric - Qij = Qn+1-jn+1-i, splits into half-sized eigenproblems\nCirculant - Uses DFT, works for any size n\nBlock Circulant - Block-level DFT approach\nSymmetric Toeplitz Tridiagonal - Closed-form cosine formula for any n\nAnti-Diagonal - Eigenvalues come in pm pairs\nPermutation Matrices - Eigenvalues are roots of unity\nKronecker Products - Eigenvalues are products of factor eigenvalues\nSpecial 5 times 5 pattern [b,d,b,b] - Known closed-form solution\nSpecial 5 times 5 pattern [b,b,d,b] - Known closed-form solution\nJordan Blocks - Repeated eigenvalue with known structure\n\nDetection robustness: Currently basic pattern matching. Room for improvement with more sophisticated algorithms and tolerance handling for near-patterns.","category":"section"},{"location":"#Eigenvector-Computation","page":"Home","title":"Eigenvector Computation","text":"Nullspace via RREF-based row reduction\nsymbolic_diagonalize verifies eigenvector independence\nError handling for non-diagonalizable matrices","category":"section"},{"location":"#Current-Capabilities-and-Limitations","page":"Home","title":"Current Capabilities and Limitations","text":"","category":"section"},{"location":"#What-Works-Well","page":"Home","title":"What Works Well","text":"Small matrices (leq 4 times 4): Full symbolic diagonalization using closed-form root solvers\nStructured matrices (any size): 13 special patterns with efficient O(n) to O(n^2) algorithms\nMixed symbolic/numeric: Handles partially symbolic matrices effectively\nComprehensive testing: 172 passing tests (37.4s) covering diverse scenarios","category":"section"},{"location":"#Known-Limitations","page":"Home","title":"Known Limitations","text":"General 5 times 5+ matrices: No closed-form solver (Abel-Ruffini theorem) - requires structure detection\nExpression complexity: Fully symbolic 4 times 4 quartic eigenvalues can be very large (~13.5 MB)\nSimplification: Basic simplification only; results may not be in minimal form\nPattern detection robustness: Exact pattern matching; may miss near-patterns or numerically perturbed structures","category":"section"},{"location":"#Development-Priorities","page":"Home","title":"Development Priorities","text":"","category":"section"},{"location":"#High-Priority","page":"Home","title":"High Priority","text":"Enhanced structure detection: More robust algorithms with tolerance handling for near-patterns\nAdditional patterns: Arrow matrices, general Hankel, more tridiagonal families\nExpression simplification: Deeper integration with Symbolics.jl simplification\nPerformance optimization: Caching, memoization for repeated subproblems","category":"section"},{"location":"#Medium-Priority","page":"Home","title":"Medium Priority","text":"Eigenvalue multiplicity: Better handling of repeated eigenvalues and generalized eigenvectors\nNumerical fallback: Automatic hybrid symbolic-numeric mode for borderline cases\nDocumentation: More examples, tutorials, pattern discovery guides\nSymbolic conditioning: Analyze stability and condition numbers symbolically","category":"section"},{"location":"#Long-Term-Vision","page":"Home","title":"Long-Term Vision","text":"Machine learning: Pattern recognition using trained models\nUser pattern libraries: Custom pattern registration and sharing\nSymbolic perturbation: First-order eigenvalue sensitivity analysis\nParallel processing: Multi-threaded block decomposition","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"#User-Guides","page":"Home","title":"User Guides","text":"User Guide - Installation, basic usage, workflow examples\nAPI Reference - Complete function signatures and keyword arguments\nPattern Library - All 13 implemented patterns with examples and complexity analysis","category":"section"},{"location":"#Developer-Resources","page":"Home","title":"Developer Resources","text":"Implementation Details - Algorithm descriptions, complexity analysis, performance considerations\nMathematical Background - Theory behind root solvers and pattern-specific algorithms\nContributing Guide - Development setup, testing, adding new patterns","category":"section"},{"location":"#Pattern-Discovery","page":"Home","title":"Pattern Discovery","text":"Additional resources for pattern research and exploration:\n\nResearch Summary (notes/RESEARCH_SUMMARY.md) - Pattern discovery overview\nDiscovery Methodology (notes/DISCOVERY_METHODOLOGY.md) - Pattern exploration techniques\nPattern Discoveries (notes/PATTERN_DISCOVERIES.md) - Detailed catalog of investigated patterns\nExplore Patterns Script (examples/explore_patterns.jl) - Interactive pattern exploration tool","category":"section"},{"location":"#Building-the-Documentation","page":"Home","title":"Building the Documentation","text":"From the project root:\n\njulia --project=docs docs/make.jl\n\nThis renders the documentation locally using Documenter.jl.","category":"section"},{"location":"#Viewing-the-Documentation","page":"Home","title":"Viewing the Documentation","text":"The documentation is built as static HTML in docs/build/. To view it properly with working navigation links, use a local web server:\n\n# Option 1: Use the provided script\ncd docs\n./serve.sh\n\n# Option 2: Use Python's built-in HTTP server\ncd docs/build\npython3 -m http.server 8000\n\n# Option 3: Use Julia's HTTP server\ncd docs/build\njulia -e 'using HTTP; HTTP.serve(HTTP.Files(\".\"))'\n\nThen open your browser to http://localhost:8000\n\nNote: Opening index.html directly with file:// may cause navigation links to not work properly in some browsers due to security restrictions.","category":"section"},{"location":"implementation/#Implementation-Details","page":"Implementation Details","title":"Implementation Details","text":"This document provides technical details about the algorithms and implementation strategies used in SymbolicDiagonalization.jl.","category":"section"},{"location":"implementation/#Table-of-Contents","page":"Implementation Details","title":"Table of Contents","text":"Overview\nCharacteristic Polynomial Computation\nRoot Solvers (Degrees 1-4)\nStructure Detection\nSpecial Pattern Solvers\nEigenvector Computation\nExpression Management\nPerformance Considerations\n\n","category":"section"},{"location":"implementation/#Overview","page":"Implementation Details","title":"Overview","text":"SymbolicDiagonalization.jl uses a multi-layered approach to compute eigenvalues and eigenvectors:\n\nStructure Detection: Identify exploitable matrix patterns\nPattern-Specific Solvers: Use specialized algorithms for detected patterns\nCharacteristic Polynomial: Compute det(lambda I - A) using Bareiss algorithm\nRoot Finding: Solve polynomials up to degree 4 using closed-form formulas\nEigenvector Computation: Use RREF-based nullspace or adjugate method\n\nThe implementation prioritizes symbolic correctness over numeric efficiency, using fraction-free algorithms and avoiding floating-point operations wherever possible.\n\n","category":"section"},{"location":"implementation/#Characteristic-Polynomial-Computation","page":"Implementation Details","title":"Characteristic Polynomial Computation","text":"","category":"section"},{"location":"implementation/#Algorithm:-Bareiss-Determinant","page":"Implementation Details","title":"Algorithm: Bareiss Determinant","text":"The characteristic polynomial det(lambda I - A) is computed using the Bareiss algorithm, a fraction-free variant of Gaussian elimination.\n\nFile: src/charpoly.jl","category":"section"},{"location":"implementation/#Why-Bareiss?","page":"Implementation Details","title":"Why Bareiss?","text":"Standard Gaussian elimination requires division, which causes intermediate expression blowup in symbolic computation:\n\nStandard GE: Expressions grow like O(2^n) due to nested divisions\nBareiss: Keeps expressions polynomial-sized by avoiding division until the end","category":"section"},{"location":"implementation/#Algorithm-Description","page":"Implementation Details","title":"Algorithm Description","text":"Given matrix M, Bareiss computes det(M) without fractions:\n\nfunction _bareiss_det(M)\n    n = size(M, 1)\n    A = Matrix{eltype(M)}(M)\n    prev = one(eltype(M))\n    \n    for k in 1:n-1\n        pivot = A[k, k]\n        _issymzero(pivot) && error(\"zero pivot encountered\")\n        \n        # Update submatrix using division-free formula\n        for i in k+1:n, j in k+1:n\n            A[i, j] = (A[i, j] * pivot - A[i, k] * A[k, j]) / prev\n        end\n        \n        # Zero out column below pivot\n        fill!(view(A, k+1:n, k), zero(eltype(M)))\n        prev = pivot\n    end\n    \n    return A[n, n]\nend\n\nKey insight: The formula (A[i,j] * pivot - A[i,k] * A[k,j]) / prev is always divisible by prev (the previous pivot), so no fractions appear.","category":"section"},{"location":"implementation/#Complexity","page":"Implementation Details","title":"Complexity","text":"Time: O(n^3) symbolic operations\nExpression size: Polynomial growth (much better than standard methods)\nSpace: O(n^2) for the matrix","category":"section"},{"location":"implementation/#Coefficient-Extraction","page":"Implementation Details","title":"Coefficient Extraction","text":"Instead of polynomial division (which is brittle for symbolic expressions), we use derivative-based extraction:\n\nfunction _collect_coefficients(poly, λ, degree)\n    coeffs = Vector{Any}(undef, degree + 1)\n    coeffs[1] = substitute(poly, λ => 0)  # Constant term\n    \n    deriv = poly\n    fact = 1\n    for k in 1:degree\n        deriv = derivative(deriv, λ)\n        fact *= k\n        coeffs[k + 1] = substitute(deriv, λ => 0) / fact\n    end\n    \n    return coeffs\nend\n\nThis uses the Taylor series expansion: p(lambda) = sum_k fracp^(k)(0)k lambda^k\n\n","category":"section"},{"location":"implementation/#Root-Solvers-(Degrees-1-4)","page":"Implementation Details","title":"Root Solvers (Degrees 1-4)","text":"","category":"section"},{"location":"implementation/#Overview-2","page":"Implementation Details","title":"Overview","text":"SymbolicDiagonalization.jl implements closed-form root solvers for polynomials up to degree 4:\n\nDegree Method Formula Name\n1 Linear Direct\n2 Quadratic Quadratic formula\n3 Cubic Cardano's method\n4 Quartic Ferrari's method\n\nFile: src/roots.jl","category":"section"},{"location":"implementation/#Linear-Solver-(Degree-1)","page":"Implementation Details","title":"Linear Solver (Degree 1)","text":"For ax + b = 0:\n\n_roots_linear(c) = [-c[1] / c[2]]  # c = [b, a]\n\nComplexity: O(1) symbolic operations","category":"section"},{"location":"implementation/#Quadratic-Solver-(Degree-2)","page":"Implementation Details","title":"Quadratic Solver (Degree 2)","text":"For ax^2 + bx + c = 0:\n\nfunction _roots_quadratic(c)\n    a, b, d = c[3], c[2], c[1]  # d is constant term\n    disc = b^2 - 4a*d\n    disc = _aggressive_simplify(disc)\n    sqrt_disc = sqrt(disc)\n    return [(-b - sqrt_disc) / (2a), (-b + sqrt_disc) / (2a)]\nend\n\nKey features:\n\nDiscriminant simplification to reduce expression size\nSymbolic square root handling\n\nComplexity: O(n^2) where n is the expression size","category":"section"},{"location":"implementation/#Cubic-Solver-(Degree-3)","page":"Implementation Details","title":"Cubic Solver (Degree 3)","text":"For ax^3 + bx^2 + cx + d = 0, we use Cardano's method:\n\nStep 1: Depress the cubic (eliminate x^2 term)\n\nSubstitution x = y - fracb3a transforms to: y^3 + py + q = 0\n\nwhere:\n\np = fracca - fracb^23a^2\nq = frac2b^327a^3 - fracbc3a^2 + fracda\n\nStep 2: Compute discriminant\n\nDelta = left(fracq2right)^2 + left(fracp3right)^3\n\nStep 3: Compute cube roots\n\nC = cbrt(-q/2 + √Δ)\nD = cbrt(-q/2 - √Δ)\n\nStep 4: Construct roots\n\nLet omega = e^2pi i3 = -frac12 + fracsqrt32i be a primitive cube root of unity.\n\nroots = [\n    C + D,\n    ω*C + ω²*D,\n    ω²*C + ω*D\n]\n\nStep 5: Shift back\n\nx = y - fracb3a\n\nComplexity: O(n^3) where n is the expression size\n\nImplementation notes:\n\nAggressive simplification applied to p, q, and Delta\nComplex arithmetic handled symbolically\nNumeric cube roots used with symbolic coefficients","category":"section"},{"location":"implementation/#Quartic-Solver-(Degree-4)","page":"Implementation Details","title":"Quartic Solver (Degree 4)","text":"For ax^4 + bx^3 + cx^2 + dx + e = 0, we use Ferrari's method via a resolvent cubic.\n\nStep 1: Depress the quartic (eliminate x^3 term)\n\nSubstitution x = y - fracb4a transforms to: y^4 + py^2 + qy + r = 0\n\nwhere:\n\np = fracca - frac3b^28a^2\nq = fracda + fracb^38a^3 - fracbc2a^2\nr = fracea - frac3b^4256a^4 + fracb^2c16a^3 - fracbd4a^2\n\nStep 2: Solve resolvent cubic\n\nThe resolvent cubic is: 8z^3 - 4pz^2 - 8rz + (4pr - q^2) = 0\n\nLet alpha be any root of this cubic (we use the first one).\n\nStep 3: Decompose into two quadratics\n\nThe depressed quartic factors as:\n\n(y^2 + beta y + (alpha + gamma))(y^2 - beta y + (alpha - gamma)) = 0\n\nwhere:\n\nbeta^2 = 2alpha - p\ngamma = -fracq2beta\n\nStep 4: Solve quadratics\n\nEach quadratic gives two roots using the quadratic formula.\n\nStep 5: Shift back\n\nx = y - fracb4a\n\nComplexity: O(n^4) where n is the expression size\n\nImplementation details:\n\nfunction _roots_quartic(c)\n    # Normalize and extract coefficients\n    a, b, cc, d, e = c[5], c[4], c[3], c[2], c[1]\n    \n    # Depress to y⁴ + py² + qy + r = 0\n    p = cc/a - 3b²/(8a²)\n    q = d/a + b³/(8a³) - b*cc/(2a²)\n    r = e/a - 3b⁴/(256a⁴) + b²*cc/(16a³) - b*d/(4a²)\n    \n    # Simplify intermediate expressions\n    p = _aggressive_simplify(p)\n    q = _aggressive_simplify(q)\n    r = _aggressive_simplify(r)\n    \n    # Resolvent cubic coefficients\n    resolvent = [4p*r - q², -8r, -4p, 8]\n    alphas = _roots_cubic(resolvent)\n    alpha = alphas[1]  # Choose first root\n    \n    # Compute β and γ\n    beta_sq = 2alpha - p\n    beta_sq = _aggressive_simplify(beta_sq)\n    beta = _symbolic_sqrt(beta_sq)\n    gamma = -q/(2beta)\n    gamma = _aggressive_simplify(gamma)\n    \n    # Two quadratics: y² ± β*y + (α ± γ)\n    t1 = beta² - 4(alpha + gamma)\n    t2 = beta² - 4(alpha - gamma)\n    t1 = _aggressive_simplify(t1)\n    t2 = _aggressive_simplify(t2)\n    \n    # Solve both quadratics\n    roots_y = [\n        (-beta - _symbolic_sqrt(t1)) / 2,\n        (-beta + _symbolic_sqrt(t1)) / 2,\n        (beta - _symbolic_sqrt(t2)) / 2,\n        (beta + _symbolic_sqrt(t2)) / 2\n    ]\n    \n    # Shift back\n    return roots_y .- b/(4a)\nend\n\nWarning: Quartic formulas produce extremely large expressions for fully symbolic 4 times 4 matrices (~13.5 MB per eigenvalue).\n\n","category":"section"},{"location":"implementation/#Structure-Detection","page":"Implementation Details","title":"Structure Detection","text":"","category":"section"},{"location":"implementation/#Overview-3","page":"Implementation Details","title":"Overview","text":"Before attempting expensive polynomial root finding, we try to detect exploitable matrix structure.\n\nFile: src/diagonalize.jl (functions starting with _is_* and _detect_*)","category":"section"},{"location":"implementation/#Detection-Hierarchy","page":"Implementation Details","title":"Detection Hierarchy","text":"Structure Detection\n├── Diagonal (_is_diagonal)\n├── Triangular (_is_triangular)\n├── Block-Diagonal (_detect_multiple_blocks)\n├── Persymmetric (_is_persymmetric)\n├── Circulant (_is_circulant)\n├── Block Circulant (_is_block_circulant)\n├── Toeplitz Tridiagonal (_is_toeplitz_tridiagonal)\n├── Anti-Diagonal (_is_antidiagonal)\n├── Permutation (_is_permutation_matrix)\n├── Kronecker Product (_is_kronecker_product)\n└── Special 5×5 (_detect_special_5x5_tridiagonal)","category":"section"},{"location":"implementation/#Implementation-Details-2","page":"Implementation Details","title":"Implementation Details","text":"","category":"section"},{"location":"implementation/#Symbolic-Zero-Detection","page":"Implementation Details","title":"Symbolic Zero Detection","text":"All structure detection relies on checking if expressions are zero:\n\nfunction _issymzero(x)\n    # Try standard iszero\n    try\n        v = Base.iszero(x)\n        if v isa Bool\n            return v\n        end\n    catch\n    end\n    \n    # Try simplify then check\n    try\n        sx = Symbolics.simplify(x)\n        v = Symbolics.iszero(sx)\n        return v === true\n    catch\n    end\n    \n    # Try direct Symbolics.iszero\n    try\n        v = Symbolics.iszero(x)\n        return v === true\n    catch\n    end\n    \n    # Conservative: not proven zero\n    return false\nend\n\nKey insight: We return false if we can't prove it's zero (conservative approach).","category":"section"},{"location":"implementation/#Diagonal-Detection","page":"Implementation Details","title":"Diagonal Detection","text":"function _is_diagonal(mat)\n    m, n = size(mat)\n    for i in 1:m, j in 1:n\n        i == j && continue\n        !_issymzero(mat[i, j]) && return false\n    end\n    return true\nend\n\nComplexity: O(n^2) symbolic zero checks","category":"section"},{"location":"implementation/#Block-Diagonal-Detection","page":"Implementation Details","title":"Block-Diagonal Detection","text":"Finds all block-diagonal structure using a greedy algorithm:\n\nfunction _detect_multiple_blocks(mat)\n    n = size(mat, 1)\n    blocks = Tuple{Int,Int}[]\n    current_start = 1\n    \n    while current_start <= n\n        # Find smallest block starting at current_start\n        block_end = n  # Default: extend to end\n        \n        for k in current_start:(n-1)\n            # Check if [current_start:k, k+1:n] and [k+1:n, current_start:k] are zero\n            upper_right_zero = all(_issymzero, mat[i, j] \n                for i in current_start:k, j in (k+1):n)\n            lower_left_zero = all(_issymzero, mat[i, j] \n                for i in (k+1):n, j in current_start:k)\n            \n            if upper_right_zero && lower_left_zero\n                block_end = k\n                break\n            end\n        end\n        \n        push!(blocks, (current_start, block_end))\n        current_start = block_end + 1\n    end\n    \n    # Only return if we found actual blocks (more than just the whole matrix)\n    return length(blocks) > 1 ? blocks : nothing\nend\n\nComplexity: O(n^4) symbolic operations in worst case","category":"section"},{"location":"implementation/#Circulant-Detection","page":"Implementation Details","title":"Circulant Detection","text":"function _is_circulant(mat)\n    n = size(mat, 1)\n    first_row = mat[1, :]\n    \n    # Check each row is a cyclic shift of the first row\n    for i in 2:n\n        for j in 1:n\n            expected_idx = mod1(j - (i - 1), n)\n            if !_issymzero(mat[i, j] - first_row[expected_idx])\n                return false\n            end\n        end\n    end\n    \n    return true\nend\n\nComplexity: O(n^2) symbolic zero checks","category":"section"},{"location":"implementation/#Block-Circulant-Detection","page":"Implementation Details","title":"Block Circulant Detection","text":"Tries different block sizes k where n is divisible by k:\n\nfunction _is_block_circulant(mat)\n    m, n = size(mat)\n    m == n || return nothing\n    \n    # Try different block sizes\n    for k in 2:div(m, 2)\n        m % k == 0 || continue\n        n_blocks = div(m, k)\n        \n        # Extract blocks from first block row\n        blocks = [mat[1:k, (i-1)*k+1:i*k] for i in 1:n_blocks]\n        \n        # Check if each block row is a cyclic shift\n        is_block_circulant = true\n        for block_row in 2:n_blocks\n            for block_col in 1:n_blocks\n                shift_idx = mod1(block_col - (block_row - 1), n_blocks)\n                expected_block = blocks[shift_idx]\n                actual_block = mat[(block_row-1)*k+1:block_row*k, \n                                  (block_col-1)*k+1:block_col*k]\n                \n                # Check if blocks match\n                if !all(_issymzero(actual_block[i, j] - expected_block[i, j]) \n                       for i in 1:k, j in 1:k)\n                    is_block_circulant = false\n                    break\n                end\n            end\n            is_block_circulant || break\n        end\n        \n        if is_block_circulant\n            return (n_blocks, k, blocks)\n        end\n    end\n    \n    return nothing\nend\n\nComplexity: O(n^4) in worst case (trying all block sizes)","category":"section"},{"location":"implementation/#Kronecker-Product-Detection","page":"Implementation Details","title":"Kronecker Product Detection","text":"Tries different factorizations N = m times n:\n\nfunction _is_kronecker_product(mat)\n    N = size(mat, 1)\n    \n    # Try factorizations N = m * n\n    for m in 2:div(N, 2)\n        N % m == 0 || continue\n        n = div(N, m)\n        \n        # Extract candidate B from (1,1) block\n        B_candidate = mat[1:n, 1:n]\n        \n        # Try to extract A by looking at block pattern\n        A = zeros(eltype(mat), m, m)\n        \n        for i_block in 1:m, j_block in 1:m\n            block = mat[(i_block-1)*n+1:i_block*n, (j_block-1)*n+1:j_block*n]\n            \n            # Find scalar such that block = scalar * B_candidate\n            scalar = find_scalar_multiple(block, B_candidate)\n            \n            # Verify block = scalar * B_candidate\n            if verify_match(block, scalar, B_candidate)\n                A[i_block, j_block] = scalar\n            else\n                @goto next_factorization\n            end\n        end\n        \n        return (A, B_candidate, m, n)\n        \n        @label next_factorization\n    end\n    \n    return nothing\nend\n\nComplexity: O(n^5) in worst case","category":"section"},{"location":"implementation/#Permutation-Matrix-Detection","page":"Implementation Details","title":"Permutation Matrix Detection","text":"function _is_permutation_matrix(A)\n    n = size(A, 1)\n    \n    # Check each row has exactly one 1 and rest zeros\n    for i in 1:n\n        count_ones = sum(_issymzero(A[i, j] - 1) for j in 1:n)\n        count_ones == 1 || return false\n        \n        # Check rest are zeros\n        for j in 1:n\n            !_issymzero(A[i, j] - 1) && !_issymzero(A[i, j]) && return false\n        end\n    end\n    \n    # Check each column has exactly one 1\n    for j in 1:n\n        count_ones = sum(_issymzero(A[i, j] - 1) for i in 1:n)\n        count_ones == 1 || return false\n    end\n    \n    return true\nend\n\nComplexity: O(n^2) symbolic zero checks\n\n","category":"section"},{"location":"implementation/#Special-Pattern-Solvers","page":"Implementation Details","title":"Special Pattern Solvers","text":"","category":"section"},{"location":"implementation/#Circulant-Matrices","page":"Implementation Details","title":"Circulant Matrices","text":"Theory: A circulant matrix has eigenvalues given by the DFT of its first row.\n\nFor circulant matrix C = textcirc(c_0 c_1 ldots c_n-1):\n\nlambda_j = sum_k c_k omega^jk\n\nfor j = 0 1 ldots n-1\n\nwhere omega = e^2pi in.\n\nfunction _circulant_eigenvalues(mat)\n    n = size(mat, 1)\n    first_row = mat[1, :]\n    eigenvalues = Vector{Any}(undef, n)\n    \n    for j in 0:(n-1)\n        λ = first_row[1]  # c₀ term\n        \n        for k in 1:(n-1)\n            θ = 2π * j * k / n\n            ω_power = cos(θ) + im * sin(θ)\n            λ += first_row[k+1] * ω_power\n        end\n        \n        eigenvalues[j+1] = Symbolics.simplify(λ)\n    end\n    \n    return eigenvalues\nend\n\nComplexity: O(n^2) symbolic operations (much better than O(n^3) for general case)","category":"section"},{"location":"implementation/#Block-Circulant-Matrices","page":"Implementation Details","title":"Block Circulant Matrices","text":"Theory: Block circulant reduces to n separate k times k eigenvalue problems.\n\nFor block circulant with blocks A_0 A_1 ldots A_n-1:\n\nEigenvalues = bigcup_j texteigvals(D_j)\n\nwhere D_j = sum_k omega^jk A_k and omega = e^2pi in.\n\nfunction _block_circulant_eigenvalues(mat, n_blocks, block_size, blocks)\n    all_eigenvalues = []\n    \n    for j in 0:(n_blocks-1)\n        # Compute Dⱼ = Σₖ ωʲᵏ Aₖ\n        D_j = zeros(eltype(mat), block_size, block_size)\n        \n        for k in 0:(n_blocks-1)\n            θ = 2π * j * k / n_blocks\n            ω_power = cos(θ) + im * sin(θ)\n            D_j .+= ω_power .* blocks[k + 1]\n        end\n        \n        # Recursively solve k×k eigenvalue problem\n        D_j = Symbolics.simplify.(D_j)\n        vals_j, _, _ = symbolic_eigenvalues(D_j)\n        append!(all_eigenvalues, vals_j)\n    end\n    \n    return all_eigenvalues\nend\n\nComplexity: O(n times T(k)) where T(k) is time to solve k times k matrix","category":"section"},{"location":"implementation/#Toeplitz-Tridiagonal-Matrices","page":"Implementation Details","title":"Toeplitz Tridiagonal Matrices","text":"Theory: Symmetric Toeplitz tridiagonal has closed-form eigenvalues via orthogonal polynomials.\n\nFor matrix with diagonal a and off-diagonals b:\n\nlambda_k = a + 2b cosleft(frackpin+1right)\n\nfor k = 1 2 ldots n\n\nfunction _toeplitz_tridiagonal_eigenvalues(n, a, b, c)\n    eigenvalues = Vector{Any}(undef, n)\n    \n    for k in 1:n\n        θ = k * π / (n + 1)\n        λₖ = a + 2 * b * cos(θ)\n        eigenvalues[k] = Symbolics.simplify(λₖ)\n    end\n    \n    return eigenvalues\nend\n\nComplexity: O(n) symbolic operations (optimal!)","category":"section"},{"location":"implementation/#Kronecker-Products","page":"Implementation Details","title":"Kronecker Products","text":"Theory: If A has eigenvalues lambda_i and B has eigenvalues mu_j, then A otimes B has eigenvalues lambda_i mu_j.\n\nfunction _kronecker_eigenvalues(A, B, m, n)\n    # Compute eigenvalues of A\n    λ_A, _, _ = symbolic_eigenvalues(A)\n    \n    # Compute eigenvalues of B\n    λ_B, _, _ = symbolic_eigenvalues(B)\n    \n    # Compute all products λᵢ * μⱼ\n    eigenvalues = []\n    for λ in λ_A, μ in λ_B\n        push!(eigenvalues, λ * μ)\n    end\n    \n    return eigenvalues\nend\n\nComplexity: O(T(m) + T(n) + mn) where T(k) is time to solve k times k matrix","category":"section"},{"location":"implementation/#Permutation-Matrices","page":"Implementation Details","title":"Permutation Matrices","text":"Theory: Eigenvalues are roots of unity determined by cycle structure.\n\nFor a cycle of length k: eigenvalues are e^2pi ijk for j = 0 1 ldots k-1\n\nfunction _compute_permutation_eigenvalues(A)\n    cycles = _permutation_to_cycles(A)\n    eigenvalues = []\n    \n    for cycle_length in cycles\n        if cycle_length == 1\n            push!(eigenvalues, 1)  # Fixed point\n        elseif cycle_length == 2\n            push!(eigenvalues, 1, -1)  # Transposition\n        else\n            # k-th roots of unity\n            for j in 0:(cycle_length - 1)\n                angle = 2π * j / cycle_length\n                push!(eigenvalues, exp(im * angle))\n            end\n        end\n    end\n    \n    return eigenvalues\nend\n\nComplexity: O(n) to find cycles, O(n) to generate eigenvalues","category":"section"},{"location":"implementation/#Anti-Diagonal-Matrices","page":"Implementation Details","title":"Anti-Diagonal Matrices","text":"Theory: Symmetric anti-diagonal has eigenvalues in pm pairs.\n\nFor anti-diagonal entries a_1 a_2 ldots a_n:\n\nOdd n: eigenvalues are a_textmid pm a_1 pm a_2 ldots pm a_textmid-1\nEven n: eigenvalues are pm a_1 pm a_2 ldots pm a_n2\n\nfunction _antidiagonal_eigenvalues(mat)\n    n = size(mat, 1)\n    antidiag = [mat[i, n + 1 - i] for i in 1:n]\n    \n    if n % 2 == 1\n        # Odd: one middle eigenvalue, rest in pairs\n        mid = (n + 1) ÷ 2\n        eigenvalues = [antidiag[mid]]\n        for i in 1:mid-1\n            push!(eigenvalues, antidiag[i], -antidiag[i])\n        end\n    else\n        # Even: all in pairs\n        eigenvalues = []\n        for i in 1:n÷2\n            push!(eigenvalues, antidiag[i], -antidiag[i])\n        end\n    end\n    \n    return eigenvalues\nend\n\nComplexity: O(n) symbolic operations","category":"section"},{"location":"implementation/#Persymmetric-Splitting","page":"Implementation Details","title":"Persymmetric Splitting","text":"Theory: Symmetric persymmetric matrices (Qij = Qn+1-j n+1-i) can be split into two half-sized blocks.\n\nfunction _persymmetric_split(mat)\n    n = size(mat, 1)\n    n % 2 != 0 && return nothing  # Only for even n\n    \n    # Build transformation matrix P = [(I+J)/√2, (I-J)/√2]\n    # where J is the exchange matrix (anti-identity)\n    \n    half = div(n, 2)\n    P = zeros(eltype(mat), n, n)\n    \n    # First half: e_i + e_{n+1-i}\n    for i in 1:half\n        P[i, i] = 1\n        P[n+1-i, i] = 1\n    end\n    \n    # Second half: e_i - e_{n+1-i}\n    for i in 1:half\n        P[i, half+i] = 1\n        P[n+1-i, half+i] = -1\n    end\n    \n    # Transform: Q_new = P^T * Q * P\n    Q_transformed = transpose(P) * mat * P\n    \n    # Extract blocks (and divide by 2 for normalization)\n    block1 = Q_transformed[1:half, 1:half] ./ 2\n    block2 = Q_transformed[half+1:end, half+1:end] ./ 2\n    \n    return (block1, block2, P)\nend\n\nComplexity: O(n^3) for matrix multiplication\n\n","category":"section"},{"location":"implementation/#Eigenvector-Computation","page":"Implementation Details","title":"Eigenvector Computation","text":"","category":"section"},{"location":"implementation/#Two-Approaches","page":"Implementation Details","title":"Two Approaches","text":"SymbolicDiagonalization.jl uses two complementary methods:\n\nAdjugate method (for small matrices, leq 3 times 3)\nRREF-based nullspace (general case)\n\nFile: src/rref.jl, src/diagonalize.jl","category":"section"},{"location":"implementation/#Adjugate-Method","page":"Implementation Details","title":"Adjugate Method","text":"For A - lambda I singular (lambda is eigenvalue), the adjugate matrix textadj(A - lambda I) has all columns in the nullspace.\n\nfunction _adjugate_vectors(M)\n    n = size(M, 1)\n    n <= 3 || return []  # Only for small matrices\n    \n    adj = _adjugate(M)\n    \n    # Return first non-zero column\n    for j in 1:n\n        col = Symbolics.simplify.(adj[:, j])\n        all(_issymzero, col) && continue\n        return [col]  # Return immediately\n    end\n    \n    return []\nend\n\nfunction _adjugate(M)\n    n = size(M, 1)\n    adj = Matrix{eltype(M)}(undef, n, n)\n    \n    for i in 1:n, j in 1:n\n        minor_det = _minor_det(M, i, j)\n        adj[j, i] = (-1)^(i + j) * minor_det\n    end\n    \n    return Symbolics.simplify.(adj)\nend\n\nAdvantages:\n\nAvoids RREF pivoting issues\nMore compact expressions for small matrices\n\nDisadvantages:\n\nOnly works for n leq 3 (determinant computation explodes)\nMay return zero vector if unlucky","category":"section"},{"location":"implementation/#RREF-Based-Nullspace","page":"Implementation Details","title":"RREF-Based Nullspace","text":"General method that works for any size:\n\nfunction _nullspace(M)\n    # Simplify entries first\n    simplified = Symbolics.simplify.(M)\n    \n    # Compute RREF\n    R, pivots = _rref(Symbolics.expand.(simplified))\n    \n    m, n = size(R)\n    free = setdiff(1:n, pivots)  # Free variables\n    \n    vectors = []\n    for f in free\n        # Set free variable to 1, solve for pivot variables\n        v = fill(zero(eltype(R)), n)\n        v[f] = one(eltype(R))\n        \n        for (row, pivot_col) in enumerate(pivots)\n            v[pivot_col] = Symbolics.simplify(-R[row, f])\n        end\n        \n        push!(vectors, Symbolics.simplify.(v))\n    end\n    \n    return vectors\nend\n\nComplexity: O(n^3) symbolic operations","category":"section"},{"location":"implementation/#RREF-Algorithm","page":"Implementation Details","title":"RREF Algorithm","text":"Row reduction to reduced row echelon form:\n\nfunction _rref(M)\n    A = copy(Matrix(M))\n    m, n = size(A)\n    pivots = Int[]\n    row = 1\n    \n    for col in 1:n\n        # Find pivot\n        pivot_row = _find_pivot(A, row, col)\n        isnothing(pivot_row) && continue\n        \n        # Swap rows\n        if pivot_row != row\n            A[row, :], A[pivot_row, :] = A[pivot_row, :], A[row, :]\n        end\n        \n        # Normalize pivot row\n        pivot = Symbolics.simplify(A[row, col])\n        A[row, :] .= Symbolics.simplify.(A[row, :] ./ pivot)\n        \n        # Eliminate column in all other rows\n        for r in 1:m\n            r == row && continue\n            factor = A[r, col]\n            _issymzero(factor) && continue\n            A[r, :] .= Symbolics.simplify.(A[r, :] .- factor .* A[row, :])\n        end\n        \n        push!(pivots, col)\n        row += 1\n        row > m && break\n    end\n    \n    return A, pivots\nend\n\nKey features:\n\nSimplification after each operation to keep expressions manageable\nSymbolic pivot selection (uses _issymzero)\nFull row elimination (not just below pivot)\n\nComplexity: O(mn^2 times s) where s is average expression size\n\n","category":"section"},{"location":"implementation/#Expression-Management","page":"Implementation Details","title":"Expression Management","text":"","category":"section"},{"location":"implementation/#The-Expression-Explosion-Problem","page":"Implementation Details","title":"The Expression Explosion Problem","text":"Symbolic computation faces a fundamental challenge: expressions grow exponentially without careful management.\n\nExample: A 3 times 3 symbolic matrix can produce eigenvalues with 1000+ terms. A 4 times 4 symbolic matrix can produce eigenvalues with 10,000+ terms (~13.5 MB each!).","category":"section"},{"location":"implementation/#Strategy:-Aggressive-Simplification","page":"Implementation Details","title":"Strategy: Aggressive Simplification","text":"We apply simplification at every intermediate step of computation:\n\nfunction _aggressive_simplify(expr; max_terms = 10000)\n    !_is_symbolic_coeff(expr) && return expr\n    \n    # Expand first to collect all terms\n    expanded = Symbolics.expand(expr)\n    \n    # Check complexity\n    _check_expression_size(expanded, max_terms)\n    \n    # Simplify\n    simplified = Symbolics.simplify(expanded)\n    \n    # Try to factor perfect squares (TODO: not yet implemented)\n    factored = _try_factor_perfect_square(simplified)\n    \n    return factored\nend\n\nApplied in:\n\nQuadratic discriminant\nCubic coefficients p, q, Delta\nQuartic coefficients p, q, r, and intermediate beta^2, gamma, t_1, t_2\nRREF operations\nEigenvector construction","category":"section"},{"location":"implementation/#Expression-Size-Estimation","page":"Implementation Details","title":"Expression Size Estimation","text":"We estimate expression complexity by counting operations:\n\nfunction _estimate_expr_size(expr)\n    !_is_symbolic_coeff(expr) && return 1\n    \n    try\n        unwrapped = Symbolics.unwrap(expr)\n        return _count_operations(unwrapped)\n    catch\n        return 1\n    end\nend\n\nfunction _count_operations(x)\n    # Base case: leaf node\n    if x isa Number || !isdefined(x, :f)\n        return 1\n    end\n    \n    # Recursive case: count children\n    if isdefined(x, :arguments)\n        args = getfield(x, :arguments)\n        return 1 + sum(_count_operations, args; init=0)\n    end\n    \n    return 1\nend","category":"section"},{"location":"implementation/#Complexity-Threshold-Errors","page":"Implementation Details","title":"Complexity Threshold Errors","text":"When expressions exceed limits, we throw helpful errors:\n\nthrow(ExpressionComplexityError(\n    \"\"\"Expression has grown too large (≈$size terms, limit: $max_terms).\n    \n    Suggestions:\n    1. Reduce matrix size (try 2×2 or 3×3 instead of 4×4)\n    2. Use fewer symbolic variables\n    3. Exploit matrix structure\n    4. Use numeric eigenvalues\n    5. Increase limit with max_terms parameter (caution!)\n    \"\"\"\n))","category":"section"},{"location":"implementation/#Timeout-Mechanism","page":"Implementation Details","title":"Timeout Mechanism","text":"Long-running computations can be interrupted:\n\nfunction _with_timeout(f, timeout_seconds, degree)\n    task = @async f()\n    timeout_task = @async (sleep(timeout_seconds); true)\n    \n    # Wait for either task or timeout\n    while !istaskdone(task) && !istaskdone(timeout_task)\n        sleep(0.1)\n    end\n    \n    if istaskdone(timeout_task)\n        # Timeout occurred\n        schedule(task, InterruptException(), error=true)\n        throw(ComputationTimeoutError(\"Computation exceeded $timeout_seconds seconds\"))\n    end\n    \n    return fetch(task)\nend\n\nDefault timeout: 300 seconds (5 minutes) Can be disabled: Set timeout = nothing","category":"section"},{"location":"implementation/#Symbolic-Square-Root-for-Complex-Numbers","page":"Implementation Details","title":"Symbolic Square Root for Complex Numbers","text":"Julia's sqrt(::Complex) has boolean checks that fail for symbolic values. We implement it directly:\n\nfunction _symbolic_sqrt(x)\n    !(x isa Complex) && return sqrt(x)\n    \n    # For Complex{Num}, implement formula manually:\n    # sqrt(a + bi) = sqrt((r+a)/2) + i*sign(b)*sqrt((r-a)/2)\n    # where r = sqrt(a² + b²)\n    \n    a = real(x)\n    b = imag(x)\n    r = sqrt(a^2 + b^2)\n    \n    real_part = sqrt((r + a) / 2)\n    imag_part = sqrt((r - a) / 2)\n    \n    return Complex(real_part, imag_part)\nend\n\n","category":"section"},{"location":"implementation/#Performance-Considerations","page":"Implementation Details","title":"Performance Considerations","text":"","category":"section"},{"location":"implementation/#Complexity-Summary","page":"Implementation Details","title":"Complexity Summary","text":"Operation Complexity Notes\nBareiss determinant O(n^3) Polynomial expression growth\nCoefficient extraction O(n) Using derivatives\nQuadratic formula O(n^2) Expression size grows quadratically\nCubic formula O(n^3) Cardano's method\nQuartic formula O(n^4) Ferrari's method\nRREF O(mn^2 times s) s = average expression size\nNullspace O(n^3 times s) After RREF\nCirculant eigenvalues O(n^2) DFT-based\nTridiagonal eigenvalues O(n) Closed-form formula\nBlock decomposition O(k times T(nk)) k blocks of size nk","category":"section"},{"location":"implementation/#Bottlenecks","page":"Implementation Details","title":"Bottlenecks","text":"Quartic formula: Produces massive expressions for fully symbolic 4×4 matrices\nRREF: Simplification at each step can be slow for large expressions\nStructure detection: O(n⁴) for some patterns (block circulant, Kronecker)\nSymbolic simplification: Symbolics.jl simplification is not always fast","category":"section"},{"location":"implementation/#Optimization-Strategies","page":"Implementation Details","title":"Optimization Strategies","text":"For users:\n\nUse structured matrices (block-diagonal, circulant, tridiagonal)\nSubstitute numeric values for some variables\nRequest eigenvalues only (skip eigenvectors)\nUse smaller matrices (2 times 2, 3 times 3 much faster than 4 times 4)\nSet expand=false to skip polynomial expansion\n\nFor developers:\n\nAdd more special pattern detectors\nImprove expression simplification (factor perfect squares, etc.)\nCache intermediate results\nParallelize independent computations (when thread-safe)\nAdd more structural decompositions (Schur complement, etc.)","category":"section"},{"location":"implementation/#Memory-Usage","page":"Implementation Details","title":"Memory Usage","text":"Approximate memory usage for fully symbolic n times n matrices:\n\nSize Eigenvalues With Eigenvectors\n2 times 2 ~1 KB ~5 KB\n3 times 3 ~100 KB ~500 KB\n4 times 4 ~50 MB ~200 MB\n5 times 5 N/A* N/A*\n\n*5 times 5 requires special structure (not general case)","category":"section"},{"location":"implementation/#Parallelization-Challenges","page":"Implementation Details","title":"Parallelization Challenges","text":"Why we don't parallelize:\n\nSymbolics.jl uses task-local storage for hashconsing (expression deduplication), which is not thread-safe.\n\nAttempting to use Threads.@threads causes crashes:\n\n# DON'T DO THIS:\nThreads.@threads for v in vals\n    vecs = _nullspace(mat .- v .* I)  # CRASHES!\nend\n\nPotential solution: Use process-based parallelism (Distributed.jl) instead of threads.","category":"section"},{"location":"implementation/#Test-Coverage","page":"Implementation Details","title":"Test Coverage","text":"The test suite includes 172 tests covering:\n\nAll root solvers (linear through quartic)\nAll structure detectors\nAll special pattern solvers\nEdge cases (zero matrices, identity, etc.)\nError handling (timeouts, complexity errors)\n\nExecution time: 37.4 seconds\n\n","category":"section"},{"location":"implementation/#Future-Improvements","page":"Implementation Details","title":"Future Improvements","text":"","category":"section"},{"location":"implementation/#Algorithm-Enhancements","page":"Implementation Details","title":"Algorithm Enhancements","text":"Schur decomposition: For upper triangular form\nQR algorithm: Iterative eigenvalue refinement\nLanczos algorithm: For large sparse matrices\nPower method: For dominant eigenvalue","category":"section"},{"location":"implementation/#Pattern-Detection","page":"Implementation Details","title":"Pattern Detection","text":"Hamiltonian matrices: J-orthogonal structure\nHankel matrices: Related to Toeplitz\nCauchy matrices: Explicit determinant formulas\nVandermonde matrices: Closed-form determinant","category":"section"},{"location":"implementation/#Expression-Optimization","page":"Implementation Details","title":"Expression Optimization","text":"Perfect square factoring: Detect and factor (a-b)^2 + c^2\nCommon subexpression elimination: Deduplicate repeated subexpressions\nGröbner basis reduction: Polynomial ideal membership\nNumerical stability analysis: Detect ill-conditioned expressions","category":"section"},{"location":"implementation/#User-Experience","page":"Implementation Details","title":"User Experience","text":"Progress bars: For long computations\nIncremental results: Return partial results before timeout\nSymbolic assumptions: Propagate assumptions (real, positive, etc.)\nPretty printing: Better display of large expressions\n\n","category":"section"},{"location":"implementation/#References","page":"Implementation Details","title":"References","text":"","category":"section"},{"location":"implementation/#Algorithms","page":"Implementation Details","title":"Algorithms","text":"Bareiss, E.H. (1968). \"Sylvester's identity and multistep integer-preserving Gaussian elimination.\" Mathematics of Computation 22(103): 565-578.\nCardano, G. (1545). Ars Magna (The Great Art). Closed-form solution for cubic equations.\nFerrari, L. (1545). Solution of quartic equations (published in Cardano's Ars Magna).\nDavis, P.J. (1979). Circulant Matrices. Wiley-Interscience. Theory of circulant eigenvalues.\nTrench, W.F. (1999). \"Numerical solution of the eigenvalue problem for Hermitian Toeplitz matrices.\" SIAM Journal on Matrix Analysis and Applications 10(2): 135-146.","category":"section"},{"location":"implementation/#Mathematical-Background","page":"Implementation Details","title":"Mathematical Background","text":"Abel, N.H. (1826). \"Beweis der Unmöglichkeit, algebraische Gleichungen von höheren Graden als dem vierten allgemein aufzulösen.\" Proof that degree geq 5 has no general formula.\nGalois, É. (1832). \"Mémoire sur les conditions de résolubilité des équations par radicaux.\" Galois theory foundation.\nHorn, R.A. & Johnson, C.R. (2013). Matrix Analysis (2nd ed.). Cambridge University Press. Comprehensive matrix theory reference.","category":"section"},{"location":"implementation/#Implementation","page":"Implementation Details","title":"Implementation","text":"Symbolics.jl Documentation. https://symbolics.juliasymbolics.org/\nSymbolicUtils.jl. https://symbolicutils.juliasymbolics.org/\n\n","category":"section"},{"location":"implementation/#Appendix:-File-Organization","page":"Implementation Details","title":"Appendix: File Organization","text":"src/\n├── SymbolicDiagonalization.jl  # Module definition and exports\n├── charpoly.jl                 # Characteristic polynomial (Bareiss)\n├── roots.jl                    # Root solvers (degrees 1-4)\n├── rref.jl                     # RREF and nullspace computation\n└── diagonalize.jl              # Main API and pattern detection\n    ├── Public API (eigen, eigvals, symbolic_*)\n    ├── Structure Detection (_is_*, _detect_*)\n    ├── Special Pattern Solvers (_*_eigenvalues)\n    ├── Eigenvector Computation (_adjugate, _nullspace)\n    └── Utility Functions\n\nLines of code:\n\ncharpoly.jl: ~60 lines\nroots.jl: ~390 lines\nrref.jl: ~75 lines\ndiagonalize.jl: ~1495 lines\nTotal: ~2020 lines of implementation code\n\n\n\nThis implementation documentation was last updated: December 11, 2025","category":"section"}]
}

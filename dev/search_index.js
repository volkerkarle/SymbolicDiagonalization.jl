var documenterSearchIndex = {"docs":
[{"location":"api_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"Complete API documentation for SymbolicDiagonalization.jl.","category":"section"},{"location":"api_reference/#Table-of-Contents","page":"API Reference","title":"Table of Contents","text":"User-Facing API\nLinearAlgebra Interface\nDirect Eigenvalue API\nCharacteristic Polynomial\nRoot Solvers\nKeyword Arguments\nException Types\nInternal API\n\n","category":"section"},{"location":"api_reference/#User-Facing-API","page":"API Reference","title":"User-Facing API","text":"","category":"section"},{"location":"api_reference/#LinearAlgebra-Interface","page":"API Reference","title":"LinearAlgebra Interface","text":"The recommended interface for most users. Extends LinearAlgebra.jl with symbolic matrix support.","category":"section"},{"location":"api_reference/#LinearAlgebra.eigen","page":"API Reference","title":"LinearAlgebra.eigen","text":"eigen(A; kwargs...) → Eigen\n\nComputes eigenvalues and eigenvectors of symbolic matrix A.\n\nArguments:\n\nA::Matrix{Union{Num, Complex{Num}}} - Symbolic matrix to diagonalize\n\nKeyword Arguments: See Keyword Arguments section\n\nReturns: Eigen object with fields:\n\n.values - Vector of eigenvalues\n.vectors - Matrix of eigenvectors (as columns)\n\nExample:\n\nusing Symbolics, SymbolicDiagonalization, LinearAlgebra\n\n@variables a b c\nmat = [a 1 0; 0 b 1; 0 0 c]\n\nE = eigen(mat)\nE.values   # [a, b, c]\nE.vectors  # 3×3 eigenvector matrix\n\nNotes:\n\nUse eigvals() instead if you only need eigenvalues (faster)\nThrows error if matrix is not diagonalizable\nEigenvectors are columns of the returned matrix\n\n","category":"section"},{"location":"api_reference/#LinearAlgebra.eigvals","page":"API Reference","title":"LinearAlgebra.eigvals","text":"eigvals(A; kwargs...) → Vector\n\nComputes eigenvalues of symbolic matrix A (faster than eigen since it skips eigenvectors).\n\nArguments:\n\nA::Matrix{Union{Num, Complex{Num}}} - Symbolic matrix\n\nKeyword Arguments: See Keyword Arguments section\n\nReturns: Vector of eigenvalue expressions\n\nExample:\n\n@variables a b\nmat = [a b; b a]\n\nλ = eigvals(mat)  # [a + b, a - b]\n\nNotes:\n\nRecommended when eigenvectors not needed\nMuch faster than eigen() for large matrices\nSame structure detection and special pattern solvers\n\n","category":"section"},{"location":"api_reference/#Direct-Eigenvalue-API","page":"API Reference","title":"Direct Eigenvalue API","text":"Lower-level API for advanced users who need more control.","category":"section"},{"location":"api_reference/#symbolic_eigenvalues","page":"API Reference","title":"symbolic_eigenvalues","text":"symbolic_eigenvalues(A; kwargs...) → (values, poly, λ)\n\nComputes eigenvalues along with characteristic polynomial.\n\nArguments:\n\nA::Matrix - Symbolic matrix\n\nKeyword Arguments: See Keyword Arguments section\n\nReturns: Tuple of:\n\nvalues - Vector of eigenvalue expressions\npoly - Characteristic polynomial det(λI - A)\nλ - Symbolic variable used in polynomial\n\nExample:\n\n@variables a b\nmat = [a b; b a]\n\nvals, poly, λ = symbolic_eigenvalues(mat)\n# vals: [a+b, a-b]\n# poly: (λ - a)² - b²\n# λ: symbolic variable\n\nUse cases:\n\nNeed both eigenvalues and characteristic polynomial\nWant to manipulate polynomial directly\nNeed the eigenvalue variable for further computation\n\n","category":"section"},{"location":"api_reference/#symbolic_eigenpairs","page":"API Reference","title":"symbolic_eigenpairs","text":"symbolic_eigenpairs(A; kwargs...) → Vector{Tuple{Num, Vector{Vector{Num}}}}\n\nComputes eigenvalue-eigenvector pairs with multiplicity handling.\n\nArguments:\n\nA::Matrix - Symbolic matrix\n\nKeyword Arguments: \n\ncompute_vectors::Bool = true - Whether to compute eigenvectors\nPlus all standard kwargs\n\nReturns: Vector of tuples (eigenvalue, eigenvectors):\n\nEach eigenvalue may have multiple eigenvectors (geometric multiplicity)\nEigenvectors are vectors, not matrix columns\n\nExample:\n\n@variables a b\nmat = [a b; b a]\n\npairs = symbolic_eigenpairs(mat)\n# [(a+b, [v₁]), (a-b, [v₂])]\n\n# Access first eigenvalue and its eigenvectors\nλ₁, vecs₁ = pairs[1]\n\nUse cases:\n\nNeed explicit multiplicity information\nWant eigenvalues grouped with their eigenvectors\nNeed to handle degenerate cases\n\n","category":"section"},{"location":"api_reference/#symbolic_diagonalize","page":"API Reference","title":"symbolic_diagonalize","text":"symbolic_diagonalize(A; kwargs...) → (P, D, pairs)\n\nComputes full diagonalization A = P D P⁻¹.\n\nArguments:\n\nA::Matrix - Symbolic matrix\n\nKeyword Arguments: See Keyword Arguments section\n\nReturns: Tuple of:\n\nP - Matrix of eigenvectors (columns)\nD - Diagonal matrix of eigenvalues\npairs - Same as symbolic_eigenpairs() output\n\nExample:\n\n@variables a b\nmat = [a b; b a]\n\nP, D, pairs = symbolic_diagonalize(mat)\n# Verify: mat ≈ P * D * inv(P)\n\nThrows:\n\nArgumentError if matrix is not diagonalizable\nArgumentError if insufficient eigenvectors found\n\nUse cases:\n\nNeed explicit matrix factorization\nWant to verify diagonalizability\nNeed P and D matrices for further computation\n\n","category":"section"},{"location":"api_reference/#Characteristic-Polynomial","page":"API Reference","title":"Characteristic Polynomial","text":"","category":"section"},{"location":"api_reference/#characteristic_polynomial","page":"API Reference","title":"characteristic_polynomial","text":"characteristic_polynomial(A; var=nothing) → (poly, coeffs, λ)\n\nComputes characteristic polynomial det(λI - A) using Bareiss algorithm.\n\nArguments:\n\nA::Matrix - Symbolic matrix\nvar - Optional symbolic variable to use (auto-generated if not provided)\n\nReturns: Tuple of:\n\npoly - Polynomial expression det(λI - A)\ncoeffs - Vector of polynomial coefficients [c₀, c₁, ..., cₙ]\nλ - Symbolic variable\n\nExample:\n\n@variables a b\nmat = [a b; b a]\n\npoly, coeffs, λ = characteristic_polynomial(mat)\n# poly: λ² - 2a·λ + (a² - b²)\n# coeffs: [a² - b², -2a, 1]\n\nImplementation details:\n\nUses Bareiss fraction-free determinant for efficiency\nAvoids expression explosion from cofactor expansion\nCoefficients extracted by differentiation at λ = 0\n\nUse cases:\n\nNeed characteristic polynomial for analysis\nWant polynomial coefficients explicitly\nImplementing custom root-finding methods\n\n","category":"section"},{"location":"api_reference/#Root-Solvers","page":"API Reference","title":"Root Solvers","text":"","category":"section"},{"location":"api_reference/#symbolic_roots","page":"API Reference","title":"symbolic_roots","text":"symbolic_roots(poly, λ; expand=true, max_terms=10000) → Vector\n\nFinds symbolic roots of polynomial using closed-form formulas (degrees 1-4).\n\nArguments:\n\npoly - Polynomial expression in variable λ\nλ - Symbolic variable\nexpand::Bool = true - Whether to expand expressions\nmax_terms::Int = 10000 - Maximum expression complexity\n\nReturns: Vector of symbolic root expressions\n\nExample:\n\n@variables λ a b\npoly = λ^2 - 2a*λ + (a^2 - b^2)\n\nroots = symbolic_roots(poly, λ)\n# [a + b, a - b]\n\nSupported degrees:\n\nDegree 1: Linear formula\nDegree 2: Quadratic formula\nDegree 3: Cardano's cubic formula\nDegree 4: Ferrari's quartic formula\nDegree ≥ 5: Throws error (Abel-Ruffini theorem)\n\nThrows:\n\nArgumentError if degree ≥ 5 and no structure detected\nExpressionComplexityError if expression exceeds max_terms\n\nNotes:\n\nQuartic formula produces very large expressions\nConsider structure detection for degree ≥ 4\nFor degree 4, expressions can be ~13.5 MB each\n\n","category":"section"},{"location":"api_reference/#Keyword-Arguments","page":"API Reference","title":"Keyword Arguments","text":"All main functions (eigen, eigvals, symbolic_eigenvalues, etc.) accept these keyword arguments:","category":"section"},{"location":"api_reference/#var::Union{Nothing,-Num}","page":"API Reference","title":"var::Union{Nothing, Num}","text":"Default: nothing (auto-generate)\n\nSymbolic variable to use for eigenvalue. If nothing, a fresh variable is created.\n\nExample:\n\n@variables λ\nvals = eigvals(mat, var=λ)\n\nUse cases: \n\nNeed specific variable name\nIntegrating with existing symbolic expressions\nWant to control variable scope\n\n","category":"section"},{"location":"api_reference/#structure::Symbol","page":"API Reference","title":"structure::Symbol","text":"Default: :auto\n\nHint about matrix structure for optimization.\n\nOptions:\n\n:auto - Automatic structure detection (default)\n:hermitian - Hermitian matrix (A† = A)\n:symmetric - Real symmetric (Aᵀ = A)\n:unitary - Unitary matrix (A† = A⁻¹)\n:general - No structure assumptions\n\nExample:\n\n# Tell solver that matrix is Hermitian\nvals = eigvals(hermitian_mat, structure=:hermitian)\n\nNotes:\n\nProviding correct hint can speed up computation\nIncorrect hint may give wrong results\n:auto is safe but may be slower\n\n","category":"section"},{"location":"api_reference/#expand::Bool","page":"API Reference","title":"expand::Bool","text":"Default: true\n\nWhether to expand polynomial expressions.\n\nOptions:\n\ntrue - Expand products and powers\nfalse - Keep factored form when possible\n\nExample:\n\n# Factored form (if available)\nvals = eigvals(mat, expand=false)\n\nUse cases:\n\nFactored form may be simpler\nExpanded form needed for numerical evaluation\nDebugging expression structure\n\n","category":"section"},{"location":"api_reference/#complexity_threshold::Int","page":"API Reference","title":"complexity_threshold::Int","text":"Default: 5\n\nWarn if matrix contains more than this many symbolic variables.\n\nExample:\n\n# Suppress warning for 10-variable matrix\nvals = eigvals(large_mat, complexity_threshold=10)\n\nPurpose: Prevent accidentally running huge symbolic computations that may timeout or produce enormous expressions.\n\nRecommendation: \n\nKeep ≤ 5 for general matrices\nCan increase for structured matrices\nSet to Inf to disable warnings\n\n","category":"section"},{"location":"api_reference/#timeout::Int","page":"API Reference","title":"timeout::Int","text":"Default: 300 (5 minutes)\n\nMaximum computation time in seconds.\n\nExample:\n\n# Allow only 60 seconds\nvals = eigvals(mat, timeout=60)\n\nThrows: ComputationTimeoutError if exceeded\n\nUse cases:\n\nPrevent runaway computations\nTesting with time limits\nInteractive use with quick feedback\n\n","category":"section"},{"location":"api_reference/#max_terms::Int","page":"API Reference","title":"max_terms::Int","text":"Default: 10000\n\nMaximum number of terms allowed in symbolic expressions.\n\nExample:\n\n# Allow more complex expressions\nvals = eigvals(mat, max_terms=50000)\n\nThrows: ExpressionComplexityError if exceeded\n\nPurpose: Prevent expression explosion (especially in quartic formula)\n\nRecommendation:\n\nKeep default for most cases\nIncrease for structured matrices\nWatch memory usage if increasing\n\n","category":"section"},{"location":"api_reference/#Exception-Types","page":"API Reference","title":"Exception Types","text":"","category":"section"},{"location":"api_reference/#ExpressionComplexityError","page":"API Reference","title":"ExpressionComplexityError","text":"Thrown when symbolic expression exceeds complexity limit.\n\nFields:\n\nmsg::String - Error message\nterms::Int - Number of terms encountered\nlimit::Int - Configured limit\n\nExample:\n\ntry\n    vals = eigvals(huge_mat, max_terms=1000)\ncatch e\n    if e isa ExpressionComplexityError\n        println(\"Expression too complex: $(e.terms) terms (limit: $(e.limit))\")\n    end\nend\n\nCommon causes:\n\nFully symbolic 4×4 matrices (quartic formula)\nLack of detected structure\nNested radical expressions\n\nSolutions:\n\nAdd structure to matrix\nUse partial numeric substitution\nIncrease max_terms (watch memory!)\nUse numerical methods instead\n\n","category":"section"},{"location":"api_reference/#ComputationTimeoutError","page":"API Reference","title":"ComputationTimeoutError","text":"Thrown when computation exceeds time limit.\n\nFields:\n\nmsg::String - Error message\ntimeout::Int - Configured timeout in seconds\n\nExample:\n\ntry\n    vals = eigvals(mat, timeout=30)\ncatch e\n    if e isa ComputationTimeoutError\n        println(\"Timed out after $(e.timeout) seconds\")\n    end\nend\n\nCommon causes:\n\nVery large symbolic matrices\nComplex expression simplification\nExpensive structure detection\n\nSolutions:\n\nIncrease timeout\nSimplify matrix structure\nUse numerical methods\nPre-substitute some variables\n\n","category":"section"},{"location":"api_reference/#Internal-API","page":"API Reference","title":"Internal API","text":"These functions are not exported but may be useful for advanced users or contributors.","category":"section"},{"location":"api_reference/#Structure-Detection","page":"API Reference","title":"Structure Detection","text":"","category":"section"},{"location":"api_reference/#_detect_structure(mat)","page":"API Reference","title":"_detect_structure(mat)","text":"Automatically detects matrix structure (diagonal, triangular, block-diagonal, etc.)","category":"section"},{"location":"api_reference/#_is_diagonal(mat)","page":"API Reference","title":"_is_diagonal(mat)","text":"Tests if matrix is diagonal","category":"section"},{"location":"api_reference/#_is_triangular(mat)","page":"API Reference","title":"_is_triangular(mat)","text":"Tests if matrix is upper or lower triangular","category":"section"},{"location":"api_reference/#_is_hermitian(mat)","page":"API Reference","title":"_is_hermitian(mat)","text":"Tests if matrix is Hermitian (A† = A)","category":"section"},{"location":"api_reference/#_is_symmetric(mat)","page":"API Reference","title":"_is_symmetric(mat)","text":"Tests if matrix is real symmetric","category":"section"},{"location":"api_reference/#_is_persymmetric(mat)","page":"API Reference","title":"_is_persymmetric(mat)","text":"Tests if matrix has persymmetric structure Q[i,j] = Q[n+1-j,n+1-i]\n\n","category":"section"},{"location":"api_reference/#Special-Pattern-Detectors","page":"API Reference","title":"Special Pattern Detectors","text":"","category":"section"},{"location":"api_reference/#_is_circulant(mat)","page":"API Reference","title":"_is_circulant(mat)","text":"Tests if matrix is circulant (each row cyclic shift of previous)","category":"section"},{"location":"api_reference/#_is_block_circulant(mat)","page":"API Reference","title":"_is_block_circulant(mat)","text":"Tests if matrix is block circulant, returns (true, n_blocks, block_size, blocks) or (false, ...)","category":"section"},{"location":"api_reference/#_is_kronecker_product(mat)","page":"API Reference","title":"_is_kronecker_product(mat)","text":"Tests if matrix is Kronecker product, returns (true, A, B, m, n) or (false, ...)","category":"section"},{"location":"api_reference/#_is_toeplitz_tridiagonal(mat)","page":"API Reference","title":"_is_toeplitz_tridiagonal(mat)","text":"Tests if matrix is symmetric Toeplitz tridiagonal","category":"section"},{"location":"api_reference/#_is_antidiagonal(mat)","page":"API Reference","title":"_is_antidiagonal(mat)","text":"Tests if matrix is symmetric anti-diagonal","category":"section"},{"location":"api_reference/#_is_permutation_matrix(mat)","page":"API Reference","title":"_is_permutation_matrix(mat)","text":"Tests if matrix is a permutation matrix","category":"section"},{"location":"api_reference/#_detect_special_5x5_tridiagonal(mat)","page":"API Reference","title":"_detect_special_5x5_tridiagonal(mat)","text":"Tests for special 5×5 patterns with known eigenvalues\n\n","category":"section"},{"location":"api_reference/#Special-Pattern-Solvers","page":"API Reference","title":"Special Pattern Solvers","text":"","category":"section"},{"location":"api_reference/#_circulant_eigenvalues(mat)","page":"API Reference","title":"_circulant_eigenvalues(mat)","text":"Computes eigenvalues of circulant matrix using DFT","category":"section"},{"location":"api_reference/#_block_circulant_eigenvalues(mat,-n_blocks,-block_size,-blocks;-...)","page":"API Reference","title":"_block_circulant_eigenvalues(mat, n_blocks, block_size, blocks; ...)","text":"Computes eigenvalues of block circulant matrix","category":"section"},{"location":"api_reference/#_kronecker_eigenvalues(A,-B,-m,-n;-...)","page":"API Reference","title":"_kronecker_eigenvalues(A, B, m, n; ...)","text":"Computes eigenvalues of Kronecker product A ⊗ B","category":"section"},{"location":"api_reference/#_toeplitz_tridiagonal_eigenvalues(n,-a,-b,-c)","page":"API Reference","title":"_toeplitz_tridiagonal_eigenvalues(n, a, b, c)","text":"Computes eigenvalues of symmetric Toeplitz tridiagonal","category":"section"},{"location":"api_reference/#_antidiagonal_eigenvalues(mat)","page":"API Reference","title":"_antidiagonal_eigenvalues(mat)","text":"Computes eigenvalues of symmetric anti-diagonal matrix","category":"section"},{"location":"api_reference/#_compute_permutation_eigenvalues(A)","page":"API Reference","title":"_compute_permutation_eigenvalues(A)","text":"Computes eigenvalues of permutation matrix via cycle decomposition\n\n","category":"section"},{"location":"api_reference/#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"","category":"section"},{"location":"api_reference/#_block_split(mat)","page":"API Reference","title":"_block_split(mat)","text":"Detects and splits block-diagonal structure","category":"section"},{"location":"api_reference/#_persymmetric_split(mat)","page":"API Reference","title":"_persymmetric_split(mat)","text":"Splits persymmetric matrix into half-sized problems","category":"section"},{"location":"api_reference/#_count_symbolic_vars(A)","page":"API Reference","title":"_count_symbolic_vars(A)","text":"Counts number of unique symbolic variables in matrix","category":"section"},{"location":"api_reference/#_check_complexity(A;-threshold,-quiet)","page":"API Reference","title":"_check_complexity(A; threshold, quiet)","text":"Checks if matrix exceeds complexity threshold, optionally warns\n\n","category":"section"},{"location":"api_reference/#Usage-Examples","page":"API Reference","title":"Usage Examples","text":"","category":"section"},{"location":"api_reference/#Example-1:-Basic-Eigenvalues","page":"API Reference","title":"Example 1: Basic Eigenvalues","text":"using Symbolics, SymbolicDiagonalization, LinearAlgebra\n\n@variables a b c\nmat = [a 0 0; 0 b 0; 0 0 c]\n\nλ = eigvals(mat)  # [a, b, c]","category":"section"},{"location":"api_reference/#Example-2:-With-Structure-Hint","page":"API Reference","title":"Example 2: With Structure Hint","text":"@variables a b\nH = [a b; conj(b) a]  # Hermitian\n\nE = eigen(H, structure=:hermitian)","category":"section"},{"location":"api_reference/#Example-3:-Error-Handling","page":"API Reference","title":"Example 3: Error Handling","text":"@variables a b c d e\nmat = [a b c d e;\n       b a c d e;\n       c c a d e;\n       d d d a e;\n       e e e e a]\n\ntry\n    λ = eigvals(mat, timeout=60, max_terms=5000)\ncatch e\n    if e isa ComputationTimeoutError\n        println(\"Computation timed out\")\n    elseif e isa ExpressionComplexityError\n        println(\"Expression too complex\")\n    else\n        rethrow(e)\n    end\nend","category":"section"},{"location":"api_reference/#Example-4:-Characteristic-Polynomial","page":"API Reference","title":"Example 4: Characteristic Polynomial","text":"@variables a b\nmat = [a b; b a]\n\npoly, coeffs, λ = characteristic_polynomial(mat)\n# poly = λ² - 2a·λ + (a² - b²)\n\n# Now solve manually if desired\nroots = symbolic_roots(poly, λ)","category":"section"},{"location":"api_reference/#Example-5:-Full-Diagonalization","page":"API Reference","title":"Example 5: Full Diagonalization","text":"@variables a b\nmat = [a b; b a]\n\nP, D, pairs = symbolic_diagonalize(mat)\n\n# Verify: mat ≈ P * D * inv(P)\n# P contains eigenvectors as columns\n# D is diagonal with eigenvalues\n\n","category":"section"},{"location":"api_reference/#See-Also","page":"API Reference","title":"See Also","text":"User Guide - Practical examples and workflows\nPattern Library - Special patterns and their eigenvalues\nImplementation - Algorithm details\nMathematical Background - Theory and proofs","category":"section"},{"location":"mathematical_background/#Mathematical-Background","page":"Mathematical Background","title":"Mathematical Background","text":"This document explains the mathematical foundations underlying SymbolicDiagonalization.jl.","category":"section"},{"location":"mathematical_background/#Table-of-Contents","page":"Mathematical Background","title":"Table of Contents","text":"The Eigenvalue Problem\nThe Abel-Ruffini Theorem\nWhy Structure Matters\nClosed-Form Root Formulas\nSpecial Pattern Theory","category":"section"},{"location":"mathematical_background/#The-Eigenvalue-Problem","page":"Mathematical Background","title":"The Eigenvalue Problem","text":"","category":"section"},{"location":"mathematical_background/#Definition","page":"Mathematical Background","title":"Definition","text":"Given an n times n matrix mathbfA, we seek scalars lambda (eigenvalues) and non-zero vectors mathbfv (eigenvectors) satisfying:\n\nmathbfA mathbfv = lambda mathbfv\n\nEquivalently, we need:\n\n(mathbfA - lambda mathbfI) mathbfv = mathbf0\n\nFor non-trivial solutions, the matrix (mathbfA - lambda mathbfI) must be singular:\n\ndet(mathbfA - lambda mathbfI) = 0\n\nThis determinant is a polynomial in lambda called the characteristic polynomial:\n\np(lambda) = det(lambda mathbfI - mathbfA) = lambda^n + c_n-1lambda^n-1 + cdots + c_1lambda + c_0\n\nThe eigenvalue problem reduces to finding roots of a polynomial.","category":"section"},{"location":"mathematical_background/#Why-Eigenvalues-Matter","page":"Mathematical Background","title":"Why Eigenvalues Matter","text":"Eigenvalues reveal fundamental properties of linear transformations:\n\nDynamics: Matrix powers mathbfA^n grow/decay based on eigenvalue magnitudes\nStability: System stability determined by eigenvalue real parts\nGeometry: Eigenvalues measure stretching/compression along eigenvector directions\nSpectral decomposition: mathbfA = mathbfPmathbfDmathbfP^-1 where mathbfD is diagonal (if mathbfA is diagonalizable)","category":"section"},{"location":"mathematical_background/#The-Fundamental-Challenge","page":"Mathematical Background","title":"The Fundamental Challenge","text":"For general matrices:\n\n2 times 2\n→ degree-2 polynomial (quadratic formula)\n3 times 3\n→ degree-3 polynomial (cubic formula)\n4 times 4\n→ degree-4 polynomial (quartic formula)\n5 times 5\n→ degree-5 polynomial (no general formula!)\nn times n\n→ degree-n polynomial (no general formula for n geq 5)\n\nThis limitation is not computational—it's a fundamental impossibility proven by the Abel-Ruffini theorem.","category":"section"},{"location":"mathematical_background/#The-Abel-Ruffini-Theorem","page":"Mathematical Background","title":"The Abel-Ruffini Theorem","text":"","category":"section"},{"location":"mathematical_background/#Statement","page":"Mathematical Background","title":"Statement","text":"Theorem (Abel-Ruffini, 1824): There is no general algebraic solution (using radicals) for polynomial equations of degree 5 or higher.","category":"section"},{"location":"mathematical_background/#What-This-Means","page":"Mathematical Background","title":"What This Means","text":"Degree leq 4: Closed-form formulas exist using +, -, times, div, and nth roots\nDegree geq 5: No general formula exists using these operations\nSpecific polynomials: May still have closed-form solutions (e.g., lambda^5 - 1 = 0)","category":"section"},{"location":"mathematical_background/#Implications-for-Symbolic-Eigenvalues","page":"Mathematical Background","title":"Implications for Symbolic Eigenvalues","text":"✅ Can solve symbolically:\n\nAll 1 times 1, 2 times 2, 3 times 3, 4 times 4 general matrices\nLarger matrices with exploitable structure\n\n❌ Cannot solve symbolically (in general):\n\nGeneric 5 times 5, 6 times 6, ..., n times n matrices\nMatrices whose structure doesn't reduce to degree leq 4","category":"section"},{"location":"mathematical_background/#Galois-Theory-Background","page":"Mathematical Background","title":"Galois Theory Background","text":"The Abel-Ruffini theorem is a consequence of Galois theory:\n\nSolvable groups: Polynomial roots can be expressed in radicals iff its Galois group is solvable\nSymmetric groups: The generic degree-n polynomial has Galois group S_n (symmetric group)\nNon-solvability: S_n is not solvable for n geq 5\nConclusion: No general radical formula for degree geq 5\n\nKey insight: Specific polynomials may have special Galois groups that ARE solvable, even for degree geq 5. This is why structure detection is crucial.","category":"section"},{"location":"mathematical_background/#Why-Structure-Matters","page":"Mathematical Background","title":"Why Structure Matters","text":"","category":"section"},{"location":"mathematical_background/#The-Structure-Exploitation-Strategy","page":"Mathematical Background","title":"The Structure-Exploitation Strategy","text":"Since we can't solve general n times n matrices for n geq 5, we must:\n\nDetect structure in the matrix\nExploit structure to reduce problem complexity\nSolve using available methods","category":"section"},{"location":"mathematical_background/#Types-of-Exploitable-Structure","page":"Mathematical Background","title":"Types of Exploitable Structure","text":"","category":"section"},{"location":"mathematical_background/#1.-Reducible-Structure","page":"Mathematical Background","title":"1. Reducible Structure","text":"Block-diagonal matrices:\n\nmathbfA = beginbmatrix\nmathbfA_1  mathbf0  mathbf0 \nmathbf0  mathbfA_2  mathbf0 \nmathbf0  mathbf0  mathbfA_3\nendbmatrix\n\nEigenvalues: lambda(mathbfA) = lambda(mathbfA_1) cup lambda(mathbfA_2) cup lambda(mathbfA_3)\n\nWhy this helps: An 8 times 8 block diagonal with 2 times 2 blocks requires solving 4 quadratic equations, not one degree-8 equation.","category":"section"},{"location":"mathematical_background/#2.-Symmetry-Structure","page":"Mathematical Background","title":"2. Symmetry Structure","text":"Circulant matrices: Each row is cyclic shift of previous\n\nmathbfC = beginbmatrix\nc_0  c_1  c_2  cdots  c_n-1 \nc_n-1  c_0  c_1  cdots  c_n-2 \nc_n-2  c_n-1  c_0  cdots  c_n-3 \nvdots  vdots  vdots  ddots  vdots\nendbmatrix\n\nEigenvalues: lambda_k = sum_j=0^n-1 c_j cdot omega^kj where omega = exp(2pi in)\n\nWhy this helps: The DFT matrix diagonalizes ALL circulant matrices, giving closed form for any n.","category":"section"},{"location":"mathematical_background/#3.-Tensor-Product-Structure","page":"Mathematical Background","title":"3. Tensor Product Structure","text":"Kronecker products: mathbfA otimes mathbfB\n\nmathbfA otimes mathbfB = beginbmatrix\na_11mathbfB  a_12mathbfB  cdots \na_21mathbfB  a_22mathbfB  cdots \nvdots  vdots  ddots\nendbmatrix\n\nEigenvalues: lambda(mathbfA otimes mathbfB) = lambda_i(mathbfA) cdot lambda_j(mathbfB)  textall  ij\n\nWhy this helps: A 6 times 6 = (2 times 2) otimes (3 times 3) reduces to quadratic + cubic, not degree-6.","category":"section"},{"location":"mathematical_background/#4.-Special-Pattern-Structure","page":"Mathematical Background","title":"4. Special Pattern Structure","text":"Symmetric Toeplitz tridiagonal: Constant diagonals\n\nmathbfT = beginbmatrix\na  b  0  0  cdots  0 \nb  a  b  0  cdots  0 \n0  b  a  b  cdots  0 \nvdots  vdots  vdots  vdots  ddots  vdots\nendbmatrix\n\nEigenvalues: lambda_k = a + 2b cosleft(frackpin+1right) for k = 1 2 ldots n\n\nWhy this helps: Known eigenvector basis (discrete sine transform) gives closed-form eigenvalues.","category":"section"},{"location":"mathematical_background/#The-Key-Principle","page":"Mathematical Background","title":"The Key Principle","text":"Matrices with structure have special Galois groups.\n\nThe characteristic polynomial of a structured matrix isn't generic—it has symmetries that make its Galois group smaller or more solvable, even for degree geq 5.\n\nExamples:\n\nCirculant n times n: Galois group is cyclic mathbbZ_n (always solvable)\nGeneric n times n: Galois group is symmetric S_n (not solvable for n geq 5)","category":"section"},{"location":"mathematical_background/#Closed-Form-Root-Formulas","page":"Mathematical Background","title":"Closed-Form Root Formulas","text":"","category":"section"},{"location":"mathematical_background/#Degree-1:-Linear","page":"Mathematical Background","title":"Degree 1: Linear","text":"Equation: lambda + c_0 = 0\n\nSolution: lambda = -c_0","category":"section"},{"location":"mathematical_background/#Degree-2:-Quadratic","page":"Mathematical Background","title":"Degree 2: Quadratic","text":"Equation: lambda^2 + c_1lambda + c_0 = 0\n\nSolution (Quadratic formula):\n\nlambda = frac-c_1 pm sqrtc_1^2 - 4c_02\n\nDiscriminant: Delta = c_1^2 - 4c_0\n\nDelta  0\n: Two real roots\nDelta = 0\n: One repeated root\nDelta  0\n: Two complex conjugate roots","category":"section"},{"location":"mathematical_background/#Degree-3:-Cubic-(Cardano's-Formula)","page":"Mathematical Background","title":"Degree 3: Cubic (Cardano's Formula)","text":"Equation: lambda^3 + c_2lambda^2 + c_1lambda + c_0 = 0\n\nStrategy: Eliminate quadratic term via substitution lambda = t - c_23\n\nReduced form: t^3 + pt + q = 0\n\nSolution:\n\nt = sqrt3-fracq2 + sqrtfracq^24 + fracp^327 + sqrt3-fracq2 - sqrtfracq^24 + fracp^327\n\nDiscriminant: Delta = -4p^3 - 27q^2\n\nDelta  0\n: Three distinct real roots\nDelta = 0\n: Repeated root\nDelta  0\n: One real root, two complex conjugates\n\nHistorical note: Cardano published this in 1545, but Tartaglia discovered it earlier.","category":"section"},{"location":"mathematical_background/#Degree-4:-Quartic-(Ferrari's-Method)","page":"Mathematical Background","title":"Degree 4: Quartic (Ferrari's Method)","text":"Equation: lambda^4 + c_3lambda^3 + c_2lambda^2 + c_1lambda + c_0 = 0\n\nStrategy: \n\nEliminate cubic term: lambda = t - c_34\nAdd and subtract clever term to create perfect squares\nReduce to solving a cubic (Cardano) plus quadratics\n\nSolution (simplified outline):\n\nSolve cubic resolvent: y^3 + p_2y^2 + p_1y + p_0 = 0 (use Cardano)\nUse root y to decompose into two quadratics\nSolve quadratics for final four roots\n\nComplexity: Formula involves nested cube roots and square roots, producing extremely large expressions.\n\nExpression size: For fully symbolic 4 times 4 matrix, each eigenvalue is ~13.5 MB of symbolic expressions!","category":"section"},{"location":"mathematical_background/#Degree-5:-No-General-Formula","page":"Mathematical Background","title":"Degree ≥ 5: No General Formula","text":"Abel-Ruffini Theorem: No algebraic solution using radicals.\n\nOur approach: Detect structure and apply specialized methods.","category":"section"},{"location":"mathematical_background/#Special-Pattern-Theory","page":"Mathematical Background","title":"Special Pattern Theory","text":"","category":"section"},{"location":"mathematical_background/#Why-Certain-Patterns-Have-Closed-Forms","page":"Mathematical Background","title":"Why Certain Patterns Have Closed Forms","text":"A matrix pattern has closed-form eigenvalues if one of these conditions holds:","category":"section"},{"location":"mathematical_background/#1.-Commutes-with-Known-Transformation","page":"Mathematical Background","title":"1. Commutes with Known Transformation","text":"If mathbfAmathbfU = mathbfUmathbfLambda where:\n\nmathbfU\nis a known unitary matrix (independent of matrix entries)\nmathbfLambda\nis diagonal\n\nThen mathbfU diagonalizes mathbfA, and eigenvalues are diagonal entries of mathbfLambda = mathbfU^daggermathbfAmathbfU.\n\nExamples:\n\nCirculant: mathbfU = DFT matrix\nSymmetric Toeplitz tridiagonal: mathbfU = discrete sine transform","category":"section"},{"location":"mathematical_background/#2.-Reducible-via-Transformation","page":"Mathematical Background","title":"2. Reducible via Transformation","text":"If a known transformation splits mathbfA into independent subproblems of degree leq 4.\n\nExamples:\n\nBlock-diagonal: Already split\nPersymmetric: Symmetry transformation splits into half-sized problems\nBlock circulant: Block DFT reduces to smaller problems","category":"section"},{"location":"mathematical_background/#3.-Tensor-Product-Structure-2","page":"Mathematical Background","title":"3. Tensor Product Structure","text":"If mathbfA = mathbfB otimes mathbfC, then lambda(mathbfA) = lambda_i(mathbfB) cdot lambda_j(mathbfC).\n\nWorks when: Can detect Kronecker product structure.","category":"section"},{"location":"mathematical_background/#4.-Polynomial-in-Simple-Matrix","page":"Mathematical Background","title":"4. Polynomial in Simple Matrix","text":"If mathbfA = f(mathbfJ) where mathbfJ is a simple matrix (e.g., shift operator, permutation).\n\nExamples:\n\nCirculant: Polynomial in cyclic shift matrix\nSymmetric Toeplitz tridiagonal: Related to Chebyshev polynomials","category":"section"},{"location":"mathematical_background/#5.-Special-Symmetry-Group","page":"Mathematical Background","title":"5. Special Symmetry Group","text":"If the matrix has a symmetry group that:\n\nConstrains eigenvalue structure\nReduces to solvable subproblems\n\nExamples:\n\nAnti-diagonal: Persymmetric symmetry forces pm pairs\nPermutation: Cycle structure gives roots of unity","category":"section"},{"location":"mathematical_background/#The-Discovery-Process","page":"Mathematical Background","title":"The Discovery Process","text":"Finding new patterns requires:\n\nPattern hypothesis: Guess a family of matrices\nNumerical testing: Check if eigenvalues have simple form\nSymbolic verification: Verify closed form holds symbolically\nMathematical justification: Explain WHY it works (find the structure)\nGeneralization: Identify what structural property makes it work\n\nSee notes/DISCOVERY_METHODOLOGY.md for practical exploration techniques.","category":"section"},{"location":"mathematical_background/#Current-Limitations","page":"Mathematical Background","title":"Current Limitations","text":"Unknown patterns: Many patterns with closed forms remain undiscovered.\n\nDetection is hard: Even when pattern has closed form, detecting it automatically is challenging.\n\nPartial solutions: Some patterns have partial closed forms (e.g., some eigenvalues closed, others not).","category":"section"},{"location":"mathematical_background/#Group-Theory-and-Symmetry-Based-Diagonalization","page":"Mathematical Background","title":"Group Theory and Symmetry-Based Diagonalization","text":"Group theory provides powerful tools for symbolic eigenvalue computation, especially for matrices with n geq 5 where direct algebraic methods fail. The key insight: matrix symmetries constrain eigenvalue structure.","category":"section"},{"location":"mathematical_background/#Representation-Theory-Fundamentals","page":"Mathematical Background","title":"Representation Theory Fundamentals","text":"","category":"section"},{"location":"mathematical_background/#Basic-Principle","page":"Mathematical Background","title":"Basic Principle","text":"When a matrix mathbfA commutes with a group G of symmetry operations:\n\ng mathbfA = mathbfA g quad forall g in G\n\nThen:\n\nEigenvectors organize into irreducible representations (irreps) of G\nEigenvalues within an irrep are equal (degeneracy)\nCharacter tables predict eigenspace dimensions before computation","category":"section"},{"location":"mathematical_background/#Key-Groups-for-Matrix-Analysis","page":"Mathematical Background","title":"Key Groups for Matrix Analysis","text":"1. Cyclic Groups mathbbZ_n (Already exploited in circulant matrices)\n\nElements: e g g^2 ldots g^n-1 where g^n = e\nIrreps: All 1-dimensional, labeled by k = 0 1 ldots n-1\nCharacters: chi_k(g^j) = omega^jk where omega = e^2pi in\nApplication: Circulant matrices are diagonalized by DFT (Fourier basis = irrep basis)\n\n2. Dihedral Groups D_n (Rotation + Reflection symmetries)\n\nElements: n rotations + n reflections (total: 2n elements)\nOrder: D_n = 2n\nIrreps: \nTwo 1-dimensional (symmetric and antisymmetric under reflection)\n(n-2)2\ntwo-dimensional irreps (for even n)\n(n-1)2\ntwo-dimensional irreps (for odd n)\nApplication: Matrices with both rotational and mirror symmetry\n\nExample (Pentagon - D_5): \n\nMatrix with pentagonal symmetry (5-fold rotation + 5 reflection axes)\nEigenspaces: dim 1 (symmetric), dim 1 (antisymmetric), dim 2, dim 2\nWithout solving: know two eigenvalues are simple, two are doubly degenerate\n\n3. Symmetric Group S_n (All permutations)\n\nElements: All n permutations\nIrreps: Labeled by Young diagrams\nKey fact: Generic n times n matrix has S_n Galois group\nApplication: Understanding why generic n geq 5 case is impossible\n\n4. Point Groups (3D Molecular symmetries)\n\nUsed in quantum chemistry for molecular orbitals:\n\nC_n\n: Cyclic rotation\nD_n\n: Dihedral (rotation + reflection)\nT_d\n: Tetrahedral\nO_h\n: Octahedral\nI_h\n: Icosahedral","category":"section"},{"location":"mathematical_background/#Galois-Groups-and-Solvability-by-Radicals","page":"Mathematical Background","title":"Galois Groups and Solvability by Radicals","text":"","category":"section"},{"location":"mathematical_background/#Connection-to-Eigenvalue-Problem","page":"Mathematical Background","title":"Connection to Eigenvalue Problem","text":"For characteristic polynomial p(lambda) = det(lambda I - A):\n\nGalois group = Symmetries of roots that preserve polynomial relations\n\nKey theorem: Polynomial solvable by radicals iff Galois group is solvable","category":"section"},{"location":"mathematical_background/#Solvable-Groups-(Can-express-eigenvalues-symbolically)","page":"Mathematical Background","title":"Solvable Groups (Can express eigenvalues symbolically)","text":"Cyclic groups mathbbZ_n: Always solvable\nExample: lambda^5 - 2 = 0 has Galois group mathbbZ_5\nRoots: sqrt52 cdot omega^k, k = 01234 where omega = e^2pi i5\nDihedral groups D_n: Always solvable\nExample: lambda^5 - lambda - 1 = 0 often has D_5 Galois group\nSolvable in radicals (though expressions may be complex)\nFrobenius groups: Solvable\nSemi-direct products of cyclic groups\nNilpotent groups: Solvable\nProducts of p-groups","category":"section"},{"location":"mathematical_background/#Non-Solvable-Groups-(Cannot-express-in-radicals)","page":"Mathematical Background","title":"Non-Solvable Groups (Cannot express in radicals)","text":"Symmetric group S_n for n geq 5: NOT solvable\nGeneric degree-n polynomial\nAbel-Ruffini theorem consequence\nAlternating group A_n for n geq 5: NOT solvable\nEven permutations only","category":"section"},{"location":"mathematical_background/#Practical-Application:-Galois-Group-Detection","page":"Mathematical Background","title":"Practical Application: Galois Group Detection","text":"Strategy for degree 5-8 polynomials:\n\nCompute resolvent polynomial\nDegree 5: Sextic resolvent\nDegree 6: Quintic resolvent\nCheck factorization patterns:\nComplete factorization → Cyclic group (solvable!)\nIrreducible of specific degree → Dihedral (solvable!)\nStays degree n → Likely S_n (not solvable)\nUse discriminant:\nSquare discriminant → Galois group in A_n\nStudy discriminant factors\n\nExample (Degree 5):\n\nFor lambda^5 + c_3lambda^3 + c_2lambda^2 + c_1lambda + c_0 = 0:\n\nIf factors as (λ^2 + a)(λ^3 + b) = 0 → Reducible, solvable\nIf c_3 = c_2 = 0 → Likely cyclic Galois group\nResolvent factorization reveals Galois group structure","category":"section"},{"location":"mathematical_background/#Commutant-Based-Diagonalization","page":"Mathematical Background","title":"Commutant-Based Diagonalization","text":"","category":"section"},{"location":"mathematical_background/#Theoretical-Foundation","page":"Mathematical Background","title":"Theoretical Foundation","text":"Schur's Lemma: If mathbfA commutes with all elements of an irreducible representation, then mathbfA is a scalar multiple of identity in that irrep space.\n\nConsequence: \n\nFind transformations mathbfT that commute with mathbfA\nmathbfT\n's eigenvectors are also mathbfA's eigenvectors\nIf mathbfT is \"simple\" (known eigenvectors), we get mathbfA's eigenvectors!","category":"section"},{"location":"mathematical_background/#Applications-Already-in-Code","page":"Mathematical Background","title":"Applications Already in Code","text":"1. Circulant Matrices\n\nCommute with cyclic shift operator mathbfS\nmathbfS\nis diagonalized by DFT matrix\nTherefore DFT diagonalizes ALL circulant matrices\n\n2. Symmetric Toeplitz Tridiagonal\n\nCommutes with certain reflection operators\nEigenvectors are discrete sine transform (DST)\nClosed-form eigenvalues: lambda_k = a + 2bcos(kpi(n+1))","category":"section"},{"location":"mathematical_background/#New-Opportunities","page":"Mathematical Background","title":"New Opportunities","text":"3. Block-Circulant with Circulant Blocks (BCCB)\n\nStructure:\n\nmathbfA = beginbmatrix\nC_0  C_1  cdots  C_n-1 \nC_n-1  C_0  cdots  C_n-2 \nvdots  vdots  ddots  vdots \nC_1  C_2  cdots  C_0\nendbmatrix\n\nwhere each C_i is itself circulant.\n\nSymmetry: Cyclic in both block structure and within blocks\nDiagonalization: 2D discrete Fourier transform\nEigenvalues: lambda_jk = sum_pq c_pq omega_n^jp omega_m^kq\nApplication: Image processing, 2D signal processing\n\n4. Dihedral Symmetry\n\nMatrix commuting with:\n\nRotation: mathbfR (order n)\nReflection: mathbfF (order 2)\n\nDetection criteria:\n\nmathbfAmathbfR = mathbfRmathbfA\nmathbfAmathbfF = mathbfFmathbfA\nmathbfR^n = mathbfI\n, mathbfF^2 = mathbfI, mathbfFmathbfRmathbfF = mathbfR^-1\n\nConsequence: \n\nEigenvalues come in patterns dictated by irreps\nSome eigenvalues non-degenerate, others doubly degenerate\nCan block-diagonalize into smaller problems","category":"section"},{"location":"mathematical_background/#Graph-Symmetries-and-Spectral-Graph-Theory","page":"Mathematical Background","title":"Graph Symmetries and Spectral Graph Theory","text":"","category":"section"},{"location":"mathematical_background/#Automorphism-Groups","page":"Mathematical Background","title":"Automorphism Groups","text":"For graph adjacency matrix mathbfA or Laplacian mathbfL:\n\nGraph automorphism = Permutation of vertices preserving edges\n\nSymmetry → Degeneracy: \n\nIf vertex i and j are in same orbit, eigenvector components related\nAutomorphism group determines eigenvalue multiplicities","category":"section"},{"location":"mathematical_background/#Strongly-Regular-Graphs","page":"Mathematical Background","title":"Strongly Regular Graphs","text":"Definition: Graph with parameters (n k lambda mu) where:\n\nn\nvertices\nEach vertex has k neighbors (regular)\nAdjacent vertices have lambda common neighbors\nNon-adjacent vertices have mu common neighbors\n\nRemarkable property: Only 3 distinct eigenvalues!\n\nEigenvalues:\n\nlambda_1 = k text (multiplicity 1)\n\nlambda_2 = frac(lambda - mu) + sqrt(lambda-mu)^2 + 4(k-mu)2 text (multiplicity  f text)\n\nlambda_3 = frac(lambda - mu) - sqrt(lambda-mu)^2 + 4(k-mu)2 text (multiplicity  g text)\n\nwhere f + g = n - 1.\n\nExamples:\n\nPetersen graph (10 vertices): Eigenvalues 3 1^5 -2^4\nPaley graphs: (p (p-1)2 (p-5)4 (p-1)4) for prime p equiv 1 pmod 4\nComplete bipartite K_mn: Eigenvalues pmsqrtmn 0^m+n-2\n\nDetection:\n\nCheck if adjacency matrix is 0-1\nVerify regularity: all row sums equal\nCount common neighbors for adjacent and non-adjacent pairs\nIf all pairs follow pattern → strongly regular → instant eigenvalues!","category":"section"},{"location":"mathematical_background/#Distance-Regular-Graphs","page":"Mathematical Background","title":"Distance-Regular Graphs","text":"Generalization of strongly regular:\n\nNumber of neighbors at distance d depends only on d\nEigenvalues satisfy polynomial recurrence relations\nMany have closed-form eigenvalue expressions\n\nExamples:\n\nHypercubes Q_n: Eigenvalues n-2k  k=01ldotsn with multiplicity binomnk\nJohnson graphs J(nk): Eigenvalues related to binomial coefficients\nHamming graphs: Product structure → Kronecker product of simpler graphs","category":"section"},{"location":"mathematical_background/#Lie-Groups-and-Continuous-Symmetries","page":"Mathematical Background","title":"Lie Groups and Continuous Symmetries","text":"","category":"section"},{"location":"mathematical_background/#Motivation","page":"Mathematical Background","title":"Motivation","text":"Some matrices commute with continuous symmetry groups:\n\nRotations in 2D or 3D\nQuantum mechanical angular momentum\nSpecial unitary transformations","category":"section"},{"location":"mathematical_background/#SO(2)-Rotations-in-2D","page":"Mathematical Background","title":"SO(2) - Rotations in 2D","text":"Matrix commuting with all 2D rotations:\n\nmathbfR(theta) = beginbmatrix costheta  -sintheta  sintheta  costheta endbmatrix\n\nConsequence: Must be proportional to identity or to rotation itself\n\nApplication: Angular momentum, circular symmetry problems","category":"section"},{"location":"mathematical_background/#SO(3)-Rotations-in-3D","page":"Mathematical Background","title":"SO(3) - Rotations in 3D","text":"Irreps labeled by angular momentum j = 0 12 1 32 2 ldots\n\nDimension: 2j + 1\n\nExample: j = 1 (spin-1, dimension 3)\n\nThree eigenvalues: -1 0 +1 (z-component of angular momentum)\n\nApplication: Molecular orbital theory, atomic physics","category":"section"},{"location":"mathematical_background/#SU(2)-Spin-Systems","page":"Mathematical Background","title":"SU(2) - Spin Systems","text":"Similar to SO(3) but for half-integer spins.\n\nExample: Spin-52 system (6-dimensional)\n\nEigenvalues: m = -52 -32 -12 +12 +32 +52\nEqually spaced by symmetry alone!\nNo polynomial solving needed\n\nDetection:\n\nCheck if matrix commutes with mathbfJ_x mathbfJ_y mathbfJ_z (angular momentum operators)\nVerify mathbfJ_i mathbfJ_j = iepsilon_ijkmathbfJ_k\nIf yes → eigenvalues are j j-1 j-2 ldots -j where 2j+1 = n","category":"section"},{"location":"mathematical_background/#Practical-Detection-Strategies","page":"Mathematical Background","title":"Practical Detection Strategies","text":"","category":"section"},{"location":"mathematical_background/#Algorithm:-Detect-Matrix-Symmetries","page":"Mathematical Background","title":"Algorithm: Detect Matrix Symmetries","text":"Input: Matrix A\nOutput: Symmetry group and eigenvalue structure\n\n1. Check basic structure:\n   - Circulant? → Use DFT\n   - Block-diagonal? → Recurse on blocks\n   - Triangular? → Read diagonal\n\n2. Test group generators:\n   - For each candidate generator g:\n     * Compute A*g and g*A\n     * If equal, g is a symmetry\n   - Identify minimal generating set\n\n3. Determine group:\n   - If cyclic generator only → ℤ_n\n   - If cyclic + reflection → D_n\n   - If all permutations → S_n (generic case)\n\n4. Apply representation theory:\n   - Look up character table\n   - Decompose into irreps\n   - Determine eigenspace dimensions\n   - Construct symmetry-adapted basis\n\n5. Solve reduced problems:\n   - Each irrep gives smaller eigenvalue problem\n   - Often degree ≤ 4 even if original is n ≥ 5","category":"section"},{"location":"mathematical_background/#Algorithm:-Galois-Group-Analysis-(Degree-5-8)","page":"Mathematical Background","title":"Algorithm: Galois Group Analysis (Degree 5-8)","text":"Input: Characteristic polynomial p(λ)\nOutput: Solvability and solution strategy\n\n1. Compute discriminant Δ\n   - If Δ is a perfect square → Galois group ⊆ A_n\n\n2. Compute resolvent polynomial\n   - Degree 5 → sextic resolvent\n   - Check if it factors\n\n3. Analyze factorization:\n   - Completely factors → Cyclic group → Use roots of unity\n   - Factors into degree-2 and degree-3 → Reducible → Solve separately\n   - Irreducible → Check for dihedral group\n\n4. If solvable:\n   - Construct tower of field extensions\n   - Express roots as nested radicals\n   \n5. If not solvable:\n   - Return numerical approximation\n   - Warn user about algebraic impossibility","category":"section"},{"location":"mathematical_background/#Implementation-Roadmap","page":"Mathematical Background","title":"Implementation Roadmap","text":"","category":"section"},{"location":"mathematical_background/#High-Priority-(Immediately-Useful)","page":"Mathematical Background","title":"High Priority (Immediately Useful)","text":"Dihedral symmetry detector\nInput: Matrix\nDetect rotation and reflection generators\nBlock-diagonalize by irreps\nSolve reduced problems (often degree ≤ 2)\nStrongly regular graph detector\nInput: 0-1 adjacency matrix\nVerify strong regularity property\nCompute three eigenvalues from parameters\nWorks for arbitrary size n\nGalois group analyzer\nInput: Degree 5-8 polynomial\nCompute resolvent and discriminant\nIdentify Galois group\nIf solvable, provide symbolic solution","category":"section"},{"location":"mathematical_background/#Medium-Priority","page":"Mathematical Background","title":"Medium Priority","text":"BCCB matrix handler\nDetect block-circulant with circulant blocks\nApply 2D DFT\nCommon in image processing\nHypercube graph detector\nIdentify n-dimensional hypercube structure\nEigenvalues: n-2k with multiplicities binomnk\nLie algebra symmetry checker\nTest commutation with SO(2), SO(3), SU(2) generators\nIf symmetric, use representation theory formulas","category":"section"},{"location":"mathematical_background/#Examples-in-Practice","page":"Mathematical Background","title":"Examples in Practice","text":"","category":"section"},{"location":"mathematical_background/#Example-1:-Pentagon-Symmetry-(55,-Dihedral-D_5)","page":"Mathematical Background","title":"Example 1: Pentagon Symmetry (5×5, Dihedral D_5)","text":"Adjacency matrix of regular pentagon:\n\nmathbfA = beginbmatrix\n0  1  0  0  1 \n1  0  1  0  0 \n0  1  0  1  0 \n0  0  1  0  1 \n1  0  0  1  0\nendbmatrix\n\nWithout group theory: Solve degree-5 polynomial (impossible in general)\n\nWith group theory:\n\nHas D_5 symmetry (5-fold rotation + reflections)\nD_5\nirreps: two 1D, two 2D\nEigenvalues: lambda_1 = 2 (1D), lambda_2 = -2 (1D), then two pairs\nEigenvalues: 2 phi -phi^-1 -phi^-1 phi where phi = (1+sqrt5)2 (golden ratio!)\n\nKey: Group theory reduces degree-5 problem to quadratic!","category":"section"},{"location":"mathematical_background/#Example-2:-Petersen-Graph-(1010,-Strongly-Regular)","page":"Mathematical Background","title":"Example 2: Petersen Graph (10×10, Strongly Regular)","text":"Parameters: (10 3 0 1)\n\n10 vertices\nEach vertex has 3 neighbors\nAdjacent vertices have 0 common neighbors\nNon-adjacent vertices have 1 common neighbor\n\nEigenvalues (from strong regularity alone):\n\nlambda_1 = 3 text (multiplicity 1)\n\nlambda_2 = 1 text (multiplicity 5)\n\nlambda_3 = -2 text (multiplicity 4)\n\nNo polynomial solving needed! Pure symmetry argument.","category":"section"},{"location":"mathematical_background/#Example-3:-66-Spin-5/2-System","page":"Mathematical Background","title":"Example 3: 6×6 Spin-5/2 System","text":"Matrix representing J_z (angular momentum operator):\n\nmathbfJ_z = textdiagleft(-frac52 -frac32 -frac12 frac12 frac32 frac52right)\n\nMore interesting: mathbfJ_x or mathbfJ_y matrices (non-diagonal)\n\nWith SU(2) symmetry:\n\nEigenvalues MUST be -52 -32 -12 12 32 52\nEqually spaced by 1\nOrder may vary but values are determined by symmetry\n\nApplication: Quantum mechanics, no polynomial solving needed for any spin-j system.","category":"section"},{"location":"mathematical_background/#Example-4:-Solvable-Degree-5-(Cyclic-Galois-Group)","page":"Mathematical Background","title":"Example 4: Solvable Degree-5 (Cyclic Galois Group)","text":"Polynomial: lambda^5 - 3 = 0\n\nGalois group: mathbbZ_5 (cyclic)\n\nSolution: \n\nlambda_k = sqrt53 cdot e^2pi ik5 quad k = 01234\n\nExplicitly:\n\nlambda_k = sqrt53 cdot left(cosfrac2pi k5 + isinfrac2pi k5right)\n\nKey: Cyclic Galois group → solvable by radicals, even though degree = 5.","category":"section"},{"location":"mathematical_background/#Further-Reading","page":"Mathematical Background","title":"Further Reading","text":"","category":"section"},{"location":"mathematical_background/#Classic-References","page":"Mathematical Background","title":"Classic References","text":"Galois Theory: \nStewart, I. (2015). Galois Theory (4th ed.). Chapman and Hall/CRC.\nMatrix Theory:\nHorn, R. A., & Johnson, C. R. (2012). Matrix Analysis (2nd ed.). Cambridge University Press.\nSpecial Matrices:\nDavis, P. J. (1979). Circulant Matrices (2nd ed.). AMS Chelsea Publishing.\nGroup Representation Theory:\nSerre, J.-P. (1977). Linear Representations of Finite Groups. Springer.\nFulton, W., & Harris, J. (1991). Representation Theory: A First Course. Springer.\nSpectral Graph Theory:\nGodsil, C., & Royle, G. (2001). Algebraic Graph Theory. Springer.\nBrouwer, A. E., & Haemers, W. H. (2012). Spectra of Graphs. Springer.","category":"section"},{"location":"mathematical_background/#Online-Resources","page":"Mathematical Background","title":"Online Resources","text":"Galois Theory Explained\nAbel-Ruffini Theorem\nCirculant Matrices\nKronecker Product\nRepresentation Theory\nDihedral Group\nStrongly Regular Graphs\nCharacter Tables","category":"section"},{"location":"mathematical_background/#Research-Papers","page":"Mathematical Background","title":"Research Papers","text":"For specific patterns implemented in this package, see references in notes/PATTERN_DISCOVERIES.md.","category":"section"},{"location":"contributing/#Contributing-to-SymbolicDiagonalization.jl","page":"Contributing","title":"Contributing to SymbolicDiagonalization.jl","text":"Thank you for your interest in contributing! This guide covers development setup, coding standards, testing requirements, and how to add new patterns.","category":"section"},{"location":"contributing/#Development-Setup","page":"Contributing","title":"Development Setup","text":"","category":"section"},{"location":"contributing/#Prerequisites","page":"Contributing","title":"Prerequisites","text":"Julia ≥1.6\nGit (if the project becomes a repository)\nRecommended: VSCode with Julia extension","category":"section"},{"location":"contributing/#Installation-for-Development","page":"Contributing","title":"Installation for Development","text":"# Clone or navigate to the package directory\ncd SymbolicDiagonalization.jl\n\n# Activate the project environment\njulia --project=.\n\n# Install dependencies\njulia> using Pkg\njulia> Pkg.instantiate()\n\n# Run tests to verify setup\njulia> Pkg.test()","category":"section"},{"location":"contributing/#Project-Structure","page":"Contributing","title":"Project Structure","text":"SymbolicDiagonalization.jl/\n├── src/\n│   ├── SymbolicDiagonalization.jl  # Main module\n│   ├── characteristic_poly.jl       # Bareiss determinant\n│   ├── root_solvers.jl              # Closed-form root formulas (1-4)\n│   ├── structure_detection.jl       # Pattern detection algorithms\n│   ├── special_patterns.jl          # Pattern-specific eigensolvers\n│   ├── eigenvectors.jl              # Nullspace computation\n│   └── utils.jl                     # Helper functions\n├── test/\n│   ├── runtests.jl                  # Test suite entry point\n│   ├── test_basic.jl                # Small matrix tests\n│   ├── test_structures.jl           # Pattern-specific tests\n│   └── test_edge_cases.jl           # Edge case coverage\n├── docs/\n│   ├── src/                         # Documentation source\n│   └── make.jl                      # Documentation builder\n└── examples/\n    └── explore_patterns.jl          # Interactive pattern exploration","category":"section"},{"location":"contributing/#Code-Style-Guidelines","page":"Contributing","title":"Code Style Guidelines","text":"","category":"section"},{"location":"contributing/#General-Principles","page":"Contributing","title":"General Principles","text":"Clarity over cleverness: Readable code is maintainable code\nType stability: Avoid type instabilities for performance\nDocument intent: Comments should explain why, not what\nFail fast: Use early error checks with clear messages","category":"section"},{"location":"contributing/#Naming-Conventions","page":"Contributing","title":"Naming Conventions","text":"Functions: snake_case (e.g., detect_block_diagonal)\nTypes: PascalCase (e.g., EigenPair)\nConstants: SCREAMING_SNAKE_CASE (e.g., MAX_ITERATIONS)\nPrivate functions: Prefix with _ (e.g., _compute_helper)","category":"section"},{"location":"contributing/#Code-Formatting","page":"Contributing","title":"Code Formatting","text":"# Good: Clear structure, well-documented\nfunction detect_circulant(A::AbstractMatrix{T}) where T\n    n = size(A, 1)\n    n == size(A, 2) || return false\n    \n    # Check if all rows are cyclic shifts of first row\n    for i in 2:n\n        for j in 1:n\n            if A[i, j] != A[1, mod1(j - i + 1, n)]\n                return false\n            end\n        end\n    end\n    return true\nend\n\n# Bad: Dense, unclear, no documentation\nfunction detect_circulant(A::AbstractMatrix{T}) where T;n=size(A,1);n==size(A,2)||return false;for i in 2:n;for j in 1:n;A[i,j]!=A[1,mod1(j-i+1,n)]&&return false;end;end;true;end","category":"section"},{"location":"contributing/#Documentation-Strings","page":"Contributing","title":"Documentation Strings","text":"Every exported function must have a docstring following this template:\n\n\"\"\"\n    function_name(arg1, arg2; kwarg1=default)\n\nBrief one-line description.\n\nExtended description with usage details, algorithm notes, and complexity.\n\n# Arguments\n- `arg1`: Description of arg1\n- `arg2`: Description of arg2\n\n# Keywords\n- `kwarg1`: Description and default value\n\n# Returns\nDescription of return value(s)\n\n# Examples\n\njulia julia> using SymbolicDiagonalization, Symbolics julia> @variables a b julia> result = function_name([a b; b a]) [a + b, a - b]\n\n\n# Complexity\nTime and space complexity analysis\n\n# References\n- [Author Year] Paper title, Journal/Conference\n\"\"\"\nfunction function_name(arg1, arg2; kwarg1=default)\n    # Implementation\nend","category":"section"},{"location":"contributing/#Testing-Requirements","page":"Contributing","title":"Testing Requirements","text":"","category":"section"},{"location":"contributing/#Test-Coverage-Standards","page":"Contributing","title":"Test Coverage Standards","text":"All new functions: Must have at least one test\nPattern detectors: Test true positives AND false negatives\nEigensolvers: Test correctness (Av = λv) and completeness (all eigenvalues found)\nEdge cases: Empty matrices, 1×1 matrices, repeated eigenvalues","category":"section"},{"location":"contributing/#Writing-Tests","page":"Contributing","title":"Writing Tests","text":"Use the @testset macro to organize tests:\n\n@testset \"Circulant Matrices\" begin\n    @testset \"Detection\" begin\n        # Test positive detection\n        @variables a b c\n        circ = [a b c; c a b; b c a]\n        @test detect_circulant(circ) == true\n        \n        # Test negative detection\n        non_circ = [a b c; c a b; a c b]\n        @test detect_circulant(non_circ) == false\n    end\n    \n    @testset \"Eigenvalues\" begin\n        # Test known eigenvalue formula\n        circ = [1 2 3; 3 1 2; 2 3 1]\n        λ = eigvals(circ)\n        \n        # Verify A*v = λ*v for each eigenvalue\n        for (i, val) in enumerate(λ)\n            v = eigvecs(circ)[:, i]\n            @test circ * v ≈ val * v atol=1e-10\n        end\n    end\n    \n    @testset \"Size Scaling\" begin\n        # Test pattern works for various sizes\n        for n in [3, 5, 7, 10]\n            A = circulant_matrix(n)\n            λ = eigvals(A)\n            @test length(λ) == n\n        end\n    end\nend","category":"section"},{"location":"contributing/#Running-Tests","page":"Contributing","title":"Running Tests","text":"# Run full test suite\njulia> using Pkg; Pkg.test()\n\n# Run specific test file\njulia> include(\"test/test_structures.jl\")\n\n# Run with coverage\njulia --code-coverage=user -e 'using Pkg; Pkg.test()'","category":"section"},{"location":"contributing/#Adding-New-Patterns","page":"Contributing","title":"Adding New Patterns","text":"Follow this 5-step process to add a new matrix pattern:","category":"section"},{"location":"contributing/#Step-1:-Detection-Function","page":"Contributing","title":"Step 1: Detection Function","text":"Create a detector in src/structure_detection.jl:\n\n\"\"\"\n    detect_my_pattern(A::AbstractMatrix) -> Bool\n\nDetect if matrix A has MyPattern structure.\n\nMyPattern is defined as [mathematical definition].\n\n# Complexity\nO(n²) - Checks all matrix entries\n\"\"\"\nfunction detect_my_pattern(A::AbstractMatrix{T}) where T\n    n = size(A, 1)\n    n == size(A, 2) || return false\n    \n    # Check pattern-specific properties\n    for i in 1:n, j in 1:n\n        # Pattern condition\n        if !condition(A[i,j])\n            return false\n        end\n    end\n    return true\nend","category":"section"},{"location":"contributing/#Step-2:-Eigensolver-Function","page":"Contributing","title":"Step 2: Eigensolver Function","text":"Create a solver in src/special_patterns.jl:\n\n\"\"\"\n    solve_my_pattern(A::AbstractMatrix; kwargs...) -> Vector\n\nCompute eigenvalues of MyPattern matrices using [algorithm name].\n\n# Algorithm\nBrief description of the algorithm and its basis (e.g., DFT, closed-form formula).\n\n# Complexity\n- Time: O(f(n))\n- Space: O(g(n))\n\n# References\n- [Author Year] Paper title\n\"\"\"\nfunction solve_my_pattern(A::AbstractMatrix{T}; kwargs...) where T\n    n = size(A, 1)\n    \n    # Extract pattern parameters\n    params = extract_parameters(A)\n    \n    # Compute eigenvalues using pattern-specific algorithm\n    eigenvalues = compute_eigenvalues(params)\n    \n    return eigenvalues\nend","category":"section"},{"location":"contributing/#Step-3:-Integration","page":"Contributing","title":"Step 3: Integration","text":"Add pattern to detection chain in src/structure_detection.jl:\n\nfunction detect_and_solve(A::AbstractMatrix; kwargs...)\n    # ... existing patterns ...\n    \n    # Add new pattern\n    if detect_my_pattern(A)\n        return solve_my_pattern(A; kwargs...)\n    end\n    \n    # ... fallback ...\nend","category":"section"},{"location":"contributing/#Step-4:-Testing","page":"Contributing","title":"Step 4: Testing","text":"Create comprehensive tests in test/test_structures.jl:\n\n@testset \"MyPattern Matrices\" begin\n    @testset \"Detection\" begin\n        # True positive\n        @variables a b\n        mat = construct_my_pattern(a, b)\n        @test detect_my_pattern(mat) == true\n        \n        # False negative\n        non_mat = [a b; b a]\n        @test detect_my_pattern(non_mat) == false\n    end\n    \n    @testset \"Known Eigenvalues\" begin\n        # Test with known theoretical eigenvalues\n        A = [concrete example]\n        λ = eigvals(A)\n        expected = [known eigenvalues]\n        @test sort(λ) ≈ sort(expected)\n    end\n    \n    @testset \"Eigenvector Verification\" begin\n        # Verify A*v = λ*v\n        A = construct_my_pattern(...)\n        E = eigen(A)\n        for i in 1:length(E.values)\n            @test A * E.vectors[:, i] ≈ E.values[i] * E.vectors[:, i]\n        end\n    end\n    \n    @testset \"Size Scaling\" begin\n        # Test multiple sizes\n        for n in [3, 5, 10, 20]\n            A = construct_my_pattern(n)\n            λ = eigvals(A)\n            @test length(λ) == n\n        end\n    end\nend","category":"section"},{"location":"contributing/#Step-5:-Documentation","page":"Contributing","title":"Step 5: Documentation","text":"Add pattern to docs/src/pattern_library.md:\n\n## MyPattern\n\n### Definition\nMathematical definition with notation.\n\n### Properties\n- Property 1\n- Property 2\n\n### Eigenvalue Formula\nClosed-form expression or algorithm description.\n\n### Example\n\\```julia\n@variables a b\nA = [matrix construction]\nλ = eigvals(A)\n# Result: [eigenvalues]\n\\```\n\n### Complexity\n- Detection: O(n²)\n- Eigenvalues: O(f(n))\n- Eigenvectors: O(g(n))\n\n### Implementation Details\nAlgorithm notes, numerical considerations, limitations.\n\n### References\n- [Author Year] Paper title","category":"section"},{"location":"contributing/#Pattern-Submission-Template","page":"Contributing","title":"Pattern Submission Template","text":"When proposing a new pattern, open an issue with:\n\n## Pattern Name: [Name]\n\n### Mathematical Definition\nLaTeX or clear description of the pattern\n\n### Eigenvalue Formula\nKnown closed-form formula or algorithm\n\n### Complexity\nExpected time/space complexity\n\n### References\nPapers or textbooks describing the pattern\n\n### Example\nConcrete example matrix and its eigenvalues\n\n### Implementation Notes\nAny special considerations (numerical stability, edge cases, etc.)","category":"section"},{"location":"contributing/#Git-Workflow-(When-Applicable)","page":"Contributing","title":"Git Workflow (When Applicable)","text":"If this project becomes a Git repository:","category":"section"},{"location":"contributing/#Branch-Naming","page":"Contributing","title":"Branch Naming","text":"feature/pattern-name - New pattern implementations\nfix/issue-description - Bug fixes\ndocs/topic - Documentation updates\nperf/optimization-area - Performance improvements","category":"section"},{"location":"contributing/#Commit-Messages","page":"Contributing","title":"Commit Messages","text":"Follow conventional commits:\n\ntype(scope): Brief description\n\nDetailed explanation of changes and motivation.\n\nFixes #issue-number\n\nTypes: feat, fix, docs, test, perf, refactor, style","category":"section"},{"location":"contributing/#Pull-Request-Process","page":"Contributing","title":"Pull Request Process","text":"Fork and branch from main\nImplement with tests and documentation\nRun tests - All must pass\nUpdate docs - Add examples and API references\nOpen PR with clear description\nAddress review comments\nSquash and merge when approved","category":"section"},{"location":"contributing/#Code-Review-Guidelines","page":"Contributing","title":"Code Review Guidelines","text":"","category":"section"},{"location":"contributing/#For-Reviewers","page":"Contributing","title":"For Reviewers","text":"Check correctness: Verify algorithm implementation against references\nTest coverage: Ensure all code paths are tested\nDocumentation: Confirm docstrings and examples are clear\nPerformance: Look for obvious inefficiencies\nStyle: Check adherence to guidelines","category":"section"},{"location":"contributing/#For-Authors","page":"Contributing","title":"For Authors","text":"Self-review first: Read your own changes critically\nRespond promptly: Address feedback quickly\nBe open: Accept constructive criticism gracefully\nTest thoroughly: Don't rely on reviewers to find bugs","category":"section"},{"location":"contributing/#Performance-Optimization-Guidelines","page":"Contributing","title":"Performance Optimization Guidelines","text":"","category":"section"},{"location":"contributing/#Profiling","page":"Contributing","title":"Profiling","text":"using Profile, ProfileView\n\n# Profile a function\n@profile eigvals(large_matrix)\nProfileView.view()\n\n# Benchmark with BenchmarkTools\nusing BenchmarkTools\n@benchmark eigvals($matrix)","category":"section"},{"location":"contributing/#Common-Optimizations","page":"Contributing","title":"Common Optimizations","text":"Avoid allocations: Use in-place operations where possible\nType stability: Ensure functions return consistent types\nLoop order: Access arrays in column-major order\nSIMD: Use @simd for vectorizable loops\nPreallocation: Allocate output arrays before loops","category":"section"},{"location":"contributing/#Example-Optimization","page":"Contributing","title":"Example Optimization","text":"# Slow: Allocates in loop\nfunction slow_transform(A)\n    result = []\n    for i in 1:size(A, 1)\n        push!(result, transform(A[i, :]))\n    end\n    return result\nend\n\n# Fast: Preallocated, type-stable\nfunction fast_transform(A::Matrix{T}) where T\n    n = size(A, 1)\n    result = Vector{T}(undef, n)\n    for i in 1:n\n        result[i] = transform(view(A, i, :))\n    end\n    return result\nend","category":"section"},{"location":"contributing/#Documentation-Building","page":"Contributing","title":"Documentation Building","text":"","category":"section"},{"location":"contributing/#Local-Documentation","page":"Contributing","title":"Local Documentation","text":"# Build documentation\njulia --project=docs docs/make.jl\n\n# View in browser with HTTP server (required for navigation links to work)\ncd docs\n./serve.sh\n# Then open http://localhost:8000","category":"section"},{"location":"contributing/#Documentation-Style","page":"Contributing","title":"Documentation Style","text":"Be concise: Short sentences, clear structure\nUse examples: Show, don't just tell\nLink references: Cross-reference related functions\nUpdate regularly: Keep docs in sync with code","category":"section"},{"location":"contributing/#CI/CD-Setup-for-GitHub","page":"Contributing","title":"CI/CD Setup for GitHub","text":"","category":"section"},{"location":"contributing/#Automatic-Documentation-Deployment","page":"Contributing","title":"Automatic Documentation Deployment","text":"The package includes GitHub Actions workflow for automatic documentation deployment to GitHub Pages.","category":"section"},{"location":"contributing/#Initial-Setup-(One-Time)","page":"Contributing","title":"Initial Setup (One-Time)","text":"1. Generate SSH Deploy Key\n\n# Install DocumenterTools if needed\njulia -e 'using Pkg; Pkg.add(\"DocumenterTools\")'\n\n# Generate deploy key\njulia -e 'using DocumenterTools; DocumenterTools.genkeys()'\n\nThis creates:\n\ndocs/src/.documenter (private key - do NOT commit)\nPublic key displayed in terminal\n\n2. Add Deploy Key to GitHub\n\nGo to your repository on GitHub\nNavigate to: Settings → Deploy keys → Add deploy key\nTitle: documenter-key\nKey: Paste the public key from step 1\n✅ Check \"Allow write access\"\nClick Add key\n\n3. Add Private Key as GitHub Secret\n\nCopy the contents of docs/src/.documenter (the private key file)\nGo to: Settings → Secrets and variables → Actions\nClick New repository secret\nName: DOCUMENTER_KEY\nValue: Paste the entire private key contents\nClick Add secret\n\n4. Update Repository URLs in docs/make.jl\n\nReplace YOUR_USERNAME with your GitHub username:\n\nrepo = \"https://github.com/YOUR_USERNAME/SymbolicDiagonalization.jl/blob/{commit}{path}#{line}\",\ncanonical = \"https://YOUR_USERNAME.github.io/SymbolicDiagonalization.jl\",\n\nAnd:\n\ndeploydocs(;\n    repo = \"github.com/YOUR_USERNAME/SymbolicDiagonalization.jl\",\n\n5. Enable GitHub Pages\n\nGo to: Settings → Pages\nSource: Deploy from a branch\nBranch: gh-pages / root\nClick Save","category":"section"},{"location":"contributing/#How-It-Works","page":"Contributing","title":"How It Works","text":"On push to main: Builds and deploys docs to gh-pages branch\nOn pull requests: Builds docs to verify they work (doesn't deploy)\nOn tags: Deploys versioned documentation\n\nYour documentation will be available at:\n\nhttps://YOUR_USERNAME.github.io/SymbolicDiagonalization.jl/","category":"section"},{"location":"contributing/#Testing-CI-Locally","page":"Contributing","title":"Testing CI Locally","text":"You can test that the CI build will work:\n\n# Simulate CI environment\nCI=true julia --project=docs -e '\n    using Pkg\n    Pkg.develop(PackageSpec(path=pwd()))\n    Pkg.instantiate()\n'\nCI=true julia --project=docs docs/make.jl","category":"section"},{"location":"contributing/#Troubleshooting","page":"Contributing","title":"Troubleshooting","text":"\"SSH key authentication failed\"\n\nEnsure DOCUMENTER_KEY secret contains the entire private key\nVerify deploy key has write access enabled\n\n\"gh-pages branch not found\"\n\nFirst deployment creates the branch automatically\nWait a few minutes after first push\n\n\"Documentation build failed\"\n\nCheck the Actions tab for error logs\nEnsure all dependencies are in docs/Project.toml\nTest locally with CI=true as shown above\n\n\"Pages not updating\"\n\nCheck GitHub Pages is enabled and pointing to gh-pages\nMay take 5-10 minutes for changes to appear\nCheck Pages build status in Actions tab","category":"section"},{"location":"contributing/#Getting-Help","page":"Contributing","title":"Getting Help","text":"","category":"section"},{"location":"contributing/#Resources","page":"Contributing","title":"Resources","text":"Julia Discourse: https://discourse.julialang.org/\nJulia Slack: Get invited at https://julialang.org/slack/\nSymbolics.jl Docs: https://symbolics.juliasymbolics.org/","category":"section"},{"location":"contributing/#Questions?","page":"Contributing","title":"Questions?","text":"Open an issue with:\n\nClear description of the problem\nMinimal reproducible example\nJulia version and package versions (Pkg.status())\nExpected vs actual behavior","category":"section"},{"location":"contributing/#License","page":"Contributing","title":"License","text":"Contributions are assumed to be licensed under the same license as the package (MIT).\n\nBy contributing, you agree that your contributions will be licensed under the MIT License.\n\n\n\nThank you for contributing to SymbolicDiagonalization.jl!","category":"section"},{"location":"user_guide/#User-Guide","page":"User Guide","title":"User Guide","text":"Practical guide to using SymbolicDiagonalization.jl effectively.","category":"section"},{"location":"user_guide/#Table-of-Contents","page":"User Guide","title":"Table of Contents","text":"Getting Started\nBasic Workflows\nWorking with Special Patterns\nPerformance Optimization\nTroubleshooting\nAdvanced Usage\n\n","category":"section"},{"location":"user_guide/#Getting-Started","page":"User Guide","title":"Getting Started","text":"","category":"section"},{"location":"user_guide/#Installation","page":"User Guide","title":"Installation","text":"# From package directory\ncd SymbolicDiagonalization.jl\njulia --project -e 'using Pkg; Pkg.instantiate()'","category":"section"},{"location":"user_guide/#Basic-Setup","page":"User Guide","title":"Basic Setup","text":"using Symbolics\nusing SymbolicDiagonalization\nusing LinearAlgebra\n\n# Define symbolic variables\n@variables a b c d\n\n# Create a matrix\nM = [a b; b a]\n\n# Compute eigenvalues\nλ = eigvals(M)  # [a+b, a-b]","category":"section"},{"location":"user_guide/#Quick-Reference","page":"User Guide","title":"Quick Reference","text":"# Eigenvalues only (fast)\nλ = eigvals(A)\n\n# Eigenvalues + eigenvectors\nE = eigen(A)\nE.values    # eigenvalues\nE.vectors   # eigenvectors as columns\n\n# With options\nλ = eigvals(A, structure=:hermitian, timeout=60)\n\n","category":"section"},{"location":"user_guide/#Basic-Workflows","page":"User Guide","title":"Basic Workflows","text":"","category":"section"},{"location":"user_guide/#Workflow-1:-Analyze-Small-Matrices-(-44)","page":"User Guide","title":"Workflow 1: Analyze Small Matrices (≤ 4×4)","text":"When to use: You have a symbolic matrix up to 4×4 and need exact eigenvalues.\n\nSteps:\n\n@variables a b c d\n\n# Create your matrix\nM = [a  b  0  0;\n     b  a  0  0;\n     0  0  c  d;\n     0  0  d  c]\n\n# Get eigenvalues (structure auto-detected)\nλ = eigvals(M)\n# Output: [a+b, a-b, c+d, c-d]\n\n# Get eigenvectors too\nE = eigen(M)\n\nTips:\n\nMatrices ≤ 3×3 compute quickly\n4×4 may be slow for fully symbolic (use structure!)\nAdd structure when possible (zeros, blocks)\n\n","category":"section"},{"location":"user_guide/#Workflow-2:-Block-Diagonal-Matrices","page":"User Guide","title":"Workflow 2: Block-Diagonal Matrices","text":"When to use: Your matrix has block structure with zeros off the blocks.\n\nSteps:\n\n# Large matrix with block structure\n@variables a b c d e f\n\nM = [a  b  0  0  0  0;\n     b  a  0  0  0  0;\n     0  0  c  d  0  0;\n     0  0  d  c  0  0;\n     0  0  0  0  e  f;\n     0  0  0  0  f  e]\n\n# Automatic block detection\nλ = eigvals(M)\n# Solves three 2×2 blocks independently\n\nWhy this is fast: 6×6 would normally require degree-6 polynomial (impossible), but block structure reduces to three quadratics.\n\nHow to recognize: Look for zero-blocks separating independent subsystems.\n\n","category":"section"},{"location":"user_guide/#Workflow-3:-Circulant-Matrices","page":"User Guide","title":"Workflow 3: Circulant Matrices","text":"When to use: Each row is a cyclic shift of the previous row.\n\nSteps:\n\n@variables a b c d\n\n# 4×4 circulant\nC = [a b c d;\n     d a b c;\n     c d a b;\n     b c d a]\n\n# DFT-based closed form (works for ANY size!)\nλ = eigvals(C)\n\nPattern recognition:\n\nRow 1: [a b c d]\nRow 2: [d a b c]  ← shift right by 1\nRow 3: [c d a b]  ← shift right by 2\nRow 4: [b c d a]  ← shift right by 3\n\nWorks for huge matrices: Even 100×100 circulant has closed form!\n\n","category":"section"},{"location":"user_guide/#Workflow-4:-Tridiagonal-Matrices","page":"User Guide","title":"Workflow 4: Tridiagonal Matrices","text":"When to use: Matrix is tridiagonal with constant diagonals.\n\nSteps:\n\n@variables a b\n\n# Symmetric Toeplitz tridiagonal\nn = 5\nT = diagm(0 => fill(a, n), \n          1 => fill(b, n-1),\n         -1 => fill(b, n-1))\n\n# Closed-form via cosines\nλ = eigvals(T)\n# λₖ = a + 2b·cos(kπ/(n+1)) for k=1,...,n\n\nPattern recognition:\n\nAll diagonal entries the same: a\nAll super-diagonal the same: b\nAll sub-diagonal the same: b\nSymmetric\n\n","category":"section"},{"location":"user_guide/#Workflow-5:-Kronecker-Products","page":"User Guide","title":"Workflow 5: Kronecker Products","text":"When to use: Matrix is a tensor product A ⊗ B.\n\nSteps:\n\n@variables a b c d\n\n# Two small matrices\nA = [a 0; 0 b]  # 2×2\nB = [c 0; 0 d]  # 2×2\n\n# Kronecker product (4×4)\nK = kron(A, B)\n\n# Eigenvalues are products\nλ = eigvals(K)\n# [ac, ad, bc, bd]\n\nWhy this works: 4×4 is manageable, but what if A and B were larger?\n\nExample: 6×6 = (2×2) ⊗ (3×3)\n\nA = [a b; b a]          # 2×2, eigenvalues {a+b, a-b}\nB = [c d 0; d c d; 0 d c]  # 3×3, eigenvalues computed via cubic\n\nK = kron(A, B)  # 6×6 matrix\n\nλ = eigvals(K)\n# Computes eigenvalues of A and B separately\n# Then forms all products λᵢ(A) · λⱼ(B)\n\nWithout Kronecker structure, degree-6 polynomial is impossible!\n\n","category":"section"},{"location":"user_guide/#Working-with-Special-Patterns","page":"User Guide","title":"Working with Special Patterns","text":"","category":"section"},{"location":"user_guide/#Hermitian-Matrices","page":"User Guide","title":"Hermitian Matrices","text":"@variables a::Real b::Real\n\n# Hermitian matrix (complex conjugate symmetric)\nH = [a b; conj(b) a]\n\n# Hint that it's Hermitian for optimizations\nλ = eigvals(H, structure=:hermitian)\n\nProperties:\n\nAlways real eigenvalues\nOrthogonal eigenvectors\nDiagonalizable\n\n","category":"section"},{"location":"user_guide/#Permutation-Matrices","page":"User Guide","title":"Permutation Matrices","text":"# 5×5 permutation: (1→2→3→1), (4↔5)\nP = [0 1 0 0 0;   # 1→2\n     0 0 1 0 0;   # 2→3\n     1 0 0 0 0;   # 3→1\n     0 0 0 0 1;   # 4→5\n     0 0 0 1 0]   # 5→4\n\nλ = eigvals(P)\n# 3-cycle: {1, ω, ω²} where ω = exp(2πi/3)\n# 2-cycle: {1, -1}\n# Total: {1, 1, 1, -1, ω, ω²}\n\nKey insight: All eigenvalues are roots of unity (magnitude 1).\n\n","category":"section"},{"location":"user_guide/#Anti-Diagonal-Matrices","page":"User Guide","title":"Anti-Diagonal Matrices","text":"@variables a b c\n\n# 5×5 anti-diagonal\nA = [0 0 0 0 a;\n     0 0 0 b 0;\n     0 0 c 0 0;\n     0 b 0 0 0;\n     a 0 0 0 0]\n\nλ = eigvals(A)\n# {c, ±a, ±b}\n\nPattern: Eigenvalues come in ±pairs (except center for odd n).\n\n","category":"section"},{"location":"user_guide/#Performance-Optimization","page":"User Guide","title":"Performance Optimization","text":"","category":"section"},{"location":"user_guide/#Tip-1:-Use-Structure-Hints","page":"User Guide","title":"Tip 1: Use Structure Hints","text":"# Without hint (may be slower)\nλ₁ = eigvals(M)\n\n# With hint (faster)\nλ₂ = eigvals(M, structure=:hermitian)\n\nWhen to use:\n\n:hermitian - Hermitian matrices\n:symmetric - Real symmetric\n:unitary - Unitary matrices\n:general - No assumptions\n\n","category":"section"},{"location":"user_guide/#Tip-2:-Eigenvalues-Only","page":"User Guide","title":"Tip 2: Eigenvalues Only","text":"# Slow: computes eigenvectors\nE = eigen(M)\nλ = E.values\n\n# Fast: eigenvalues only\nλ = eigvals(M)\n\nSpeedup: 2-5x for medium matrices, more for large ones.\n\n","category":"section"},{"location":"user_guide/#Tip-3:-Partial-Substitution","page":"User Guide","title":"Tip 3: Partial Substitution","text":"If your matrix has many symbolic variables but some can be numeric:\n\n@variables a b c d e f g h\n\n# Fully symbolic 4×4 (slow, huge expressions)\nM = [a b c d; e f g h; ...]\n\n# Substitute some variables\nusing Symbolics: substitute\nM_partial = substitute(M, Dict(\n    c => 0, d => 0,  # Add structure with zeros\n    e => 0, g => 0\n))\n\n# Now much faster\nλ = eigvals(M_partial)\n\n","category":"section"},{"location":"user_guide/#Tip-4:-Increase-Timeout-for-Complex-Matrices","page":"User Guide","title":"Tip 4: Increase Timeout for Complex Matrices","text":"# Default timeout: 300 seconds\nλ = eigvals(M)\n\n# Allow more time\nλ = eigvals(M, timeout=600)\n\n","category":"section"},{"location":"user_guide/#Tip-5:-Simplify-Results","page":"User Guide","title":"Tip 5: Simplify Results","text":"using Symbolics: simplify\n\nλ = eigvals(M)\n\n# Simplify expressions\nλ_simple = simplify.(λ)\n\n","category":"section"},{"location":"user_guide/#Troubleshooting","page":"User Guide","title":"Troubleshooting","text":"","category":"section"},{"location":"user_guide/#Problem:-\"Cannot-solve-degree-n-5-without-structure\"","page":"User Guide","title":"Problem: \"Cannot solve degree n ≥ 5 without structure\"","text":"Cause: Matrix is 5×5+ with no detected structure.\n\nSolutions:\n\nCheck for block structure:\n\n# Add zeros to create blocks\nM_blocked = [A zeros(2,2); zeros(3,2) B]\n\nLook for special patterns: Is it circulant? Tridiagonal? Kronecker product?\nUse numeric substitution:\n\n# Substitute some variables with numbers\nM_numeric = substitute(M, Dict(a => 1, b => 2))\n\nUse numerical methods:\n\n# Convert to Float64 and solve numerically\nM_float = Float64.(substitute(M, Dict(...)))\nλ_numeric = eigvals(M_float)  # Standard LinearAlgebra\n\n","category":"section"},{"location":"user_guide/#Problem:-Expression-Complexity-Error","page":"User Guide","title":"Problem: Expression Complexity Error","text":"Cause: Expressions exceed max_terms limit (default 10,000).\n\nSolutions:\n\nIncrease limit (watch memory!):\n\nλ = eigvals(M, max_terms=50000)\n\nAdd structure:\n\n# Replace off-block elements with zeros\nM_sparse = ...\n\nUse expand=false:\n\nλ = eigvals(M, expand=false)\n\n","category":"section"},{"location":"user_guide/#Problem:-Computation-Timeout","page":"User Guide","title":"Problem: Computation Timeout","text":"Cause: Exceeded time limit (default 300s).\n\nSolutions:\n\nIncrease timeout:\n\nλ = eigvals(M, timeout=900)  # 15 minutes\n\nSimplify matrix:\n\n# Use fewer variables\n# Add structure (zeros, blocks)\n# Partial numeric substitution\n\nCheck matrix size: 4×4 fully symbolic takes ~minutes. 5×5+ may be impossible.\n\n","category":"section"},{"location":"user_guide/#Problem:-Wrong-Eigenvalues","page":"User Guide","title":"Problem: Wrong Eigenvalues","text":"Cause: Incorrect structure hint or numerical issues.\n\nSolutions:\n\nRemove structure hint:\n\nλ = eigvals(M)  # Auto-detect\n\nVerify numerically:\n\n# Substitute numeric values\nM_test = substitute(M, Dict(a=>1, b=>2, c=>3))\nλ_numeric = eigvals(M_test)\n\n# Check against symbolic\nλ_sym = eigvals(M)\nλ_sym_test = substitute.(λ_sym, Ref(Dict(a=>1, b=>2, c=>3)))\n\n# Compare\n@assert isapprox(sort(λ_numeric), sort(λ_sym_test))\n\n","category":"section"},{"location":"user_guide/#Problem:-Expression-Too-Large-(Memory-Issues)","page":"User Guide","title":"Problem: Expression Too Large (Memory Issues)","text":"Cause: Quartic formula on fully symbolic 4×4 produces ~13.5 MB per eigenvalue.\n\nSolutions:\n\nDon't use fully symbolic 4×4: Add structure!\nPartial substitution:\n\nM_partial = substitute(M, Dict(\n    # Set some entries to simple values\n    M[1,3] => 0,\n    M[1,4] => 0,\n    M[2,4] => 0\n))\n\nUse block structure:\n\n# Instead of 4×4, use 2×2 blocks\nM = [A zeros(2,2); zeros(2,2) B]\n\n","category":"section"},{"location":"user_guide/#Advanced-Usage","page":"User Guide","title":"Advanced Usage","text":"","category":"section"},{"location":"user_guide/#Custom-Eigenvalue-Variables","page":"User Guide","title":"Custom Eigenvalue Variables","text":"@variables λ a b\n\nM = [a b; b a]\n\n# Use specific variable name\nvals, poly, λ_var = symbolic_eigenvalues(M, var=λ)\n\n","category":"section"},{"location":"user_guide/#Characteristic-Polynomial-Only","page":"User Guide","title":"Characteristic Polynomial Only","text":"M = [a b; b a]\n\npoly, coeffs, λ = characteristic_polynomial(M)\n# poly: λ² - 2a·λ + (a² - b²)\n# coeffs: [a² - b², -2a, 1]\n\n","category":"section"},{"location":"user_guide/#Eigenpairs-with-Multiplicity","page":"User Guide","title":"Eigenpairs with Multiplicity","text":"M = [a 0 0; 0 a 1; 0 0 a]  # Jordan block\n\npairs = symbolic_eigenpairs(M)\n# [(a, [v₁, v₂, ...])]  # May have multiple eigenvectors\n\n","category":"section"},{"location":"user_guide/#Verification","page":"User Guide","title":"Verification","text":"P, D, pairs = symbolic_diagonalize(M)\n\n# Verify: M = P * D * P⁻¹\nusing Symbolics: simplify\nerr = simplify.(M - P * D * inv(P))\n@assert all(iszero, err)\n\n","category":"section"},{"location":"user_guide/#Mixed-Numeric-Symbolic","page":"User Guide","title":"Mixed Numeric-Symbolic","text":"# Some entries numeric, some symbolic\n@variables a b\n\nM = [a   1.5  0   0;\n     1.5 b    0   0;\n     0   0    2.0 1.0;\n     0   0    1.0 3.0]\n\nλ = eigvals(M)  # Works fine!\n\n","category":"section"},{"location":"user_guide/#Practical-Examples","page":"User Guide","title":"Practical Examples","text":"","category":"section"},{"location":"user_guide/#Example-1:-Vibrating-String","page":"User Guide","title":"Example 1: Vibrating String","text":"Discrete model of vibrating string with n masses:\n\n@variables k m ω\n\nn = 5\n# Stiffness matrix (tridiagonal)\nK = diagm(0 => fill(2k, n),\n          1 => fill(-k, n-1),\n         -1 => fill(-k, n-1))\n\n# Eigenfrequencies: ω² = λ/m\nλ = eigvals(K)\nω_squared = λ ./ m\n\n# ωₖ = √(λₖ/m) = √(k/m) · √(4sin²(kπ/(2(n+1))))\n\n","category":"section"},{"location":"user_guide/#Example-2:-Quantum-Tight-Binding-Model","page":"User Guide","title":"Example 2: Quantum Tight-Binding Model","text":"1D tight-binding Hamiltonian:\n\n@variables t ε\n\nn = 4\nH = diagm(0 => fill(ε, n),\n          1 => fill(-t, n-1),\n         -1 => fill(-t, n-1))\n\n# Energy eigenvalues\nE = eigvals(H)\n# Eₖ = ε - 2t·cos(kπ/(n+1))\n\n","category":"section"},{"location":"user_guide/#Example-3:-Graph-Laplacian-(Cycle)","page":"User Guide","title":"Example 3: Graph Laplacian (Cycle)","text":"Laplacian of cycle graph Cₙ:\n\n@variables d\n\nn = 6\n# Cycle graph Laplacian (circulant!)\nL = [2d -d  0   0  0  -d;\n     -d 2d -d   0  0   0;\n      0 -d 2d  -d  0   0;\n      0  0 -d  2d -d   0;\n      0  0  0  -d 2d  -d;\n     -d  0  0   0 -d  2d]\n\n# Eigenvalues via circulant formula\nλ = eigvals(L)\n# λₖ = 2d(1 - cos(2πk/n)) for k=0,...,n-1\n\n","category":"section"},{"location":"user_guide/#Example-4:-Coupled-Oscillators","page":"User Guide","title":"Example 4: Coupled Oscillators","text":"Two coupled 2D oscillators:\n\n@variables k₁ k₂ κ m\n\n# Each oscillator: 2×2 block\nA = [k₁ 0; 0 k₁] / m\nB = [k₂ 0; 0 k₂] / m\n\n# Coupling\nC = [κ 0; 0 κ] / m\n\n# Full system (4×4)\nM = [A C; C B]\n\n# If κ=0: decoupled (block-diagonal)\n# If κ≠0: analyze coupled system\n\nλ = eigvals(M)\n\n","category":"section"},{"location":"user_guide/#Next-Steps","page":"User Guide","title":"Next Steps","text":"API Reference - Complete function documentation\nPattern Library - All special patterns\nMathematical Background - Theory\nImplementation - Algorithm details\nContributing - How to add new patterns\n\n","category":"section"},{"location":"user_guide/#Getting-Help","page":"User Guide","title":"Getting Help","text":"Check documentation: API reference, pattern library\nVerify numerically: Test with numeric values first\nSimplify problem: Remove variables, add structure\nReport issues: GitHub issues with minimal reproducible example","category":"section"},{"location":"pattern_library/#Pattern-Library","page":"Pattern Library","title":"Pattern Library","text":"Complete catalog of all special matrix patterns with closed-form eigenvalue solutions implemented in SymbolicDiagonalization.jl.","category":"section"},{"location":"pattern_library/#Table-of-Contents","page":"Pattern Library","title":"Table of Contents","text":"Basic Patterns\nDiagonal Matrices\nTriangular Matrices\nJordan Blocks\nStructure-Based Patterns\nBlock-Diagonal\nPersymmetric\nSymmetry-Based Patterns\nCirculant Matrices\nBlock Circulant\nAnti-Diagonal\nTensor Product Patterns\nKronecker Products\nTridiagonal Patterns\nSymmetric Toeplitz Tridiagonal\nSpecial 5×5 Patterns\nPermutation Patterns\nPermutation Matrices\n\n","category":"section"},{"location":"pattern_library/#Basic-Patterns","page":"Pattern Library","title":"Basic Patterns","text":"","category":"section"},{"location":"pattern_library/#Diagonal-Matrices","page":"Pattern Library","title":"Diagonal Matrices","text":"Structure: Non-zero only on main diagonal\n\nMatrix Form:\n\nmathbfD = beginbmatrix\nd_1  0  0  cdots  0 \n0  d_2  0  cdots  0 \n0  0  d_3  cdots  0 \nvdots  vdots  vdots  ddots  vdots \n0  0  0  cdots  d_n\nendbmatrix\n\nEigenvalues: d_1 d_2 d_3 ldots d_n (diagonal entries)\n\nEigenvectors: Standard basis vectors mathbfe_i\n\nComplexity: O(n) - direct reading\n\nExample:\n\n@variables a b c\nD = [a 0 0; 0 b 0; 0 0 c]\n\neigvals(D)  # [a, b, c]\n\nWhy this works: Diagonal matrices are already in eigenvalue form. The eigenvalue equation mathbfDmathbfv = lambdamathbfv is satisfied by standard basis vectors.\n\nMathematical properties:\n\nAlways diagonalizable\nEigenvectors are orthogonal\nSimple eigenvalue structure\n\n","category":"section"},{"location":"pattern_library/#Triangular-Matrices","page":"Pattern Library","title":"Triangular Matrices","text":"Structure: Upper or lower triangular (zeros below or above diagonal)\n\nUpper Triangular Form:\n\nmathbfU = beginbmatrix\nu_11  u_12  u_13  cdots  u_1n \n0  u_22  u_23  cdots  u_2n \n0  0  u_33  cdots  u_3n \nvdots  vdots  vdots  ddots  vdots \n0  0  0  cdots  u_nn\nendbmatrix\n\nEigenvalues: u_11 u_22 u_33 ldots u_nn (diagonal entries)\n\nEigenvectors: Computed via back-substitution\n\nComplexity: O(n) for eigenvalues, O(n^2) for eigenvectors\n\nExample:\n\n@variables a b c\nU = [a 1 2; 0 b 3; 0 0 c]\n\neigvals(U)  # [a, b, c]\n\nWhy this works: For triangular matrices, det(lambdamathbfI - mathbfU) is a product of diagonal terms (lambda - u_ii), so eigenvalues are exactly the diagonal entries.\n\nMathematical properties:\n\nMay not be diagonalizable (if repeated eigenvalues)\nEigenvalues independent of off-diagonal entries\nCharacteristic polynomial factorizes immediately\n\n","category":"section"},{"location":"pattern_library/#Jordan-Blocks","page":"Pattern Library","title":"Jordan Blocks","text":"Structure: Single repeated eigenvalue on diagonal, ones on superdiagonal\n\nMatrix Form:\n\nmathbfJ(lambda n) = beginbmatrix\nlambda  1  0  cdots  0 \n0  lambda  1  cdots  0 \n0  0  lambda  cdots  0 \nvdots  vdots  vdots  ddots  vdots \n0  0  0  cdots  lambda\nendbmatrix\n\nEigenvalues: lambda with algebraic multiplicity n\n\nEigenvectors: Only ONE eigenvector (not diagonalizable for n  1)\n\nComplexity: O(1) for eigenvalues\n\nExample:\n\n@variables λ\nJ = [λ 1 0; 0 λ 1; 0 0 λ]\n\neigvals(J)  # [λ, λ, λ]\n\nWhy this works: det(tmathbfI - mathbfJ) = (t - lambda)^n, giving repeated root lambda. Geometric multiplicity is 1 (rank deficiency).\n\nMathematical properties:\n\nNot diagonalizable (unless n = 1)\nPrototype of non-diagonalizable matrices\nAppears in Jordan normal form decomposition\n\nCaution: symbolic_diagonalize() will throw error since Jordan blocks (n  1) are not diagonalizable.\n\n","category":"section"},{"location":"pattern_library/#Structure-Based-Patterns","page":"Pattern Library","title":"Structure-Based Patterns","text":"","category":"section"},{"location":"pattern_library/#Block-Diagonal-Matrices","page":"Pattern Library","title":"Block-Diagonal Matrices","text":"Structure: Non-zero only in diagonal blocks\n\nMatrix Form:\n\nmathbfB = beginbmatrix\nmathbfA_1  mathbf0  mathbf0  cdots  mathbf0 \nmathbf0  mathbfA_2  mathbf0  cdots  mathbf0 \nmathbf0  mathbf0  mathbfA_3  cdots  mathbf0 \nvdots  vdots  vdots  ddots  vdots \nmathbf0  mathbf0  mathbf0  cdots  mathbfA_k\nendbmatrix\n\nwhere each mathbfA_i is a square matrix (possibly different sizes).\n\nEigenvalues: lambda(mathbfB) = lambda(mathbfA_1) cup lambda(mathbfA_2) cup cdots cup lambda(mathbfA_k)\n\nComplexity: O(sum_i f(n_i)) where f(n) is cost to solve size-n block\n\nExample:\n\n@variables a b c d\nB = [a  b  0  0;\n     b  a  0  0;\n     0  0  c  d;\n     0  0  d  c]\n\neigvals(B)  # [a+b, a-b, c+d, c-d]\n\nWhy this works: The characteristic polynomial factorizes:\n\ndet(lambdamathbfI - mathbfB) = det(lambdamathbfI - mathbfA_1) cdot det(lambdamathbfI - mathbfA_2) cdot ldots cdot det(lambdamathbfI - mathbfA_k)\n\nSo eigenvalues are union of eigenvalues of each block.\n\nDetection algorithm:\n\nFind connected components of non-zero structure\nRecursively solve each block independently\nConcatenate eigenvalues\n\nPractical importance: An 8 times 8 matrix with four 2 times 2 blocks requires solving 4 quadratics, not one degree-8 polynomial!\n\nMathematical properties:\n\nDiagonalizable iff all blocks are diagonalizable\nEigenvectors are block-structured\nExtremely common in practice (physical subsystems, symmetry blocks)\n\n","category":"section"},{"location":"pattern_library/#Persymmetric-Matrices","page":"Pattern Library","title":"Persymmetric Matrices","text":"Structure: Symmetric about anti-diagonal: Qij = Qn+1-j n+1-i\n\nMatrix Form (4 times 4 example):\n\nmathbfP = beginbmatrix\na  b  c  d \nb  e  f  c \nc  f  e  b \nd  c  b  a\nendbmatrix\n\nEigenvalues: Computed by splitting into half-sized problems\n\nComplexity: O(f(n2)) where f is cost for size n2\n\nExample:\n\n@variables a b c d e f\nP = [a b c d; b e f c; c f e b; d c b a]\n\neigvals(P)  # Splits into two 2×2 problems\n\nWhy this works: Persymmetric structure allows transformation:\n\nmathbfQ = mathbfJ mathbfP mathbfJ quad text(where  mathbfJ text is anti-diagonal identity)\n\nThis creates block structure in eigenvector space, splitting problem in half.\n\nTransformation details:\n\nLet mathbfJ be the flip matrix (anti-diagonal identity)\nForm symmetric combinations: (mathbfP pm mathbfJPJ)2\nThese commute and can be simultaneously diagonalized\nReduces to two half-sized eigenvalue problems\n\nDetection: Check if Qij = Qn+1-j n+1-i for all ij\n\nMathematical properties:\n\nAlways diagonalizable (if symmetric)\nEigenspaces split into symmetric/antisymmetric subspaces\nOften appears in signal processing, centrosymmetric matrices\n\nLimitation: Current implementation handles some but not all persymmetric cases.\n\n","category":"section"},{"location":"pattern_library/#Symmetry-Based-Patterns","page":"Pattern Library","title":"Symmetry-Based Patterns","text":"","category":"section"},{"location":"pattern_library/#Circulant-Matrices","page":"Pattern Library","title":"Circulant Matrices","text":"Structure: Each row is cyclic shift of previous row\n\nMatrix Form:\n\nmathbfC = beginbmatrix\nc_0  c_1  c_2  cdots  c_n-1 \nc_n-1  c_0  c_1  cdots  c_n-2 \nc_n-2  c_n-1  c_0  cdots  c_n-3 \nvdots  vdots  vdots  ddots  vdots \nc_1  c_2  c_3  cdots  c_0\nendbmatrix\n\nEigenvalues (closed-form for any n):\n\nlambda_k = sum_j=0^n-1 c_j cdot omega^kj quad textfor  k = 0 1 ldots n-1\n\nwhere omega = exp(2pi in) is the nth root of unity.\n\nEigenvectors: Columns of DFT matrix (independent of entries!)\n\nComplexity: O(n) to compute all n eigenvalues\n\nExample (3 times 3):\n\n@variables a b c\nC = [a b c; c a b; b c a]\n\n# ω = exp(2πi/3)\neigvals(C)  # [a+b+c, a+b*ω+c*ω², a+b*ω²+c*ω]\n\nWhy this works: Circulant matrices commute with cyclic shifts. The DFT diagonalizes ALL circulant matrices simultaneously. The eigenvalues are exactly the Discrete Fourier Transform of the first row.\n\nMathematical foundation:\n\nCirculant matrices form a commutative algebra\nAll share the same eigenvectors (DFT basis)\nMultiplication in circulant space = convolution in sequence space\nDiagonalization in DFT space = pointwise multiplication\n\nDetection algorithm:\n\nCheck if Cij = C(i-1) bmod n (j-1) bmod n for all ij\nExtract first row c_0 c_1 ldots c_n-1\nApply DFT formula\n\nApplications:\n\nSignal processing (circular convolution)\nTime series analysis (periodic processes)\nGraph Laplacians (cycle graphs)\nCoding theory\n\nPractical notes:\n\nWorks for ANY size n (even n = 100+!)\nGeneric n times n requires degree-n polynomial (impossible for n geq 5)\nCirculant structure bypasses Abel-Ruffini limitation\n\nVariants:\n\nSkew-circulant: Last element negated on each shift\ng-circulant: Generalized with group operation\nBlock circulant: See next section\n\n","category":"section"},{"location":"pattern_library/#Block-Circulant-Matrices","page":"Pattern Library","title":"Block Circulant Matrices","text":"Structure: Block version of circulant (blocks shift instead of elements)\n\nMatrix Form (4 blocks, size k times k each):\n\nmathbfBC = beginbmatrix\nmathbfA_0  mathbfA_1  mathbfA_2  mathbfA_3 \nmathbfA_3  mathbfA_0  mathbfA_1  mathbfA_2 \nmathbfA_2  mathbfA_3  mathbfA_0  mathbfA_1 \nmathbfA_1  mathbfA_2  mathbfA_3  mathbfA_0\nendbmatrix\n\nEigenvalues: Compute by solving n eigenvalue problems of size k times k:\n\nlambda(mathbfBC) = bigcup_m=0^n-1 lambdaleft(sum_j=0^n-1 mathbfA_j cdot omega^mjright)\n\nwhere omega = exp(2pi in).\n\nComplexity: O(n cdot f(k)) where f(k) is cost for k times k matrix\n\nExample (4 times 4 with 2 times 2 blocks):\n\n@variables a b c d\nA = [a b; c d]\nB = [1 0; 0 1]\n\n# 4×4 block circulant [A B; B A]\nBC = [a b 1 0;\n      c d 0 1;\n      1 0 a b;\n      0 1 c d]\n\neigvals(BC)  # Solves 2 problems of size 2×2\n\nWhy this works: Block circulant matrices are diagonalized by block DFT. The reduction formula creates n different k times k matrices (linear combinations of blocks with DFT coefficients), which can be solved independently.\n\nMathematical foundation:\n\nGeneralization of circulant to matrix entries\nBlock DFT plays same role as regular DFT\nEigenvalue problem decouples into n independent k times k problems\n\nDetection algorithm:\n\nCheck block structure (equal-sized blocks)\nVerify block circulant property\nExtract blocks mathbfA_0 mathbfA_1 ldots mathbfA_n-1\nForm n combinations with DFT weights\nSolve each k times k system\n\nKey examples:\n\n12 times 12 with 3 times 3 blocks: 4 blocks → solve 4 cubic equations (feasible)\n8 times 8 with 4 times 4 blocks: 2 blocks → solve 2 quartic equations (feasible but large)\n16 times 16 with 2 times 2 blocks: 8 blocks → solve 8 quadratic equations (easy)\n\nWithout block structure, these would require degree-12, degree-8, and degree-16 polynomials (impossible)!\n\nApplications:\n\nMulti-channel signal processing\nBlock Toeplitz systems\nVectorized circulant operations\nKronecker-structured problems\n\nLimitation: Requires k leq 4 for closed form (unless further structure in blocks).\n\n","category":"section"},{"location":"pattern_library/#Anti-Diagonal-Matrices","page":"Pattern Library","title":"Anti-Diagonal Matrices","text":"Structure: Non-zero only on anti-diagonal, with symmetry\n\nMatrix Form (n times n, symmetric about anti-diagonal):\n\nmathbfA = beginbmatrix\n0  0  0  cdots  0  a_n \n0  0  0  cdots  a_n-1  0 \n0  0  0  cdots  0  0 \nvdots  vdots  vdots  ddots  vdots  vdots \na_n-1  0  0  cdots  0  0 \na_n  0  0  cdots  0  0\nendbmatrix\n\nwith symmetry: Aij = An+1-j n+1-i\n\nEigenvalues (closed-form for any n):\n\nOdd n: a_k -a_k for k = 1 ldots (n-1)2, plus a_(n+1)2 (center element)\nEven n: a_k -a_k for k = 1 ldots n2\n\nEigenvector structure: pm pairs with specific symmetry\n\nComplexity: O(n) - direct computation\n\nExample (5 times 5):\n\n@variables a b c\nA = [0 0 0 0 a;\n     0 0 0 b 0;\n     0 0 c 0 0;\n     0 b 0 0 0;\n     a 0 0 0 0]\n\neigvals(A)  # {c, ±a, ±b}\n\nWhy this works: The persymmetric symmetry combined with anti-diagonal structure forces eigenvalues into pm pairs. The transformation mathbfJmathbfA (flip matrix) equals pmmathbfA, creating symmetric/antisymmetric subspaces.\n\nMathematical foundation:\n\nAnti-diagonal flip symmetry: mathbfJAJ^dagger = pmmathbfA\nEigenvectors come in symmetric/antisymmetric pairs\nEigenvalue equation: If mathbfAmathbfv = lambdamathbfv, then mathbfA(mathbfJmathbfv) = -lambda(mathbfJmathbfv)\n\nDetection algorithm:\n\nCheck if zeros everywhere except anti-diagonal\nVerify symmetry: Ai n+1-i = An+1-i i\nExtract anti-diagonal elements\nForm pm pairs (center unpaired if odd n)\n\nApplications:\n\nExchange matrices\nReversal operators\nSymmetric perturbations of identity\nQuantum mechanics (parity operators)\n\nMathematical properties:\n\nAlways diagonalizable\nReal eigenvalues if entries are real\nOrthogonal eigenvectors (pairs)\n\n","category":"section"},{"location":"pattern_library/#Tensor-Product-Patterns","page":"Pattern Library","title":"Tensor Product Patterns","text":"","category":"section"},{"location":"pattern_library/#Kronecker-Products","page":"Pattern Library","title":"Kronecker Products","text":"Structure: Tensor product mathbfA otimes mathbfB = a_ijmathbfB\n\nMatrix Form (2 times 2 otimes 2 times 2 example):\n\nmathbfA otimes mathbfB = beginbmatrix\na_11mathbfB  a_12mathbfB \na_21mathbfB  a_22mathbfB\nendbmatrix\n\nwhere each entry a_ijmathbfB is a block.\n\nEigenvalues (closed-form for any sizes m, n):\n\nlambda(mathbfA otimes mathbfB) = lambda_i(mathbfA) cdot lambda_j(mathbfB)  i = 1ldots m j = 1ldots n\n\nAll m cdot n products of eigenvalues of mathbfA and mathbfB.\n\nEigenvectors: mathbfv_ij = mathbfv_i(mathbfA) otimes mathbfv_j(mathbfB) (tensor products)\n\nComplexity: O(f(m) + f(n)) where f is cost for each factor\n\nExample (4 times 4 = 2 times 2 otimes 2 times 2):\n\n@variables a b c d\nA = [a 0; 0 b]  # eigenvalues {a, b}\nB = [c 0; 0 d]  # eigenvalues {c, d}\n\nK = kron(A, B)  # 4×4 matrix\n\neigvals(K)  # {ac, ad, bc, bd}\n\nWhy this works: The eigenvalue equation for Kronecker products:\n\n(mathbfA otimes mathbfB)(mathbfu otimes mathbfv) = (mathbfAmathbfu) otimes (mathbfBmathbfv) = (lambda_umathbfu) otimes (lambda_vmathbfv) = (lambda_ulambda_v)(mathbfu otimes mathbfv)\n\nSo if mathbfu is eigenvector of mathbfA with eigenvalue lambda_u, and mathbfv is eigenvector of mathbfB with eigenvalue lambda_v, then mathbfuotimesmathbfv is eigenvector of mathbfAotimesmathbfB with eigenvalue lambda_ulambda_v.\n\nMathematical foundation:\n\nTensor product structure in linear algebra\nFactorization of eigenspaces: E(mathbfAotimesmathbfB) = E(mathbfA) otimes E(mathbfB)\nMultiplicative property of eigenvalues\n\nDetection algorithm:\n\nCheck block pattern: equal-sized blocks\nVerify scaling relationship between blocks\nExtract factor matrices mathbfA and mathbfB\nSolve eigenvalues of mathbfA and mathbfB independently\nForm all products lambda_i(mathbfA) cdot lambda_j(mathbfB)\n\nKey examples:\n\n6 times 6 = 2 times 2 otimes 3 times 3: Quadratic times cubic = feasible\n12 times 12 = 3 times 3 otimes 4 times 4: Cubic times quartic = feasible (but large)\n12 times 12 = 4 times 4 otimes 3 times 3: Same as above\n\nWithout Kronecker structure, degree-6 and degree-12 would be impossible!\n\nApplications:\n\nMulti-dimensional systems (separable PDEs)\nQuantum mechanics (composite systems)\nGraph products (Cartesian product graphs)\nMulti-way tensor analysis\n\nDetection challenges:\n\nRequires exact scaling pattern recognition\nFloating-point errors can break detection\nCurrent implementation: basic pattern matching\n\n","category":"section"},{"location":"pattern_library/#Tridiagonal-Patterns","page":"Pattern Library","title":"Tridiagonal Patterns","text":"","category":"section"},{"location":"pattern_library/#Symmetric-Toeplitz-Tridiagonal","page":"Pattern Library","title":"Symmetric Toeplitz Tridiagonal","text":"Structure: Tridiagonal with constant diagonals (Toeplitz + tridiagonal)\n\nMatrix Form:\n\nmathbfT = beginbmatrix\na  b  0  0  cdots  0 \nb  a  b  0  cdots  0 \n0  b  a  b  cdots  0 \nvdots  vdots  vdots  vdots  ddots  vdots\nendbmatrix\n\nEigenvalues (closed-form for any n):\n\nlambda_k = a + 2bcosleft(frackpin+1right) quad textfor  k = 1 2 ldots n\n\nEigenvectors (known analytically):\n\nv_k(j) = sinleft(fracjkpin+1right) quad textfor  j = 1 ldots n\n\nComplexity: O(n) to compute all eigenvalues\n\nExample (4 times 4):\n\n@variables a b\nT = [a b 0 0;\n     b a b 0;\n     0 b a b;\n     0 0 b a]\n\n# λₖ = a + 2b·cos(kπ/5) for k=1,2,3,4\neigvals(T)\n\nWhy this works: The eigenvectors are discrete sine functions, which are known eigenfunctions of the discrete Laplacian operator. The eigenvalues come from the cosine terms in the eigenvalue equation.\n\nMathematical foundation:\n\nRelated to discrete Laplacian operator\nEigenvectors are Discrete Sine Transform (DST) basis\nConnection to Chebyshev polynomials\nComes from finite-difference discretization of d^2dx^2\n\nDerivation: The eigenvalue equation mathbfTmathbfv = lambdamathbfv with mathbfv = sin(kpi(n+1)) sin(2kpi(n+1)) ldots sin(nkpi(n+1)) gives:\n\nasinleft(fracjkpin+1right) + bsinleft(frac(j-1)kpin+1right) + bsinleft(frac(j+1)kpin+1right) = lambda_ksinleft(fracjkpin+1right)\n\nUsing trigonometric identity sin(alpha)+sin(beta) = 2sin((alpha+beta)2)cos((alpha-beta)2), this simplifies to lambda_k = a + 2bcos(kpi(n+1)).\n\nDetection algorithm:\n\nCheck tridiagonal structure (zeros beyond sub/super-diagonals)\nVerify constant diagonals: all diagonal = a, all off-diagonal = b\nVerify symmetry: sub-diagonal = super-diagonal\nApply formula for k = 1 ldots n\n\nApplications:\n\nFinite difference methods (1D Laplacian)\nVibrating string (discrete model)\nHeat equation discretization\nGraph Laplacian (path graph)\nQuantum mechanics (tight-binding model)\n\nGeneralizations:\n\nNon-symmetric: Different super/sub-diagonals (no closed form in general)\nPeriodic: Adds corner elements (circulant tridiagonal)\nNon-Toeplitz: Variable diagonals (generally no closed form)\n\nWhy it scales to any n: The eigenvector basis is KNOWN and independent of matrix size. We don't need to solve polynomial—we directly compute eigenvalues from formula.\n\n","category":"section"},{"location":"pattern_library/#Special-55-Tridiagonal-Patterns","page":"Pattern Library","title":"Special 5×5 Tridiagonal Patterns","text":"Structure: Tridiagonal 5 times 5 with one \"perturbation\" from constant pattern\n\nTwo specific patterns have been discovered with closed-form eigenvalues.","category":"section"},{"location":"pattern_library/#Pattern-1:-[b,-d,-b,-b]","page":"Pattern Library","title":"Pattern 1: [b, d, b, b]","text":"Matrix Form:\n\nmathbfM = beginbmatrix\na  b  0  0  0 \nb  a  d  0  0 \n0  d  a  b  0 \n0  0  b  a  b \n0  0  0  b  a\nendbmatrix\n\nOff-diagonal sequence: b d b b\n\nEigenvalues (closed-form):\n\nlefta + sqrt2b^2 + d^2  a - sqrt2b^2 + d^2  a + b  a - b  aright\n\nExample:\n\n@variables a b d\nM = [a b 0 0 0; b a d 0 0; 0 d a b 0; 0 0 b a b; 0 0 0 b a]\n\neigvals(M)  # {a ± √(2b² + d²), a ± b, a}","category":"section"},{"location":"pattern_library/#Pattern-2:-[b,-b,-d,-b]","page":"Pattern Library","title":"Pattern 2: [b, b, d, b]","text":"Matrix Form:\n\nmathbfM = beginbmatrix\na  b  0  0  0 \nb  a  b  0  0 \n0  b  a  d  0 \n0  0  d  a  b \n0  0  0  b  a\nendbmatrix\n\nOff-diagonal sequence: b b d b\n\nEigenvalues (closed-form - SAME as Pattern 1!):\n\nlefta + sqrt2b^2 + d^2  a - sqrt2b^2 + d^2  a + b  a - b  aright\n\nExample:\n\n@variables a b d\nM = [a b 0 0 0; b a b 0 0; 0 b a d 0; 0 0 d a b; 0 0 0 b a]\n\neigvals(M)  # {a ± √(2b² + d²), a ± b, a}  (identical to Pattern 1!)\n\nRemarkable discovery: Despite different positions of perturbation d, both patterns yield IDENTICAL eigenvalues!\n\nWhy this works: Unknown! This is an empirical discovery. The mathematical explanation likely involves:\n\nHidden symmetry in characteristic polynomial\nIsospectrality (different matrices, same spectrum)\nPossibly related to Chebyshev polynomial structure\n\nWhat doesn't work (patterns without closed form):\n\nd b b b: Boundary perturbation at position 0\nb b b d: Boundary perturbation at position 3\nd d b b, b d d b: Multiple perturbations\nc d e f: General perturbations\n\nKey insight from research: Interior perturbations (positions 1-2) admit closed forms, but boundary perturbations (positions 0, 3) break the pattern.\n\nDetection algorithm:\n\nCheck 5 times 5 tridiagonal structure\nExtract super-diagonal sequence\nMatch against known patterns bdbb or bbdb\nVerify constant diagonal = a\nApply closed-form formula\n\nApplications:\n\nPerturbed vibrating strings\nDefects in 1D lattice models\nSpecific quantum systems\n\nResearch opportunity: \n\nWhy do these specific patterns work?\nAre there similar 7 times 7 or 9 times 9 patterns?\nCan we characterize all solvable perturbation patterns?\n\nSee notes/PATTERN_DISCOVERIES.md for more details on discovery methodology.\n\n","category":"section"},{"location":"pattern_library/#Permutation-Patterns","page":"Pattern Library","title":"Permutation Patterns","text":"","category":"section"},{"location":"pattern_library/#Permutation-Matrices","page":"Pattern Library","title":"Permutation Matrices","text":"Structure: Exactly one 1 in each row and column, rest zeros\n\nMatrix Form (example: permutation 1 to 2, 2 to 3, 3 to 1):\n\nmathbfP = beginbmatrix\n0  1  0 \n0  0  1 \n1  0  0\nendbmatrix\n\nEigenvalues (closed-form for any permutation):\n\nEach k-cycle contributes k-th roots of unity: 1 omega omega^2 ldots omega^k-1 where omega = exp(2pi ik)\nAll eigenvalues have magnitude 1 (on unit circle)\n\nComplexity: O(n) to compute cycle decomposition and roots\n\nExample (6 times 6 with 3-cycle, 2-cycle, fixed point):\n\n# Permutation: (1→2→3→1), (4↔5), (6)\nP = [0 1 0 0 0 0;   # 1→2\n     0 0 1 0 0 0;   # 2→3\n     1 0 0 0 0 0;   # 3→1\n     0 0 0 0 1 0;   # 4→5\n     0 0 0 1 0 0;   # 5→4\n     0 0 0 0 0 1]   # 6→6\n\neigvals(P)\n# 3-cycle contributes: {1, ω, ω²} where ω = exp(2πi/3)\n# 2-cycle contributes: {1, -1}\n# Fixed point contributes: {1}\n# Total: {1, 1, 1, -1, ω, ω²}\n\nWhy this works: \n\nPermutation matrices have finite order: mathbfP^k = mathbfI for some k\nIf mathbfP^kmathbfv = mathbfv, then mathbfP has eigenvalues that are k-th roots of unity\nCycle decomposition determines which roots appear\n\nMathematical foundation:\n\nCayley's theorem: Every permutation decomposes into disjoint cycles\nRoot of unity property: If mathbfP^k = mathbfI, then lambda^k = 1, so lambda is a k-th root of unity\nCycle length = root order: k-cycle gives k-th roots of unity\n\nCycle decomposition algorithm:\n\nFind permutation: which column has 1 in each row\nFollow cycle: start at 1, go to P(1), then P(P(1)), until back to 1\nRepeat for unvisited elements\nCount cycle lengths\n\nEigenvalue computation: For each k-cycle, add k eigenvalues exp(2pi ijk)  j = 0 ldots k-1\n\nApplications:\n\nSorting algorithms (permutation analysis)\nGroup theory (symmetric group representations)\nGraph automorphisms\nCoding theory (permutation codes)\nFourier analysis on symmetric group\n\nMathematical properties:\n\nAlways orthogonal: mathbfP^daggermathbfP = mathbfI\nEigenvalues on unit circle: lambda = 1\nDiagonalizable (orthogonally)\nDeterminant = pm 1 (sign of permutation)\n\nSpecial cases:\n\nIdentity: One n-cycle → eigenvalue 1 with multiplicity n\nFull cycle: One n-cycle → all n-th roots of unity exp(2pi ikn)  k=0ldots n-1\nTransposition: (2-cycle) → eigenvalues 1 -1\nFixed points: Contribute eigenvalue 1\n\nDetection algorithm:\n\nCheck if matrix has exactly one 1 per row and column\nAll other entries must be 0\nExtract permutation mapping\nCompute cycle decomposition\nGenerate roots of unity for each cycle\n\n","category":"section"},{"location":"pattern_library/#Group-Theoretic-Patterns","page":"Pattern Library","title":"Group-Theoretic Patterns","text":"","category":"section"},{"location":"pattern_library/#Dihedral-Symmetry-Matrices","page":"Pattern Library","title":"Dihedral Symmetry Matrices","text":"Structure: Matrix commuting with dihedral group D_n (rotations and reflections)\n\nSymmetry conditions:\n\nCommutes with n-fold cyclic rotation mathbfR: mathbfAmathbfR = mathbfRmathbfA\nCommutes with reflection mathbfF: mathbfAmathbfF = mathbfFmathbfA\nGroup relations: mathbfR^n = mathbfI, mathbfF^2 = mathbfI, mathbfFmathbfRmathbfF = mathbfR^-1\n\nExample (Pentagon adjacency, n=5):\n\n# Regular pentagon graph - 5-fold rotational and reflection symmetry\nA = [0 1 0 0 1;\n     1 0 1 0 0;\n     0 1 0 1 0;\n     0 0 1 0 1;\n     1 0 0 1 0]\n\neigvals(A)  # [2, φ, φ, -1/φ, -1/φ] where φ = (1+√5)/2 (golden ratio)\n\nEigenvalue structure:\n\nIrreducible representations of D_n determine eigenspace dimensions\nFor D_n: Two 1-dimensional irreps + multiple 2-dimensional irreps\nReduces degree-n problem to multiple smaller problems (often quadratic)\n\nFor odd n:\n\n1 symmetric eigenvalue (irrep A_1)\n1 antisymmetric eigenvalue (irrep A_2)  \n(n-1)2\ndoubly degenerate eigenvalue pairs (2D irreps E_k)\n\nFor even n:\n\n2 one-dimensional (symmetric/antisymmetric)\n2 one-dimensional (symmetric/antisymmetric w.r.t. perpendicular axis)\n(n-4)2\ndoubly degenerate pairs\n\nComplexity: O(n) for detection + solving (n-1)2 quadratic equations\n\nWhy this works: \n\nRepresentation theory guarantees block-diagonal structure in symmetry-adapted basis\nEach irrep block often has degree ≤ 2\nAvoids solving full degree-n characteristic polynomial\n\nApplications:\n\nRegular polygon graphs (chemistry: cyclic molecules)\nCrystal lattice symmetries\nMolecular orbital theory (molecules with rotational + mirror symmetry)\nSignal processing on circular arrays with reflection symmetry\n\nDetection algorithm:\n\nTest if matrix is circulant (rotation symmetry)\nGenerate reflection operators for different axes\nCheck if mathbfA mathbfF = 0 for any reflection\nIf both rotation and reflection symmetries → dihedral\nApply character table decomposition\n\nMathematical properties:\n\nReal eigenvalues if matrix is real symmetric\nEigenvalues come in pairs (except for 1D irreps)\nMore efficient than general degree-n polynomial\n\n","category":"section"},{"location":"pattern_library/#Strongly-Regular-Graphs","page":"Pattern Library","title":"Strongly Regular Graphs","text":"Structure: Adjacency matrix of strongly regular graph with parameters (n k lambda mu)\n\nParameters:\n\nn\n: number of vertices\nk\n: degree (each vertex has k neighbors)\nlambda\n: adjacent vertices have lambda common neighbors\nmu\n: non-adjacent vertices have mu common neighbors\n\nVerification conditions:\n\nBinary matrix (entries 0 or 1)\nZero diagonal (no self-loops)\nSymmetric\nAll row sums equal k (regular)\nFor adjacent vertices ij: exactly lambda common neighbors\nFor non-adjacent vertices ij: exactly mu common neighbors\n\nEigenvalues (only 3 distinct values!):\n\nlambda_1 = k quad text(multiplicity 1)\n\nlambda_2 = frac(lambda - mu) + sqrtDelta2 quad text(multiplicity  f text)\n\nlambda_3 = frac(lambda - mu) - sqrtDelta2 quad text(multiplicity  g text)\n\nwhere Delta = (lambda - mu)^2 + 4(k - mu) and f + g = n - 1.\n\nExample 1: Petersen Graph (n=10 k=3 lambda=0 mu=1):\n\n# Petersen graph adjacency matrix (10×10)\n# Parameters: (10, 3, 0, 1)\nP = [0 1 0 0 1 1 0 0 0 0;\n     1 0 1 0 0 0 1 0 0 0;\n     0 1 0 1 0 0 0 1 0 0;\n     0 0 1 0 1 0 0 0 1 0;\n     1 0 0 1 0 0 0 0 0 1;\n     1 0 0 0 0 0 0 1 1 0;\n     0 1 0 0 0 0 0 0 1 1;\n     0 0 1 0 0 1 0 0 0 1;\n     0 0 0 1 0 1 1 0 0 0;\n     0 0 0 0 1 0 1 1 0 0]\n\neigvals(P)  # [3, 1, 1, 1, 1, 1, -2, -2, -2, -2]\n\nFormula: lambda_1 = 3, Delta = (0-1)^2 + 4(3-1) = 9\n\nlambda_2 = (-1 + 3)2 = 1\n(multiplicity 5)\nlambda_3 = (-1 - 3)2 = -2\n(multiplicity 4)\n\nExample 2: Complete Bipartite Graph K_mn:\n\n# K_{3,3} - complete bipartite graph\nK33 = [0 0 0 1 1 1;\n       0 0 0 1 1 1;\n       0 0 0 1 1 1;\n       1 1 1 0 0 0;\n       1 1 1 0 0 0;\n       1 1 1 0 0 0]\n\neigvals(K33)  # [3, -3, 0, 0, 0, 0]\n\nGeneral: K_mn has eigenvalues sqrtmn -sqrtmn 0 ldots 0 with m+n-2 zeros.\n\nExample 3: Cycle Graph C_5 (also circulant):\n\nC5 = [0 1 0 0 1;\n      1 0 1 0 0;\n      0 1 0 1 0;\n      0 0 1 0 1;\n      1 0 0 1 0]\n\neigvals(C5)  # [2, φ, φ, -1/φ, -1/φ] where φ = (1+√5)/2\n\nComplexity: O(n^2) for verification, O(1) for eigenvalue computation\n\nWhy this works:\n\nStrong regularity imposes severe constraints on eigenvalue structure\nSymmetry forces all but 3 eigenvalues to be determined by the other two\nParameters (nklambdamu) completely determine spectrum\n\nApplications:\n\nCombinatorial designs\nError-correcting codes\nAssociation schemes\nGraph isomorphism testing\nNetwork analysis (highly symmetric networks)\n\nFamous examples:\n\nPetersen graph: (10 3 0 1)\nPaley graphs: Prime p equiv 1 pmod4, parameters (p (p-1)2 (p-5)4 (p-1)4)\nConference graphs: n equiv 2 pmod4, parameters (n (n-1)2 (n-5)4 (n-1)4)\nLatin square graphs: From orthogonal Latin squares\nTriangular graphs T(n): Vertices = 2-subsets of 1ldotsn\n\nMathematical properties:\n\nEigenvalues are algebraic integers\nInteger eigenvalues occur frequently\nSpectrum often involves quadratic irrationals\nStrong regularity Rightarrow walk-regularity (number of walks depends only on distance)\n\n","category":"section"},{"location":"pattern_library/#Block-Circulant-with-Circulant-Blocks-(BCCB)","page":"Pattern Library","title":"Block-Circulant with Circulant Blocks (BCCB)","text":"Structure: Block-circulant matrix where each block is itself circulant\n\nMatrix form (m times m blocks, each n times n):\n\nmathbfA = beginbmatrix\nC_0  C_1  C_2  cdots  C_m-1 \nC_m-1  C_0  C_1  cdots  C_m-2 \nC_m-2  C_m-1  C_0  cdots  C_m-3 \nvdots  vdots  vdots  ddots  vdots \nC_1  C_2  C_3  cdots  C_0\nendbmatrix\n\nwhere each C_i is an n times n circulant matrix.\n\nExample (2 times 2 blocks, each 3 times 3):\n\n# Create 3×3 circulant blocks\nC0 = [1 2 3; 3 1 2; 2 3 1]\nC1 = [4 5 6; 6 4 5; 5 6 4]\n\n# Assemble 6×6 BCCB matrix\nA = [C0 C1;\n     C1 C0]\n\neigvals(A)  # Computed via 2D DFT\n\nEigenvalues: \n\nlambda_jk = sum_p=0^m-1 sum_q=0^n-1 a_pq cdot omega_m^jp cdot omega_n^kq\n\nwhere omega_m = e^2pi im, omega_n = e^2pi in, and a_pq is the (pq) entry in the first block row.\n\nAlternative formulation:\n\nView as doubly-circulant (mn) times (mn) matrix with 2D structure\nEigenvalues = 2D DFT of the m times n \"generator matrix\"\n\nComplexity: O(mn log(mn)) using Fast Fourier Transform\n\nWhy this works:\n\nCombines two levels of circulant structure\nDiagonalized by 2D Fourier basis (Kronecker product of 1D DFT matrices)\nExtension of circulant matrix theory to higher dimensions\n\nApplications:\n\nImage processing: Natural images have approximate BCCB structure\n2D convolution: Convolution matrices are BCCB\nPartial differential equations: Discretized 2D Laplacian with periodic BCs\nSignal processing: 2D signals, video processing\nCompressed sensing: Fast matrix-vector multiplication\n\nDetection algorithm:\n\nCheck if matrix can be partitioned into blocks\nVerify block-level circulant structure (each block row is cyclic shift)\nVerify each block is circulant\nExtract generator matrix (first row of blocks, first row of each block)\nApply 2D FFT\n\nMathematical properties:\n\nAlways diagonalized by 2D DFT matrix\nEigenvalues can be complex even if matrix is real\nFast matrix-vector multiplication: O(mn log(mn)) via FFT\nGeneralization: 3D, 4D, ... multi-level circulant (used in tensor computations)\n\nExtensions:\n\nBlock-Toeplitz with Toeplitz blocks (BTTB): Similar but without circulant constraint\nMulti-level circulant: More than 2 levels of nesting\nKronecker sum structure: Related to tensor product problems\n\n","category":"section"},{"location":"pattern_library/#Hypercube-Graphs","page":"Pattern Library","title":"Hypercube Graphs","text":"Structure: Adjacency matrix of n-dimensional hypercube Q_n\n\nDefinition: \n\nVertices: Binary strings of length n (total: 2^n vertices)\nEdges: Connect vertices differing in exactly one bit\n\nExample (Q_3, 3D cube, 8 vertices):\n\n# Vertices: 000, 001, 010, 011, 100, 101, 110, 111\n# Edges connect vertices differing in one bit\nQ3 = [0 1 1 0 1 0 0 0;\n      1 0 0 1 0 1 0 0;\n      1 0 0 1 0 0 1 0;\n      0 1 1 0 0 0 0 1;\n      1 0 0 0 0 1 1 0;\n      0 1 0 0 1 0 0 1;\n      0 0 1 0 1 0 0 1;\n      0 0 0 1 0 1 1 0]\n\neigvals(Q3)  # [3, 1, 1, 1, -1, -1, -1, -3]\n\nEigenvalues (closed-form for any dimension n):\n\nlambda_k = n - 2k quad k = 0 1 2 ldots n\n\nMultiplicities:\n\nm_k = binomnk\n\nComplete spectrum for Q_n:\n\nlambda = n\nwith multiplicity binomn0 = 1\nlambda = n-2\nwith multiplicity binomn1 = n\nlambda = n-4\nwith multiplicity binomn2\nvdots\nlambda = -n+2\nwith multiplicity binomnn-1 = n\nlambda = -n\nwith multiplicity binomnn = 1\n\nExamples:\n\nQ_1\n(line): eigenvalues 1 -1\nQ_2\n(square): eigenvalues 2 0 0 -2\nQ_3\n(cube): eigenvalues 3 1 1 1 -1 -1 -1 -3\nQ_4\n(tesseract): eigenvalues 4 2 2 2 2 2 2 0 0 0 0 0 0 -2 -2 -2 -2 -2 -2 -4\n\nComplexity: O(1) for eigenvalue generation (just binomial coefficients!)\n\nWhy this works:\n\nHypercube has extremely high symmetry (automorphism group is large)\nGraph is Cayley graph of mathbbZ_2^n (Boolean group)\nEigenvectors are Walsh-Hadamard functions\nConnection to Gray code and Boolean function analysis\n\nApplications:\n\nParallel computing: Hypercube network topology\nBoolean function analysis: Walsh-Hadamard transform\nCoding theory: Hamming distance, error correction\nQuantum computing: Qubit state spaces\nCombinatorial optimization: Traveling salesman, graph coloring\n\nDetection algorithm:\n\nCheck if matrix is 2^n times 2^n for some integer n\nVerify binary (0-1) adjacency matrix\nCheck regularity: all vertices have degree n\nVerify diameter is n (furthest vertices are n edges apart)\nCheck if matrix equals I otimes A_n-1 + J otimes I where A_n-1 is (n-1)-hypercube and J is anti-diagonal\n\nMathematical properties:\n\nBipartite graph (vertices partition by parity of bit sum)\nDistance-regular graph\nSymmetric (undirected edges)\nEigenvalues are integers\nMaximum eigenvalue = degree = n\nCharacteristic polynomial: prod_k=0^n (lambda - (n-2k))^binomnk\n\nRelation to other structures:\n\nHamming graphs H(n2): Equivalent to hypercube\nJohnson graphs J(2n n): Related but different spectrum\nCayley graphs: Hypercube is Cayley graph of (mathbbZ_2)^n\n\n","category":"section"},{"location":"pattern_library/#Summary-Table","page":"Pattern Library","title":"Summary Table","text":"Pattern Size Limit Complexity Key Property\nDiagonal Any n O(n) Direct reading\nTriangular Any n O(n) Diagonal entries\nJordan Block Any n O(1) Single eigenvalue\nBlock-Diagonal Any n sum O(n_i) Union of blocks\nPersymmetric Any n O(n2) Half-size split\nCirculant Any n O(n) DFT formula\nBlock Circulant Any n (k leq 4) O(n cdot k) Block DFT\nKronecker mathbfAotimesmathbfB Any mn (leq 4) O(m+n) Product rule\nToeplitz Tridiag Any n O(n) Cosine formula\nAnti-Diagonal Any n O(n) pm pairs\nPermutation Any n O(n) Roots of unity\nSpecial 5 times 5 [b,d,b,b] 5 times 5 only O(1) Empirical\nSpecial 5 times 5 [b,b,d,b] 5 times 5 only O(1) Empirical\nDihedral Symmetry Any n O(n) + quadratics Rep theory\nStrongly Regular Graph Any n O(n^2) verify, O(1) compute 3 eigenvalues\nBCCB Any m times n O(mn log(mn)) 2D DFT\nHypercube Q_n 2^n O(n) Binomial coefficients\n\n","category":"section"},{"location":"pattern_library/#Pattern-Discovery-Resources","page":"Pattern Library","title":"Pattern Discovery Resources","text":"Additional resources available in the repository:\n\nPATTERN_DISCOVERIES.md (notes/PATTERN_DISCOVERIES.md) - Detailed discovery notes and mathematical justifications\nDISCOVERY_METHODOLOGY.md (notes/DISCOVERY_METHODOLOGY.md) - How to discover new patterns\nRESEARCH_SUMMARY.md (notes/RESEARCH_SUMMARY.md) - Summary of research findings\nexplore_patterns.jl (examples/explore_patterns.jl) - Interactive pattern exploration tools\n\n","category":"section"},{"location":"pattern_library/#Contributing-New-Patterns","page":"Pattern Library","title":"Contributing New Patterns","text":"If you discover a new pattern, please:\n\nVerify numerically (at least 3 test cases)\nVerify symbolically (check characteristic polynomial)\nExplain WHY it works (mathematical justification)\nImplement detector and solver\nAdd comprehensive tests\nDocument in this file\n\nSee Contributing Guide for details.","category":"section"},{"location":"group_theory_examples/#Group-Theory-Examples","page":"Group Theory Examples","title":"Group Theory Examples","text":"This document demonstrates non-trivial applications of group theory to symbolic matrix diagonalization, focusing on matrices with n geq 5 where standard algebraic methods fail.","category":"section"},{"location":"group_theory_examples/#Table-of-Contents","page":"Group Theory Examples","title":"Table of Contents","text":"Pentagon Symmetry (Dihedral D_5)\nPetersen Graph (Strongly Regular)\nHypercube Networks\n2D Image Convolution (BCCB)\nCyclic Molecule Orbitals\nSolvable Degree-5 Polynomials\nQuantum Spin Systems\n\n","category":"section"},{"location":"group_theory_examples/#Pentagon-Symmetry-(Dihedral-D_5)","page":"Group Theory Examples","title":"Pentagon Symmetry (Dihedral D_5)","text":"","category":"section"},{"location":"group_theory_examples/#Problem-Setup","page":"Group Theory Examples","title":"Problem Setup","text":"Consider the adjacency matrix of a regular pentagon graph. Each vertex connects to its two neighbors, creating a 5-fold rotational symmetry plus 5 reflection axes through vertices and opposite edge midpoints.","category":"section"},{"location":"group_theory_examples/#Matrix-Definition","page":"Group Theory Examples","title":"Matrix Definition","text":"using SymbolicDiagonalization\nusing LinearAlgebra\n\n# Adjacency matrix of regular pentagon\n# Vertices: 1-2-3-4-5-1 in a cycle\nA = [0 1 0 0 1;\n     1 0 1 0 0;\n     0 1 0 1 0;\n     0 0 1 0 1;\n     1 0 0 1 0]","category":"section"},{"location":"group_theory_examples/#Group-Theory-Analysis","page":"Group Theory Examples","title":"Group Theory Analysis","text":"Symmetry group: Dihedral D_5 with 10 elements\n\n5 rotations: identity, 72 144 216 288\n5 reflections: through each vertex and opposite edge midpoint\n\nCharacter table for D_5: | Irrep | E | 2C_5 | 2C_5^2 | 5sigma_v | Dimension | |–––-|––-|––––|–––––|––––––-|–––––-| | A_1 | 1   | 1      | 1        | 1           | 1         | | A_2 | 1   | 1      | 1        | -1          | 1         | | E_1 | 2   | 2cos(72) | 2cos(144) | 0 | 2   | | E_2 | 2   | 2cos(144) | 2cos(72) | 0  | 2   |\n\nEigenspace decomposition:\n\n1 eigenvalue from A_1 (fully symmetric)\n1 eigenvalue from A_2 (antisymmetric under reflection)\n2 eigenvalues from E_1 (degenerate pair)\n2 eigenvalues from E_2 (degenerate pair)","category":"section"},{"location":"group_theory_examples/#Computation","page":"Group Theory Examples","title":"Computation","text":"# Standard eigenvalue computation\nvals = eigvals(A)\n# Result: [2.0, 0.618..., 0.618..., -1.618..., -1.618...]\n\n# Symbolic computation reveals exact values\nusing Symbolics\n@variables a b\nA_sym = [0 1 0 0 1;\n         1 0 1 0 0;\n         0 1 0 1 0;\n         0 0 1 0 1;\n         1 0 0 1 0]\n\nvals_sym = eigvals(A_sym)\n# Result (after simplification):\n# λ₁ = 2                    [A₁ irrep - fully symmetric]\n# λ₂ = (1 + √5)/2 = φ       [E₁ irrep - golden ratio]\n# λ₃ = (1 + √5)/2 = φ       [E₁ irrep - degenerate]\n# λ₄ = (1 - √5)/2 = -1/φ    [E₂ irrep]\n# λ₅ = (1 - √5)/2 = -1/φ    [E₂ irrep - degenerate]","category":"section"},{"location":"group_theory_examples/#Why-Group-Theory-Helps","page":"Group Theory Examples","title":"Why Group Theory Helps","text":"Without group theory: \n\nSolve degree-5 characteristic polynomial: det(lambda I - A) = 0\nGeneric quintic is unsolvable by radicals (Abel-Ruffini theorem)\n\nWith group theory:\n\nRecognize D_5 symmetry\nDecompose into irreps: 1D + 1D + 2D + 2D\nSolve two quadratic equations instead of one quintic!\nEigenvalues involve golden ratio phi = (1+sqrt5)2","category":"section"},{"location":"group_theory_examples/#Mathematical-Insight","page":"Group Theory Examples","title":"Mathematical Insight","text":"The characteristic polynomial factors as:\n\n(lambda - 2)(lambda + 2)(lambda^2 - lambda - 1)^text(but appears twice due to degeneracy)\n\nWait, let me recalculate more carefully:\n\ndet(lambda I - A) = (lambda - 2)(lambda^2 - lambda - 4)(lambda^2 + lambda - 1)\n\nThis factors into degree 1, 2, and 2 polynomials - all solvable! The D_5 symmetry forced this factorization.","category":"section"},{"location":"group_theory_examples/#Application:-Cyclopentadienyl-Anion","page":"Group Theory Examples","title":"Application: Cyclopentadienyl Anion","text":"In chemistry, the cyclopentadienyl anion (C₅H₅⁻) has exactly this symmetry. The π-electron molecular orbitals have energies proportional to these eigenvalues:\n\nGround state: E_1 = 2alpha (bonding)\nDegenerate pair: E_2 = E_3 = alpha + betaphi (bonding)\nDegenerate pair: E_4 = E_5 = alpha - betaphi (antibonding)\n\nwhere alpha beta are Hückel parameters. The golden ratio appearance is a direct consequence of pentagonal symmetry!\n\n","category":"section"},{"location":"group_theory_examples/#Petersen-Graph-(Strongly-Regular)","page":"Group Theory Examples","title":"Petersen Graph (Strongly Regular)","text":"","category":"section"},{"location":"group_theory_examples/#Problem-Setup-2","page":"Group Theory Examples","title":"Problem Setup","text":"The Petersen graph is a famous graph in combinatorics with remarkable symmetry properties. It has 10 vertices, each with degree 3, and is strongly regular with parameters (10 3 0 1).","category":"section"},{"location":"group_theory_examples/#Matrix-Definition-2","page":"Group Theory Examples","title":"Matrix Definition","text":"# Petersen graph adjacency matrix\n# Vertices arranged as outer pentagon (1-5) and inner pentagram (6-10)\nP = [0 1 0 0 1 1 0 0 0 0;\n     1 0 1 0 0 0 1 0 0 0;\n     0 1 0 1 0 0 0 1 0 0;\n     0 0 1 0 1 0 0 0 1 0;\n     1 0 0 1 0 0 0 0 0 1;\n     1 0 0 0 0 0 0 1 1 0;\n     0 1 0 0 0 0 0 0 1 1;\n     0 0 1 0 0 1 0 0 0 1;\n     0 0 0 1 0 1 1 0 0 0;\n     0 0 0 0 1 0 1 1 0 0]","category":"section"},{"location":"group_theory_examples/#Strongly-Regular-Graph-Properties","page":"Group Theory Examples","title":"Strongly Regular Graph Properties","text":"Parameters: (n k lambda mu) = (10 3 0 1)\n\nn = 10\n: number of vertices\nk = 3\n: each vertex has 3 neighbors (3-regular)\nlambda = 0\n: adjacent vertices have 0 common neighbors\nmu = 1\n: non-adjacent vertices have exactly 1 common neighbor\n\nVerification:\n\n# Check regularity\n@assert all(sum(P, dims=2) .== 3)  # All row sums = 3\n\n# Check λ parameter (adjacent vertices)\nfor i in 1:10, j in i+1:10\n    if P[i,j] == 1  # Adjacent vertices\n        common = sum(P[i,:] .* P[j,:])\n        @assert common == 0  # No common neighbors\n    end\nend\n\n# Check μ parameter (non-adjacent vertices)\nfor i in 1:10, j in i+1:10\n    if P[i,j] == 0 && i != j  # Non-adjacent vertices\n        common = sum(P[i,:] .* P[j,:])\n        @assert common == 1  # Exactly 1 common neighbor\n    end\nend","category":"section"},{"location":"group_theory_examples/#Eigenvalue-Formula","page":"Group Theory Examples","title":"Eigenvalue Formula","text":"For strongly regular graph with parameters (n k lambda mu):\n\nlambda_1 = k = 3\n\nDelta = (lambda - mu)^2 + 4(k - mu) = (0-1)^2 + 4(3-1) = 1 + 8 = 9\n\nlambda_2 = frac(lambda-mu) + sqrtDelta2 = frac-1 + 32 = 1\n\nlambda_3 = frac(lambda-mu) - sqrtDelta2 = frac-1 - 32 = -2\n\nMultiplicities (from n = 1 + f + g and constraint equations):\n\nm_1 = 1\n(largest eigenvalue always has multiplicity 1)\nm_2 = 5\nm_3 = 4","category":"section"},{"location":"group_theory_examples/#Computation-2","page":"Group Theory Examples","title":"Computation","text":"# Numerical eigenvalues\nvals = eigvals(P)\n# Result: [3, 1, 1, 1, 1, 1, -2, -2, -2, -2]\n\n# Group by value\nunique_vals = unique(round.(vals, digits=10))\nmultiplicities = [count(≈(v), vals) for v in unique_vals]\n\nprintln(\"Eigenvalue spectrum:\")\nfor (v, m) in zip(unique_vals, multiplicities)\n    println(\"  λ = $v with multiplicity $m\")\nend\n# Output:\n# λ = 3 with multiplicity 1\n# λ = 1 with multiplicity 5\n# λ = -2 with multiplicity 4","category":"section"},{"location":"group_theory_examples/#Why-This-is-Remarkable","page":"Group Theory Examples","title":"Why This is Remarkable","text":"Without strong regularity:\n\nSolve degree-10 characteristic polynomial\n10 = 3628800\npossible permutations of roots\nGeneric degree-10 polynomial is completely intractable symbolically\n\nWith strong regularity:\n\nOnly 3 distinct eigenvalues regardless of size!\nComputed from parameters using simple formula (square root of linear expression)\nNo polynomial solving whatsoever\nMultiplicities determined by parameter constraints","category":"section"},{"location":"group_theory_examples/#Mathematical-Depth","page":"Group Theory Examples","title":"Mathematical Depth","text":"The Petersen graph is the Kneser graph K(52) - vertices are 2-element subsets of 12345, edges connect disjoint subsets.\n\nAutomorphism group: Symmetric group S_5 with order 120\n\nGraph has 120 symmetries!\nThis massive symmetry constrains eigenvalue structure severely\n\nImplications:\n\nSmallest bridgeless cubic graph with no 3-edge-coloring\nUnique (35)-cage (smallest 3-regular graph with girth 5)\nAppears in Hoffman-Singleton theorem\nGraph is vertex-transitive but not edge-transitive\n\n","category":"section"},{"location":"group_theory_examples/#Hypercube-Networks","page":"Group Theory Examples","title":"Hypercube Networks","text":"","category":"section"},{"location":"group_theory_examples/#Problem-Setup-3","page":"Group Theory Examples","title":"Problem Setup","text":"The n-dimensional hypercube Q_n has 2^n vertices (binary strings of length n), with edges connecting vertices differing in exactly one bit. These are crucial in parallel computing architectures.","category":"section"},{"location":"group_theory_examples/#Example:-3D-Cube-(Q_3)","page":"Group Theory Examples","title":"Example: 3D Cube (Q_3)","text":"# 3D cube (8 vertices)\n# Binary labels: 000, 001, 010, 011, 100, 101, 110, 111\nQ3 = [0 1 1 0 1 0 0 0;  # 000: connects to 001, 010, 100\n      1 0 0 1 0 1 0 0;  # 001: connects to 000, 011, 101\n      1 0 0 1 0 0 1 0;  # 010: connects to 000, 011, 110\n      0 1 1 0 0 0 0 1;  # 011: connects to 001, 010, 111\n      1 0 0 0 0 1 1 0;  # 100: connects to 000, 101, 110\n      0 1 0 0 1 0 0 1;  # 101: connects to 001, 100, 111\n      0 0 1 0 1 0 0 1;  # 110: connects to 010, 100, 111\n      0 0 0 1 0 1 1 0]  # 111: connects to 011, 101, 110\n\n# Eigenvalues (computed)\nvals = eigvals(Q3)\n# Result: [3, 1, 1, 1, -1, -1, -1, -3]","category":"section"},{"location":"group_theory_examples/#Closed-Form-Eigenvalue-Formula","page":"Group Theory Examples","title":"Closed-Form Eigenvalue Formula","text":"For Q_n (n-dimensional hypercube with 2^n vertices):\n\nEigenvalues:\n\nlambda_k = n - 2k quad k = 0 1 2 ldots n\n\nMultiplicities:\n\nm_k = binomnk\n\nComplete spectrum: | k | lambda_k | Multiplicity | Description | |––-|––––––-|–––––––|––––––-| | 0   | n         | binomn0 = 1 | Maximum eigenvalue | | 1   | n-2       | binomn1 = n | | | 2   | n-4       | binomn2     | | | vdots | vdots | vdots | | | n | -n        | binomnn = 1 | Minimum eigenvalue |","category":"section"},{"location":"group_theory_examples/#Example:-4D-Hypercube-(Q_4)","page":"Group Theory Examples","title":"Example: 4D Hypercube (Q_4)","text":"# For Q₄ (16 vertices), eigenvalues without computing:\nn = 4\nfor k in 0:n\n    λ = n - 2k\n    m = binomial(n, k)\n    println(\"λ = $λ with multiplicity $m\")\nend\n\n# Output:\n# λ = 4 with multiplicity 1\n# λ = 2 with multiplicity 4\n# λ = 0 with multiplicity 6\n# λ = -2 with multiplicity 4\n# λ = -4 with multiplicity 1\n\n# Total: 1 + 4 + 6 + 4 + 1 = 16 ✓","category":"section"},{"location":"group_theory_examples/#Example:-5D-Hypercube-(Q_5)","page":"Group Theory Examples","title":"Example: 5D Hypercube (Q_5)","text":"# Q₅ has 32 vertices - degree 5 on each vertex\n# Without group theory: solve degree-32 polynomial (hopeless!)\n# With group theory: instant closed form!\n\nn = 5\neigenvalues = Dict{Int, Int}()\nfor k in 0:n\n    λ = n - 2k\n    m = binomial(n, k)\n    eigenvalues[λ] = m\nend\n\nprintln(\"Q₅ spectrum:\")\nfor (λ, m) in sort(collect(eigenvalues), rev=true)\n    println(\"  λ = $λ : $(\"λ \" ^ m)\")\nend\n\n# Output:\n# λ = 5 : λ\n# λ = 3 : λ λ λ λ λ\n# λ = 1 : λ λ λ λ λ λ λ λ λ λ\n# λ = -1 : λ λ λ λ λ λ λ λ λ λ\n# λ = -3 : λ λ λ λ λ\n# λ = -5 : λ","category":"section"},{"location":"group_theory_examples/#Why-This-Works","page":"Group Theory Examples","title":"Why This Works","text":"Cayley graph structure: Q_n is the Cayley graph of (mathbbZ_2)^n\n\nVertices = elements of Boolean group\nEdges = group generators (flip one bit)\n\nEigenvectors: Walsh-Hadamard functions\n\nmathbfv_S = (-1)^x cap S  x in 01^n\nfor subset S subseteq 1ldotsn\nEigenvalue of mathbfv_S is n - 2S\nNumber of subsets of size k is binomnk\n\nConnection to Boolean functions:\n\nWalsh-Hadamard transform diagonalizes adjacency matrix\nEigenvalues measure correlation with parity functions\nApplications in cryptography, coding theory, quantum computing","category":"section"},{"location":"group_theory_examples/#Application:-Parallel-Computer-Networks","page":"Group Theory Examples","title":"Application: Parallel Computer Networks","text":"Many parallel computers use hypercube topology:\n\nConnection Machine CM-2 (1987): 65,536 processors in Q_16\nIntel iPSC: Hypercube architecture\nCosmic Cube: Early Caltech design\n\nNetwork properties from spectrum:\n\nDiameter: n (maximum eigenvalue - minimum eigenvalue)/2\nExpansion: Related to spectral gap lambda_1 - lambda_2 = 2\nBisection width: 2^n-1 (exponential in dimension)\n\n","category":"section"},{"location":"group_theory_examples/#2D-Image-Convolution-(BCCB)","page":"Group Theory Examples","title":"2D Image Convolution (BCCB)","text":"","category":"section"},{"location":"group_theory_examples/#Problem-Setup-4","page":"Group Theory Examples","title":"Problem Setup","text":"2D convolution with periodic boundary conditions creates Block-Circulant with Circulant Blocks (BCCB) matrices. These are ubiquitous in image processing and signal analysis.","category":"section"},{"location":"group_theory_examples/#Example:-33-Image-with-22-Kernel","page":"Group Theory Examples","title":"Example: 3×3 Image with 2×2 Kernel","text":"# Image: 3×3 grid (9 pixels total)\n# Convolution kernel: 2×2 (but extended to 3×3 with zero padding)\n# Periodic boundary conditions\n\n# Kernel (shifted and wrapped):\n# k = [k₀₀ k₀₁ 0  ]\n#     [k₁₀ k₁₁ 0  ]\n#     [0   0   0  ]\n\n# Example: Gaussian blur kernel (unnormalized)\nk00, k01, k10, k11 = 4, 2, 2, 1\n\n# Construct circulant blocks\n# Each 3×3 block is circulant\nC00 = [k00 0 k01;   # Row 0 of kernel, circularly shifted\n       k01 k00 0;\n       0 k01 k00]\n\nC01 = [k10 0 k11;   # Row 1 of kernel, circularly shifted\n       k11 k10 0;\n       0 k11 k10]\n\nC02 = [0 0 0;       # Row 2 of kernel (all zeros)\n       0 0 0;\n       0 0 0]\n\n# Assemble BCCB matrix (9×9)\n# Block structure is circulant\nBCCB = [C00 C02 C01;\n        C01 C00 C02;\n        C02 C01 C00]\n\nprintln(\"BCCB matrix size: $(size(BCCB))\")  # 9×9","category":"section"},{"location":"group_theory_examples/#Eigenvalue-Computation-via-2D-DFT","page":"Group Theory Examples","title":"Eigenvalue Computation via 2D DFT","text":"For BCCB matrix from m times n kernel:\n\nEigenvalues:\n\nlambda_jk = sum_p=0^m-1 sum_q=0^n-1 K_pq cdot omega_m^jp cdot omega_n^kq\n\nwhere K is the kernel matrix and omega_m = e^2pi im.\n\nusing FFTW\n\n# Kernel as 3×3 matrix\nK = [k00 k01 0;\n     k10 k11 0;\n     0   0   0]\n\n# Eigenvalues = 2D DFT of kernel\neigenvalues_bccb = vec(fft(K))\n\nprintln(\"Eigenvalues (via 2D FFT):\")\nfor (i, λ) in enumerate(eigenvalues_bccb)\n    println(\"  λ[$i] = $(round(λ, digits=3))\")\nend\n\n# Verify against direct computation\neigenvalues_direct = eigvals(BCCB)\nprintln(\"\\nVerification:\")\nprintln(\"  Max error: $(maximum(abs.(sort(eigenvalues_bccb) - sort(eigenvalues_direct))))\")","category":"section"},{"location":"group_theory_examples/#Symbolic-Computation","page":"Group Theory Examples","title":"Symbolic Computation","text":"using Symbolics\n@variables k00 k01 k10 k11\n\n# Construct symbolic BCCB\n# (code as above but with symbolic variables)\n\n# Eigenvalues from 2D DFT formula\nω3 = exp(2π*im/3)\n\neigenvalues_symbolic = [\n    k00 + k01 + k10 + k11,                                  # (j,k) = (0,0)\n    k00 + k01*ω3 + k10 + k11*ω3,                           # (j,k) = (0,1)\n    k00 + k01*ω3^2 + k10 + k11*ω3^2,                       # (j,k) = (0,2)\n    k00 + k01 + k10*ω3 + k11*ω3,                           # (j,k) = (1,0)\n    k00 + k01*ω3 + k10*ω3 + k11*ω3^2,                      # (j,k) = (1,1)\n    k00 + k01*ω3^2 + k10*ω3 + k11*ω3,                      # (j,k) = (1,2)\n    k00 + k01 + k10*ω3^2 + k11*ω3^2,                       # (j,k) = (2,0)\n    k00 + k01*ω3 + k10*ω3^2 + k11,                         # (j,k) = (2,1)\n    k00 + k01*ω3^2 + k10*ω3^2 + k11                        # (j,k) = (2,2)\n]","category":"section"},{"location":"group_theory_examples/#Why-This-is-Important","page":"Group Theory Examples","title":"Why This is Important","text":"Image sizes: Modern images are large (e.g., 1920×1080 = 2,073,600 pixels)\n\nDirect eigenvalue computation: O(n^3) for n times n matrix → Intractable!\nBCCB exploitation: O(n log n) via FFT → Real-time processing!\n\nApplications:\n\nDeconvolution: Inverse filtering for image restoration\nDeblurring: Remove motion blur or defocus\nEdge detection: Convolution with edge kernels\nImage compression: Spectral analysis\nTexture analysis: Frequency domain characterization\n\nExample speeds (for 1024 times 1024 image):\n\nDirect method: sim 10^18 operations → years\nFFT method: sim 10^7 operations → milliseconds\n\n","category":"section"},{"location":"group_theory_examples/#Cyclic-Molecule-Orbitals","page":"Group Theory Examples","title":"Cyclic Molecule Orbitals","text":"","category":"section"},{"location":"group_theory_examples/#Problem-Setup-5","page":"Group Theory Examples","title":"Problem Setup","text":"Benzene (C₆H₆) and other cyclic aromatic molecules have π-electrons delocalized around a ring. The Hückel molecular orbital theory uses a tight-binding model where adjacent atoms interact.","category":"section"},{"location":"group_theory_examples/#Benzene-(C_6-symmetry)","page":"Group Theory Examples","title":"Benzene (C_6 symmetry)","text":"using Symbolics\n@variables α β  # α = on-site energy, β = hopping parameter\n\n# Hückel Hamiltonian for benzene\n# Diagonal: all α (on-site energy)\n# Off-diagonal: β for adjacent atoms\nH_benzene = [α  β  0  0  0  β;\n             β  α  β  0  0  0;\n             0  β  α  β  0  0;\n             0  0  β  α  β  0;\n             0  0  0  β  α  β;\n             β  0  0  0  β  α]","category":"section"},{"location":"group_theory_examples/#Circulant-Structure","page":"Group Theory Examples","title":"Circulant Structure","text":"Notice: This is a circulant matrix!\n\nFirst row: α β 0 0 0 β\nEach subsequent row is a cyclic shift\n\nEigenvalues (from DFT formula):\n\nlambda_k = α + βleft(e^2pi ik6 + e^-2pi ik6right) = α + 2βcosleft(frac2pi k6right)\n\nfor k = 0 1 2 3 4 5.","category":"section"},{"location":"group_theory_examples/#Explicit-Computation","page":"Group Theory Examples","title":"Explicit Computation","text":"# Eigenvalues for k = 0, 1, 2, 3, 4, 5\neigenvalues_benzene = [\n    α + 2β*cos(0),           # k=0: α + 2β\n    α + 2β*cos(π/3),         # k=1: α + β\n    α + 2β*cos(2π/3),        # k=2: α - β\n    α + 2β*cos(π),           # k=3: α - 2β\n    α + 2β*cos(4π/3),        # k=4: α - β\n    α + 2β*cos(5π/3)         # k=5: α + β\n]\n\n# Simplified:\n# λ₀ = α + 2β  (1-fold, non-degenerate)\n# λ₁ = α + β   (2-fold degenerate)\n# λ₂ = α - β   (2-fold degenerate)\n# λ₃ = α - 2β  (1-fold, non-degenerate)","category":"section"},{"location":"group_theory_examples/#Energy-Level-Diagram","page":"Group Theory Examples","title":"Energy Level Diagram","text":"    α + 2β  ━━━━━━  (bonding, filled with 2 e⁻)\n             /  \\\n    α + β   ━━  ━━  (degenerate, filled with 4 e⁻)\n           ─────────  HOMO-LUMO gap\n    α - β   ━━  ━━  (degenerate, empty - antibonding)\n             \\  /\n    α - 2β  ━━━━━━  (antibonding, empty)\n\nElectron filling (6 π-electrons):\n\nLowest orbital (α + 2β): 2 electrons\nDegenerate pair (α + β): 4 electrons\nResult: Fully filled bonding orbitals → stable aromatic system\n\nHückel's 4n+2 rule: Aromatic stability when π-electron count = 4n+2\n\nBenzene: 6 = 4(1) + 2 ✓ (aromatic)\nCyclobutadiene: 4 = 4(1) ✗ (antiaromatic)\nCyclooctatetraene: 8 = 4(2) ✗ (non-planar)","category":"section"},{"location":"group_theory_examples/#Generalization:-Cyclic-C_n-Molecules","page":"Group Theory Examples","title":"Generalization: Cyclic C_n Molecules","text":"For any n-membered ring:\n\nlambda_k = α + 2βcosleft(frac2pi knright) quad k = 0 1 ldots n-1\n\nExamples:\n\nCyclopropene (n=3): λ = {α+2β, α-β, α-β}\nCyclobutadiene (n=4): λ = {α+2β, α, α, α-2β} (unstable, non-aromatic)\nCyclopentadienyl (n=5): λ = {α+2β, α+2β·cos(72°), ...} (from earlier pentagon example)\nBenzene (n=6): λ = {α+2β, α+β, α+β, α-β, α-β, α-2β} (stable, aromatic)\n\n","category":"section"},{"location":"group_theory_examples/#Solvable-Degree-5-Polynomials","page":"Group Theory Examples","title":"Solvable Degree-5 Polynomials","text":"","category":"section"},{"location":"group_theory_examples/#Problem:-When-Can-We-Solve-Quintics?","page":"Group Theory Examples","title":"Problem: When Can We Solve Quintics?","text":"The Abel-Ruffini theorem says generic degree-5 polynomials are unsolvable. But polynomials with special structure (solvable Galois groups) ARE solvable!","category":"section"},{"location":"group_theory_examples/#Example-1:-Pure-Quintic-(\\mathbb{Z}_5-Galois-Group)","page":"Group Theory Examples","title":"Example 1: Pure Quintic (mathbbZ_5 Galois Group)","text":"Polynomial: lambda^5 - a = 0\n\nGalois group: Cyclic group mathbbZ_5 (solvable!)\n\nSolutions:\n\nlambda_k = sqrt5a cdot e^2pi i k5 quad k = 0 1 2 3 4\n\nusing Symbolics\n@variables a\n\n# Five solutions\nω = exp(2π*im/5)  # Fifth root of unity\nsolutions = [a^(1/5) * ω^k for k in 0:4]\n\n# Explicitly:\nλ0 = a^(1/5)                                    # Real (if a > 0)\nλ1 = a^(1/5) * (cos(2π/5) + im*sin(2π/5))     # Complex\nλ2 = a^(1/5) * (cos(4π/5) + im*sin(4π/5))     # Complex\nλ3 = a^(1/5) * (cos(6π/5) + im*sin(6π/5))     # Complex conjugate of λ2\nλ4 = a^(1/5) * (cos(8π/5) + im*sin(8π/5))     # Complex conjugate of λ1\n\nConcrete example: lambda^5 - 32 = 0\n\na = 32\nroots = [2 * exp(2π*im*k/5) for k in 0:4]\n# = [2, 2ω, 2ω², 2ω³, 2ω⁴]","category":"section"},{"location":"group_theory_examples/#Example-2:-Binomial-with-Gcd-Structure","page":"Group Theory Examples","title":"Example 2: Binomial with Gcd Structure","text":"Polynomial: lambda^5 - lambda^3 = 0\n\nFactorization: lambda^3(lambda^2 - 1) = 0\n\nSolutions: 0 0 0 1 -1\n\n# This is really degree-2 after factoring out λ³\n# Not fundamentally a quintic problem","category":"section"},{"location":"group_theory_examples/#Example-3:-Emma-Lehmer's-Quintic-(Dihedral-D_5)","page":"Group Theory Examples","title":"Example 3: Emma Lehmer's Quintic (Dihedral D_5)","text":"Polynomial: lambda^5 + n^2lambda^4 - (2n^3 + 6n^2 + 10n + 10)lambda^3 + cdots\n\nActually, let's use a simpler dihedral example:\n\nPolynomial: lambda^5 - lambda - 1 = 0\n\nGalois group: Often D_5 (dihedral, solvable)\n\nDiscriminant: -19 cdot 151 (not a perfect square → not in A_5, suggests D_5)\n\nSolutions: Expressible using nested radicals, but very complex. Example:\n\nlambda_1 approx 11673\n\nThe exact expression involves:\n\nSolving a degree-6 resolvent (sextic) → gives auxiliary value y\nUsing y to reduce to quadratics\nNested square roots and fifth roots\n\nToo complex for practical use, but theoretically exists.","category":"section"},{"location":"group_theory_examples/#Example-4:-Reducible-Quintic","page":"Group Theory Examples","title":"Example 4: Reducible Quintic","text":"Polynomial: (lambda^2 + 1)(lambda^3 - 2) = 0\n\nSolutions: \n\nlambda in i -i cup sqrt32 sqrt32omega sqrt32omega^2\n\nwhere omega = e^2pi i3.\n\n# Roots:\nroots = [\n    im, -im,                                    # From λ² + 1 = 0\n    2^(1/3),                                    # From λ³ - 2 = 0\n    2^(1/3) * exp(2π*im/3),\n    2^(1/3) * exp(4π*im/3)\n]","category":"section"},{"location":"group_theory_examples/#Practical-Detection-Strategy","page":"Group Theory Examples","title":"Practical Detection Strategy","text":"Given degree-5 characteristic polynomial p(lambda):\n\nTry factorization (symbolic or numerical)\nIf factors → solve smaller pieces\nCheck for pure power: lambda^5 - a\nGalois group mathbbZ_5 → use roots of unity\nCompute discriminant Delta\nIf Delta is perfect square → Galois group in A_5 (still might be solvable)\nCompute resolvent polynomial (degree-6 sextic)\nIf resolvent factors significantly → possibly dihedral D_5 (solvable)\nIf resolvent stays irreducible → likely S_5 or A_5 (not solvable in general)\nNumerical check: Compare symbolic solution attempt with numerical roots\nIf expressions match numerically → solvable\nIf no match → probably not solvable by radicals\n\n","category":"section"},{"location":"group_theory_examples/#Quantum-Spin-Systems","page":"Group Theory Examples","title":"Quantum Spin Systems","text":"","category":"section"},{"location":"group_theory_examples/#Problem-Setup-6","page":"Group Theory Examples","title":"Problem Setup","text":"Quantum mechanical spin-j systems have (2j+1)-dimensional Hilbert spaces. The angular momentum operators hatJ_x hatJ_y hatJ_z form an SU(2) Lie algebra.","category":"section"},{"location":"group_theory_examples/#Spin-5/2-System-(6-dimensional)","page":"Group Theory Examples","title":"Spin-5/2 System (6-dimensional)","text":"Dimension: 2j + 1 = 6 for j = 52\n\nJ_z operator (diagonal in standard basis):\n\nusing Symbolics\n\n# Spin-5/2: m = -5/2, -3/2, -1/2, +1/2, +3/2, +5/2\nJz = Diagonal([-5/2, -3/2, -1/2, 1/2, 3/2, 5/2])\n\n# Eigenvalues: {-5/2, -3/2, -1/2, 1/2, 3/2, 5/2}\n# Equally spaced by 1\n\nJ_x operator (off-diagonal, using ladder operators):\n\nJ_x = frac12(J_+ + J_-)\n\nwhere J_pm are raising/lowering operators.\n\n# Matrix elements: ⟨m'|Jₓ|m⟩ = (1/2)[⟨m'|J₊|m⟩ + ⟨m'|J₋|m⟩]\n# J₊|j,m⟩ = √[(j-m)(j+m+1)] |j,m+1⟩\n# J₋|j,m⟩ = √[(j+m)(j-m+1)] |j,m-1⟩\n\nj = 5/2\nm_values = [-5/2, -3/2, -1/2, 1/2, 3/2, 5/2]\n\nJx = zeros(6, 6)\nfor (i, m) in enumerate(m_values)\n    # Raising operator contribution (connects m to m+1)\n    if i < 6\n        Jx[i+1, i] = 0.5 * sqrt((j - m) * (j + m + 1))\n    end\n    # Lowering operator contribution (connects m to m-1)\n    if i > 1\n        Jx[i-1, i] = 0.5 * sqrt((j + m) * (j - m + 1))\n    end\nend\n\nprintln(\"Jₓ matrix for spin-5/2:\")\ndisplay(Jx)\n\n# Output:\n# 0.0    1.118  0.0    0.0    0.0    0.0\n# 1.118  0.0    1.581  0.0    0.0    0.0\n# 0.0    1.581  0.0    1.732  0.0    0.0\n# 0.0    0.0    1.732  0.0    1.581  0.0\n# 0.0    0.0    0.0    1.581  0.0    1.118\n# 0.0    0.0    0.0    0.0    1.118  0.0\n\nEigenvalues of J_x: Despite being 6×6, we know eigenvalues from SU(2) representation theory!\n\n# Eigenvalues MUST be:\neigenvalues_Jx = [-5/2, -3/2, -1/2, 1/2, 3/2, 5/2]\n\n# Verify numerically:\ncomputed_eigs = eigvals(Jx)\nprintln(\"Computed eigenvalues:\")\nprintln(sort(computed_eigs))\n\n# Result: [-2.5, -1.5, -0.5, 0.5, 1.5, 2.5]\n# Matches exactly!","category":"section"},{"location":"group_theory_examples/#Why-This-Works-2","page":"Group Theory Examples","title":"Why This Works","text":"SU(2) representation theory:\n\nFor spin-j system, eigenvalues of any component (J_x J_y textor  J_z) are:\n-j -j+1 -j+2 ldots j-1 j\nAll equally spaced by 1\nTotal of 2j+1 eigenvalues\nDetermined by symmetry alone, no polynomial solving!\n\nCommutation relations:\n\nJ_x J_y = i J_z quad J_y J_z = i J_x quad J_z J_x = i J_y\n\nThese define the SU(2) Lie algebra. Any matrix satisfying these relations has the standard spin-j eigenvalue spectrum.","category":"section"},{"location":"group_theory_examples/#Application:-Electron-Spin-Resonance","page":"Group Theory Examples","title":"Application: Electron Spin Resonance","text":"In magnetic resonance, electrons with spin-1/2 precess in magnetic fields. For higher spins (e.g., transition metal ions with S = 52), the energy levels are:\n\n# Zeeman splitting in magnetic field B\nusing Symbolics\n@variables B g μ_B  # Field, g-factor, Bohr magneton\n\n# Energy levels\nE_m = [-g * μ_B * B * m for m in [-5/2, -3/2, -1/2, 1/2, 3/2, 5/2]]\n\n# Allowed transitions: Δm = ±1\n# Resonance frequencies:\nω_transitions = [g * μ_B * B for _ in 1:5]  # All transitions have same frequency!\n\nprintln(\"All ESR transitions at same frequency: ω = g·μ_B·B\")\n\nThis equal spacing is a direct consequence of SU(2) symmetry.","category":"section"},{"location":"group_theory_examples/#Generalization:-Arbitrary-Spin","page":"Group Theory Examples","title":"Generalization: Arbitrary Spin","text":"For spin-j (dimension 2j+1):\n\nfunction spin_eigenvalues(j)\n    return [-j + k for k in 0:(2j)]\nend\n\n# Examples:\nprintln(\"Spin-1/2 (electrons): \", spin_eigenvalues(1/2))      # [-1/2, 1/2]\nprintln(\"Spin-1 (photons): \", spin_eigenvalues(1))            # [-1, 0, 1]\nprintln(\"Spin-3/2 (Δ baryons): \", spin_eigenvalues(3/2))      # [-3/2, -1/2, 1/2, 3/2]\nprintln(\"Spin-2 (gravitons): \", spin_eigenvalues(2))          # [-2, -1, 0, 1, 2]\nprintln(\"Spin-5/2 (Mn²⁺): \", spin_eigenvalues(5/2))           # [-5/2, -3/2, -1/2, 1/2, 3/2, 5/2]\n\nKey insight: For any dimension n = 2j+1, if matrix has SU(2) symmetry, eigenvalues are immediately known without computation!\n\n","category":"section"},{"location":"group_theory_examples/#Summary","page":"Group Theory Examples","title":"Summary","text":"These examples demonstrate that group theory transforms impossible problems into tractable ones:\n\nPentagon (5×5): Degree-5 polynomial → Two quadratics (via D_5 symmetry)\nPetersen (10×10): Degree-10 polynomial → Direct formula (3 values only!)\nHypercube (2^n vertices): Exponentially large → Binomial coefficients\nBCCB: Million-dimensional image → FFT in milliseconds\nBenzene: 6×6 Hückel → Cosine formula (circulant structure)\nSolvable quintics: Degree-5 → Nested radicals (when Galois group is solvable)\nSpin systems: Arbitrary size → Integer eigenvalues (SU(2) representation)\n\nThe common thread: Symmetry constrains eigenvalue structure, often reducing intractable problems to closed-form solutions or efficient algorithms.","category":"section"},{"location":"implementation/#Implementation-Details","page":"Implementation Details","title":"Implementation Details","text":"This document provides technical details about the algorithms and implementation strategies used in SymbolicDiagonalization.jl.","category":"section"},{"location":"implementation/#Table-of-Contents","page":"Implementation Details","title":"Table of Contents","text":"Overview\nCharacteristic Polynomial Computation\nRoot Solvers (Degrees 1-4)\nStructure Detection\nSpecial Pattern Solvers\nEigenvector Computation\nExpression Management\nPerformance Considerations\n\n","category":"section"},{"location":"implementation/#Overview","page":"Implementation Details","title":"Overview","text":"SymbolicDiagonalization.jl uses a multi-layered approach to compute eigenvalues and eigenvectors:\n\nStructure Detection: Identify exploitable matrix patterns\nPattern-Specific Solvers: Use specialized algorithms for detected patterns\nCharacteristic Polynomial: Compute det(lambda I - A) using Bareiss algorithm\nRoot Finding: Solve polynomials up to degree 4 using closed-form formulas\nEigenvector Computation: Use RREF-based nullspace or adjugate method\n\nThe implementation prioritizes symbolic correctness over numeric efficiency, using fraction-free algorithms and avoiding floating-point operations wherever possible.\n\n","category":"section"},{"location":"implementation/#Characteristic-Polynomial-Computation","page":"Implementation Details","title":"Characteristic Polynomial Computation","text":"","category":"section"},{"location":"implementation/#Algorithm:-Bareiss-Determinant","page":"Implementation Details","title":"Algorithm: Bareiss Determinant","text":"The characteristic polynomial det(lambda I - A) is computed using the Bareiss algorithm, a fraction-free variant of Gaussian elimination.\n\nFile: src/charpoly.jl","category":"section"},{"location":"implementation/#Why-Bareiss?","page":"Implementation Details","title":"Why Bareiss?","text":"Standard Gaussian elimination requires division, which causes intermediate expression blowup in symbolic computation:\n\nStandard GE: Expressions grow like O(2^n) due to nested divisions\nBareiss: Keeps expressions polynomial-sized by avoiding division until the end","category":"section"},{"location":"implementation/#Algorithm-Description","page":"Implementation Details","title":"Algorithm Description","text":"Given matrix M, Bareiss computes det(M) without fractions:\n\nfunction _bareiss_det(M)\n    n = size(M, 1)\n    A = Matrix{eltype(M)}(M)\n    prev = one(eltype(M))\n    \n    for k in 1:n-1\n        pivot = A[k, k]\n        _issymzero(pivot) && error(\"zero pivot encountered\")\n        \n        # Update submatrix using division-free formula\n        for i in k+1:n, j in k+1:n\n            A[i, j] = (A[i, j] * pivot - A[i, k] * A[k, j]) / prev\n        end\n        \n        # Zero out column below pivot\n        fill!(view(A, k+1:n, k), zero(eltype(M)))\n        prev = pivot\n    end\n    \n    return A[n, n]\nend\n\nKey insight: The formula (A[i,j] * pivot - A[i,k] * A[k,j]) / prev is always divisible by prev (the previous pivot), so no fractions appear.","category":"section"},{"location":"implementation/#Complexity","page":"Implementation Details","title":"Complexity","text":"Time: O(n^3) symbolic operations\nExpression size: Polynomial growth (much better than standard methods)\nSpace: O(n^2) for the matrix","category":"section"},{"location":"implementation/#Coefficient-Extraction","page":"Implementation Details","title":"Coefficient Extraction","text":"Instead of polynomial division (which is brittle for symbolic expressions), we use derivative-based extraction:\n\nfunction _collect_coefficients(poly, λ, degree)\n    coeffs = Vector{Any}(undef, degree + 1)\n    coeffs[1] = substitute(poly, λ => 0)  # Constant term\n    \n    deriv = poly\n    fact = 1\n    for k in 1:degree\n        deriv = derivative(deriv, λ)\n        fact *= k\n        coeffs[k + 1] = substitute(deriv, λ => 0) / fact\n    end\n    \n    return coeffs\nend\n\nThis uses the Taylor series expansion: p(lambda) = sum_k fracp^(k)(0)k lambda^k\n\n","category":"section"},{"location":"implementation/#Root-Solvers-(Degrees-1-4)","page":"Implementation Details","title":"Root Solvers (Degrees 1-4)","text":"","category":"section"},{"location":"implementation/#Overview-2","page":"Implementation Details","title":"Overview","text":"SymbolicDiagonalization.jl implements closed-form root solvers for polynomials up to degree 4:\n\nDegree Method Formula Name\n1 Linear Direct\n2 Quadratic Quadratic formula\n3 Cubic Cardano's method\n4 Quartic Ferrari's method\n\nFile: src/roots.jl","category":"section"},{"location":"implementation/#Linear-Solver-(Degree-1)","page":"Implementation Details","title":"Linear Solver (Degree 1)","text":"For ax + b = 0:\n\n_roots_linear(c) = [-c[1] / c[2]]  # c = [b, a]\n\nComplexity: O(1) symbolic operations","category":"section"},{"location":"implementation/#Quadratic-Solver-(Degree-2)","page":"Implementation Details","title":"Quadratic Solver (Degree 2)","text":"For ax^2 + bx + c = 0:\n\nfunction _roots_quadratic(c)\n    a, b, d = c[3], c[2], c[1]  # d is constant term\n    disc = b^2 - 4a*d\n    disc = _aggressive_simplify(disc)\n    sqrt_disc = sqrt(disc)\n    return [(-b - sqrt_disc) / (2a), (-b + sqrt_disc) / (2a)]\nend\n\nKey features:\n\nDiscriminant simplification to reduce expression size\nSymbolic square root handling\n\nComplexity: O(n^2) where n is the expression size","category":"section"},{"location":"implementation/#Cubic-Solver-(Degree-3)","page":"Implementation Details","title":"Cubic Solver (Degree 3)","text":"For ax^3 + bx^2 + cx + d = 0, we use Cardano's method:\n\nStep 1: Depress the cubic (eliminate x^2 term)\n\nSubstitution x = y - fracb3a transforms to: y^3 + py + q = 0\n\nwhere:\n\np = fracca - fracb^23a^2\nq = frac2b^327a^3 - fracbc3a^2 + fracda\n\nStep 2: Compute discriminant\n\nDelta = left(fracq2right)^2 + left(fracp3right)^3\n\nStep 3: Compute cube roots\n\nC = cbrt(-q/2 + √Δ)\nD = cbrt(-q/2 - √Δ)\n\nStep 4: Construct roots\n\nLet omega = e^2pi i3 = -frac12 + fracsqrt32i be a primitive cube root of unity.\n\nroots = [\n    C + D,\n    ω*C + ω²*D,\n    ω²*C + ω*D\n]\n\nStep 5: Shift back\n\nx = y - fracb3a\n\nComplexity: O(n^3) where n is the expression size\n\nImplementation notes:\n\nAggressive simplification applied to p, q, and Delta\nComplex arithmetic handled symbolically\nNumeric cube roots used with symbolic coefficients","category":"section"},{"location":"implementation/#Quartic-Solver-(Degree-4)","page":"Implementation Details","title":"Quartic Solver (Degree 4)","text":"For ax^4 + bx^3 + cx^2 + dx + e = 0, we use Ferrari's method via a resolvent cubic.\n\nStep 1: Depress the quartic (eliminate x^3 term)\n\nSubstitution x = y - fracb4a transforms to: y^4 + py^2 + qy + r = 0\n\nwhere:\n\np = fracca - frac3b^28a^2\nq = fracda + fracb^38a^3 - fracbc2a^2\nr = fracea - frac3b^4256a^4 + fracb^2c16a^3 - fracbd4a^2\n\nStep 2: Solve resolvent cubic\n\nThe resolvent cubic is: 8z^3 - 4pz^2 - 8rz + (4pr - q^2) = 0\n\nLet alpha be any root of this cubic (we use the first one).\n\nStep 3: Decompose into two quadratics\n\nThe depressed quartic factors as:\n\n(y^2 + beta y + (alpha + gamma))(y^2 - beta y + (alpha - gamma)) = 0\n\nwhere:\n\nbeta^2 = 2alpha - p\ngamma = -fracq2beta\n\nStep 4: Solve quadratics\n\nEach quadratic gives two roots using the quadratic formula.\n\nStep 5: Shift back\n\nx = y - fracb4a\n\nComplexity: O(n^4) where n is the expression size\n\nImplementation details:\n\nfunction _roots_quartic(c)\n    # Normalize and extract coefficients\n    a, b, cc, d, e = c[5], c[4], c[3], c[2], c[1]\n    \n    # Depress to y⁴ + py² + qy + r = 0\n    p = cc/a - 3b²/(8a²)\n    q = d/a + b³/(8a³) - b*cc/(2a²)\n    r = e/a - 3b⁴/(256a⁴) + b²*cc/(16a³) - b*d/(4a²)\n    \n    # Simplify intermediate expressions\n    p = _aggressive_simplify(p)\n    q = _aggressive_simplify(q)\n    r = _aggressive_simplify(r)\n    \n    # Resolvent cubic coefficients\n    resolvent = [4p*r - q², -8r, -4p, 8]\n    alphas = _roots_cubic(resolvent)\n    alpha = alphas[1]  # Choose first root\n    \n    # Compute β and γ\n    beta_sq = 2alpha - p\n    beta_sq = _aggressive_simplify(beta_sq)\n    beta = _symbolic_sqrt(beta_sq)\n    gamma = -q/(2beta)\n    gamma = _aggressive_simplify(gamma)\n    \n    # Two quadratics: y² ± β*y + (α ± γ)\n    t1 = beta² - 4(alpha + gamma)\n    t2 = beta² - 4(alpha - gamma)\n    t1 = _aggressive_simplify(t1)\n    t2 = _aggressive_simplify(t2)\n    \n    # Solve both quadratics\n    roots_y = [\n        (-beta - _symbolic_sqrt(t1)) / 2,\n        (-beta + _symbolic_sqrt(t1)) / 2,\n        (beta - _symbolic_sqrt(t2)) / 2,\n        (beta + _symbolic_sqrt(t2)) / 2\n    ]\n    \n    # Shift back\n    return roots_y .- b/(4a)\nend\n\nWarning: Quartic formulas produce extremely large expressions for fully symbolic 4 times 4 matrices (~13.5 MB per eigenvalue).\n\n","category":"section"},{"location":"implementation/#Structure-Detection","page":"Implementation Details","title":"Structure Detection","text":"","category":"section"},{"location":"implementation/#Overview-3","page":"Implementation Details","title":"Overview","text":"Before attempting expensive polynomial root finding, we try to detect exploitable matrix structure.\n\nFile: src/diagonalize.jl (functions starting with _is_* and _detect_*)","category":"section"},{"location":"implementation/#Detection-Hierarchy","page":"Implementation Details","title":"Detection Hierarchy","text":"Structure Detection\n├── Diagonal (_is_diagonal)\n├── Triangular (_is_triangular)\n├── Block-Diagonal (_detect_multiple_blocks)\n├── Persymmetric (_is_persymmetric)\n├── Circulant (_is_circulant)\n├── Block Circulant (_is_block_circulant)\n├── Toeplitz Tridiagonal (_is_toeplitz_tridiagonal)\n├── Anti-Diagonal (_is_antidiagonal)\n├── Permutation (_is_permutation_matrix)\n├── Kronecker Product (_is_kronecker_product)\n└── Special 5×5 (_detect_special_5x5_tridiagonal)","category":"section"},{"location":"implementation/#Implementation-Details-2","page":"Implementation Details","title":"Implementation Details","text":"","category":"section"},{"location":"implementation/#Symbolic-Zero-Detection","page":"Implementation Details","title":"Symbolic Zero Detection","text":"All structure detection relies on checking if expressions are zero:\n\nfunction _issymzero(x)\n    # Try standard iszero\n    try\n        v = Base.iszero(x)\n        if v isa Bool\n            return v\n        end\n    catch\n    end\n    \n    # Try simplify then check\n    try\n        sx = Symbolics.simplify(x)\n        v = Symbolics.iszero(sx)\n        return v === true\n    catch\n    end\n    \n    # Try direct Symbolics.iszero\n    try\n        v = Symbolics.iszero(x)\n        return v === true\n    catch\n    end\n    \n    # Conservative: not proven zero\n    return false\nend\n\nKey insight: We return false if we can't prove it's zero (conservative approach).","category":"section"},{"location":"implementation/#Diagonal-Detection","page":"Implementation Details","title":"Diagonal Detection","text":"function _is_diagonal(mat)\n    m, n = size(mat)\n    for i in 1:m, j in 1:n\n        i == j && continue\n        !_issymzero(mat[i, j]) && return false\n    end\n    return true\nend\n\nComplexity: O(n^2) symbolic zero checks","category":"section"},{"location":"implementation/#Block-Diagonal-Detection","page":"Implementation Details","title":"Block-Diagonal Detection","text":"Finds all block-diagonal structure using a greedy algorithm:\n\nfunction _detect_multiple_blocks(mat)\n    n = size(mat, 1)\n    blocks = Tuple{Int,Int}[]\n    current_start = 1\n    \n    while current_start <= n\n        # Find smallest block starting at current_start\n        block_end = n  # Default: extend to end\n        \n        for k in current_start:(n-1)\n            # Check if [current_start:k, k+1:n] and [k+1:n, current_start:k] are zero\n            upper_right_zero = all(_issymzero, mat[i, j] \n                for i in current_start:k, j in (k+1):n)\n            lower_left_zero = all(_issymzero, mat[i, j] \n                for i in (k+1):n, j in current_start:k)\n            \n            if upper_right_zero && lower_left_zero\n                block_end = k\n                break\n            end\n        end\n        \n        push!(blocks, (current_start, block_end))\n        current_start = block_end + 1\n    end\n    \n    # Only return if we found actual blocks (more than just the whole matrix)\n    return length(blocks) > 1 ? blocks : nothing\nend\n\nComplexity: O(n^4) symbolic operations in worst case","category":"section"},{"location":"implementation/#Circulant-Detection","page":"Implementation Details","title":"Circulant Detection","text":"function _is_circulant(mat)\n    n = size(mat, 1)\n    first_row = mat[1, :]\n    \n    # Check each row is a cyclic shift of the first row\n    for i in 2:n\n        for j in 1:n\n            expected_idx = mod1(j - (i - 1), n)\n            if !_issymzero(mat[i, j] - first_row[expected_idx])\n                return false\n            end\n        end\n    end\n    \n    return true\nend\n\nComplexity: O(n^2) symbolic zero checks","category":"section"},{"location":"implementation/#Block-Circulant-Detection","page":"Implementation Details","title":"Block Circulant Detection","text":"Tries different block sizes k where n is divisible by k:\n\nfunction _is_block_circulant(mat)\n    m, n = size(mat)\n    m == n || return nothing\n    \n    # Try different block sizes\n    for k in 2:div(m, 2)\n        m % k == 0 || continue\n        n_blocks = div(m, k)\n        \n        # Extract blocks from first block row\n        blocks = [mat[1:k, (i-1)*k+1:i*k] for i in 1:n_blocks]\n        \n        # Check if each block row is a cyclic shift\n        is_block_circulant = true\n        for block_row in 2:n_blocks\n            for block_col in 1:n_blocks\n                shift_idx = mod1(block_col - (block_row - 1), n_blocks)\n                expected_block = blocks[shift_idx]\n                actual_block = mat[(block_row-1)*k+1:block_row*k, \n                                  (block_col-1)*k+1:block_col*k]\n                \n                # Check if blocks match\n                if !all(_issymzero(actual_block[i, j] - expected_block[i, j]) \n                       for i in 1:k, j in 1:k)\n                    is_block_circulant = false\n                    break\n                end\n            end\n            is_block_circulant || break\n        end\n        \n        if is_block_circulant\n            return (n_blocks, k, blocks)\n        end\n    end\n    \n    return nothing\nend\n\nComplexity: O(n^4) in worst case (trying all block sizes)","category":"section"},{"location":"implementation/#Kronecker-Product-Detection","page":"Implementation Details","title":"Kronecker Product Detection","text":"Tries different factorizations N = m times n:\n\nfunction _is_kronecker_product(mat)\n    N = size(mat, 1)\n    \n    # Try factorizations N = m * n\n    for m in 2:div(N, 2)\n        N % m == 0 || continue\n        n = div(N, m)\n        \n        # Extract candidate B from (1,1) block\n        B_candidate = mat[1:n, 1:n]\n        \n        # Try to extract A by looking at block pattern\n        A = zeros(eltype(mat), m, m)\n        \n        for i_block in 1:m, j_block in 1:m\n            block = mat[(i_block-1)*n+1:i_block*n, (j_block-1)*n+1:j_block*n]\n            \n            # Find scalar such that block = scalar * B_candidate\n            scalar = find_scalar_multiple(block, B_candidate)\n            \n            # Verify block = scalar * B_candidate\n            if verify_match(block, scalar, B_candidate)\n                A[i_block, j_block] = scalar\n            else\n                @goto next_factorization\n            end\n        end\n        \n        return (A, B_candidate, m, n)\n        \n        @label next_factorization\n    end\n    \n    return nothing\nend\n\nComplexity: O(n^5) in worst case","category":"section"},{"location":"implementation/#Permutation-Matrix-Detection","page":"Implementation Details","title":"Permutation Matrix Detection","text":"function _is_permutation_matrix(A)\n    n = size(A, 1)\n    \n    # Check each row has exactly one 1 and rest zeros\n    for i in 1:n\n        count_ones = sum(_issymzero(A[i, j] - 1) for j in 1:n)\n        count_ones == 1 || return false\n        \n        # Check rest are zeros\n        for j in 1:n\n            !_issymzero(A[i, j] - 1) && !_issymzero(A[i, j]) && return false\n        end\n    end\n    \n    # Check each column has exactly one 1\n    for j in 1:n\n        count_ones = sum(_issymzero(A[i, j] - 1) for i in 1:n)\n        count_ones == 1 || return false\n    end\n    \n    return true\nend\n\nComplexity: O(n^2) symbolic zero checks\n\n","category":"section"},{"location":"implementation/#Special-Pattern-Solvers","page":"Implementation Details","title":"Special Pattern Solvers","text":"","category":"section"},{"location":"implementation/#Circulant-Matrices","page":"Implementation Details","title":"Circulant Matrices","text":"Theory: A circulant matrix has eigenvalues given by the DFT of its first row.\n\nFor circulant matrix C = textcirc(c_0 c_1 ldots c_n-1):\n\nlambda_j = sum_k c_k omega^jk\n\nfor j = 0 1 ldots n-1\n\nwhere omega = e^2pi in.\n\nfunction _circulant_eigenvalues(mat)\n    n = size(mat, 1)\n    first_row = mat[1, :]\n    eigenvalues = Vector{Any}(undef, n)\n    \n    for j in 0:(n-1)\n        λ = first_row[1]  # c₀ term\n        \n        for k in 1:(n-1)\n            θ = 2π * j * k / n\n            ω_power = cos(θ) + im * sin(θ)\n            λ += first_row[k+1] * ω_power\n        end\n        \n        eigenvalues[j+1] = Symbolics.simplify(λ)\n    end\n    \n    return eigenvalues\nend\n\nComplexity: O(n^2) symbolic operations (much better than O(n^3) for general case)","category":"section"},{"location":"implementation/#Block-Circulant-Matrices","page":"Implementation Details","title":"Block Circulant Matrices","text":"Theory: Block circulant reduces to n separate k times k eigenvalue problems.\n\nFor block circulant with blocks A_0 A_1 ldots A_n-1:\n\nEigenvalues = bigcup_j texteigvals(D_j)\n\nwhere D_j = sum_k omega^jk A_k and omega = e^2pi in.\n\nfunction _block_circulant_eigenvalues(mat, n_blocks, block_size, blocks)\n    all_eigenvalues = []\n    \n    for j in 0:(n_blocks-1)\n        # Compute Dⱼ = Σₖ ωʲᵏ Aₖ\n        D_j = zeros(eltype(mat), block_size, block_size)\n        \n        for k in 0:(n_blocks-1)\n            θ = 2π * j * k / n_blocks\n            ω_power = cos(θ) + im * sin(θ)\n            D_j .+= ω_power .* blocks[k + 1]\n        end\n        \n        # Recursively solve k×k eigenvalue problem\n        D_j = Symbolics.simplify.(D_j)\n        vals_j, _, _ = symbolic_eigenvalues(D_j)\n        append!(all_eigenvalues, vals_j)\n    end\n    \n    return all_eigenvalues\nend\n\nComplexity: O(n times T(k)) where T(k) is time to solve k times k matrix","category":"section"},{"location":"implementation/#Toeplitz-Tridiagonal-Matrices","page":"Implementation Details","title":"Toeplitz Tridiagonal Matrices","text":"Theory: Symmetric Toeplitz tridiagonal has closed-form eigenvalues via orthogonal polynomials.\n\nFor matrix with diagonal a and off-diagonals b:\n\nlambda_k = a + 2b cosleft(frackpin+1right)\n\nfor k = 1 2 ldots n\n\nfunction _toeplitz_tridiagonal_eigenvalues(n, a, b, c)\n    eigenvalues = Vector{Any}(undef, n)\n    \n    for k in 1:n\n        θ = k * π / (n + 1)\n        λₖ = a + 2 * b * cos(θ)\n        eigenvalues[k] = Symbolics.simplify(λₖ)\n    end\n    \n    return eigenvalues\nend\n\nComplexity: O(n) symbolic operations (optimal!)","category":"section"},{"location":"implementation/#Kronecker-Products","page":"Implementation Details","title":"Kronecker Products","text":"Theory: If A has eigenvalues lambda_i and B has eigenvalues mu_j, then A otimes B has eigenvalues lambda_i mu_j.\n\nfunction _kronecker_eigenvalues(A, B, m, n)\n    # Compute eigenvalues of A\n    λ_A, _, _ = symbolic_eigenvalues(A)\n    \n    # Compute eigenvalues of B\n    λ_B, _, _ = symbolic_eigenvalues(B)\n    \n    # Compute all products λᵢ * μⱼ\n    eigenvalues = []\n    for λ in λ_A, μ in λ_B\n        push!(eigenvalues, λ * μ)\n    end\n    \n    return eigenvalues\nend\n\nComplexity: O(T(m) + T(n) + mn) where T(k) is time to solve k times k matrix","category":"section"},{"location":"implementation/#Permutation-Matrices","page":"Implementation Details","title":"Permutation Matrices","text":"Theory: Eigenvalues are roots of unity determined by cycle structure.\n\nFor a cycle of length k: eigenvalues are e^2pi ijk for j = 0 1 ldots k-1\n\nfunction _compute_permutation_eigenvalues(A)\n    cycles = _permutation_to_cycles(A)\n    eigenvalues = []\n    \n    for cycle_length in cycles\n        if cycle_length == 1\n            push!(eigenvalues, 1)  # Fixed point\n        elseif cycle_length == 2\n            push!(eigenvalues, 1, -1)  # Transposition\n        else\n            # k-th roots of unity\n            for j in 0:(cycle_length - 1)\n                angle = 2π * j / cycle_length\n                push!(eigenvalues, exp(im * angle))\n            end\n        end\n    end\n    \n    return eigenvalues\nend\n\nComplexity: O(n) to find cycles, O(n) to generate eigenvalues","category":"section"},{"location":"implementation/#Anti-Diagonal-Matrices","page":"Implementation Details","title":"Anti-Diagonal Matrices","text":"Theory: Symmetric anti-diagonal has eigenvalues in pm pairs.\n\nFor anti-diagonal entries a_1 a_2 ldots a_n:\n\nOdd n: eigenvalues are a_textmid pm a_1 pm a_2 ldots pm a_textmid-1\nEven n: eigenvalues are pm a_1 pm a_2 ldots pm a_n2\n\nfunction _antidiagonal_eigenvalues(mat)\n    n = size(mat, 1)\n    antidiag = [mat[i, n + 1 - i] for i in 1:n]\n    \n    if n % 2 == 1\n        # Odd: one middle eigenvalue, rest in pairs\n        mid = (n + 1) ÷ 2\n        eigenvalues = [antidiag[mid]]\n        for i in 1:mid-1\n            push!(eigenvalues, antidiag[i], -antidiag[i])\n        end\n    else\n        # Even: all in pairs\n        eigenvalues = []\n        for i in 1:n÷2\n            push!(eigenvalues, antidiag[i], -antidiag[i])\n        end\n    end\n    \n    return eigenvalues\nend\n\nComplexity: O(n) symbolic operations","category":"section"},{"location":"implementation/#Persymmetric-Splitting","page":"Implementation Details","title":"Persymmetric Splitting","text":"Theory: Symmetric persymmetric matrices (Qij = Qn+1-j n+1-i) can be split into two half-sized blocks.\n\nfunction _persymmetric_split(mat)\n    n = size(mat, 1)\n    n % 2 != 0 && return nothing  # Only for even n\n    \n    # Build transformation matrix P = [(I+J)/√2, (I-J)/√2]\n    # where J is the exchange matrix (anti-identity)\n    \n    half = div(n, 2)\n    P = zeros(eltype(mat), n, n)\n    \n    # First half: e_i + e_{n+1-i}\n    for i in 1:half\n        P[i, i] = 1\n        P[n+1-i, i] = 1\n    end\n    \n    # Second half: e_i - e_{n+1-i}\n    for i in 1:half\n        P[i, half+i] = 1\n        P[n+1-i, half+i] = -1\n    end\n    \n    # Transform: Q_new = P^T * Q * P\n    Q_transformed = transpose(P) * mat * P\n    \n    # Extract blocks (and divide by 2 for normalization)\n    block1 = Q_transformed[1:half, 1:half] ./ 2\n    block2 = Q_transformed[half+1:end, half+1:end] ./ 2\n    \n    return (block1, block2, P)\nend\n\nComplexity: O(n^3) for matrix multiplication\n\n","category":"section"},{"location":"implementation/#Eigenvector-Computation","page":"Implementation Details","title":"Eigenvector Computation","text":"","category":"section"},{"location":"implementation/#Two-Approaches","page":"Implementation Details","title":"Two Approaches","text":"SymbolicDiagonalization.jl uses two complementary methods:\n\nAdjugate method (for small matrices, leq 3 times 3)\nRREF-based nullspace (general case)\n\nFile: src/rref.jl, src/diagonalize.jl","category":"section"},{"location":"implementation/#Adjugate-Method","page":"Implementation Details","title":"Adjugate Method","text":"For A - lambda I singular (lambda is eigenvalue), the adjugate matrix textadj(A - lambda I) has all columns in the nullspace.\n\nfunction _adjugate_vectors(M)\n    n = size(M, 1)\n    n <= 3 || return []  # Only for small matrices\n    \n    adj = _adjugate(M)\n    \n    # Return first non-zero column\n    for j in 1:n\n        col = Symbolics.simplify.(adj[:, j])\n        all(_issymzero, col) && continue\n        return [col]  # Return immediately\n    end\n    \n    return []\nend\n\nfunction _adjugate(M)\n    n = size(M, 1)\n    adj = Matrix{eltype(M)}(undef, n, n)\n    \n    for i in 1:n, j in 1:n\n        minor_det = _minor_det(M, i, j)\n        adj[j, i] = (-1)^(i + j) * minor_det\n    end\n    \n    return Symbolics.simplify.(adj)\nend\n\nAdvantages:\n\nAvoids RREF pivoting issues\nMore compact expressions for small matrices\n\nDisadvantages:\n\nOnly works for n leq 3 (determinant computation explodes)\nMay return zero vector if unlucky","category":"section"},{"location":"implementation/#RREF-Based-Nullspace","page":"Implementation Details","title":"RREF-Based Nullspace","text":"General method that works for any size:\n\nfunction _nullspace(M)\n    # Simplify entries first\n    simplified = Symbolics.simplify.(M)\n    \n    # Compute RREF\n    R, pivots = _rref(Symbolics.expand.(simplified))\n    \n    m, n = size(R)\n    free = setdiff(1:n, pivots)  # Free variables\n    \n    vectors = []\n    for f in free\n        # Set free variable to 1, solve for pivot variables\n        v = fill(zero(eltype(R)), n)\n        v[f] = one(eltype(R))\n        \n        for (row, pivot_col) in enumerate(pivots)\n            v[pivot_col] = Symbolics.simplify(-R[row, f])\n        end\n        \n        push!(vectors, Symbolics.simplify.(v))\n    end\n    \n    return vectors\nend\n\nComplexity: O(n^3) symbolic operations","category":"section"},{"location":"implementation/#RREF-Algorithm","page":"Implementation Details","title":"RREF Algorithm","text":"Row reduction to reduced row echelon form:\n\nfunction _rref(M)\n    A = copy(Matrix(M))\n    m, n = size(A)\n    pivots = Int[]\n    row = 1\n    \n    for col in 1:n\n        # Find pivot\n        pivot_row = _find_pivot(A, row, col)\n        isnothing(pivot_row) && continue\n        \n        # Swap rows\n        if pivot_row != row\n            A[row, :], A[pivot_row, :] = A[pivot_row, :], A[row, :]\n        end\n        \n        # Normalize pivot row\n        pivot = Symbolics.simplify(A[row, col])\n        A[row, :] .= Symbolics.simplify.(A[row, :] ./ pivot)\n        \n        # Eliminate column in all other rows\n        for r in 1:m\n            r == row && continue\n            factor = A[r, col]\n            _issymzero(factor) && continue\n            A[r, :] .= Symbolics.simplify.(A[r, :] .- factor .* A[row, :])\n        end\n        \n        push!(pivots, col)\n        row += 1\n        row > m && break\n    end\n    \n    return A, pivots\nend\n\nKey features:\n\nSimplification after each operation to keep expressions manageable\nSymbolic pivot selection (uses _issymzero)\nFull row elimination (not just below pivot)\n\nComplexity: O(mn^2 times s) where s is average expression size\n\n","category":"section"},{"location":"implementation/#Expression-Management","page":"Implementation Details","title":"Expression Management","text":"","category":"section"},{"location":"implementation/#The-Expression-Explosion-Problem","page":"Implementation Details","title":"The Expression Explosion Problem","text":"Symbolic computation faces a fundamental challenge: expressions grow exponentially without careful management.\n\nExample: A 3 times 3 symbolic matrix can produce eigenvalues with 1000+ terms. A 4 times 4 symbolic matrix can produce eigenvalues with 10,000+ terms (~13.5 MB each!).","category":"section"},{"location":"implementation/#Strategy:-Aggressive-Simplification","page":"Implementation Details","title":"Strategy: Aggressive Simplification","text":"We apply simplification at every intermediate step of computation:\n\nfunction _aggressive_simplify(expr; max_terms = 10000)\n    !_is_symbolic_coeff(expr) && return expr\n    \n    # Expand first to collect all terms\n    expanded = Symbolics.expand(expr)\n    \n    # Check complexity\n    _check_expression_size(expanded, max_terms)\n    \n    # Simplify\n    simplified = Symbolics.simplify(expanded)\n    \n    # Try to factor perfect squares (TODO: not yet implemented)\n    factored = _try_factor_perfect_square(simplified)\n    \n    return factored\nend\n\nApplied in:\n\nQuadratic discriminant\nCubic coefficients p, q, Delta\nQuartic coefficients p, q, r, and intermediate beta^2, gamma, t_1, t_2\nRREF operations\nEigenvector construction","category":"section"},{"location":"implementation/#Expression-Size-Estimation","page":"Implementation Details","title":"Expression Size Estimation","text":"We estimate expression complexity by counting operations:\n\nfunction _estimate_expr_size(expr)\n    !_is_symbolic_coeff(expr) && return 1\n    \n    try\n        unwrapped = Symbolics.unwrap(expr)\n        return _count_operations(unwrapped)\n    catch\n        return 1\n    end\nend\n\nfunction _count_operations(x)\n    # Base case: leaf node\n    if x isa Number || !isdefined(x, :f)\n        return 1\n    end\n    \n    # Recursive case: count children\n    if isdefined(x, :arguments)\n        args = getfield(x, :arguments)\n        return 1 + sum(_count_operations, args; init=0)\n    end\n    \n    return 1\nend","category":"section"},{"location":"implementation/#Complexity-Threshold-Errors","page":"Implementation Details","title":"Complexity Threshold Errors","text":"When expressions exceed limits, we throw helpful errors:\n\nthrow(ExpressionComplexityError(\n    \"\"\"Expression has grown too large (≈$size terms, limit: $max_terms).\n    \n    Suggestions:\n    1. Reduce matrix size (try 2×2 or 3×3 instead of 4×4)\n    2. Use fewer symbolic variables\n    3. Exploit matrix structure\n    4. Use numeric eigenvalues\n    5. Increase limit with max_terms parameter (caution!)\n    \"\"\"\n))","category":"section"},{"location":"implementation/#Timeout-Mechanism","page":"Implementation Details","title":"Timeout Mechanism","text":"Long-running computations can be interrupted:\n\nfunction _with_timeout(f, timeout_seconds, degree)\n    task = @async f()\n    timeout_task = @async (sleep(timeout_seconds); true)\n    \n    # Wait for either task or timeout\n    while !istaskdone(task) && !istaskdone(timeout_task)\n        sleep(0.1)\n    end\n    \n    if istaskdone(timeout_task)\n        # Timeout occurred\n        schedule(task, InterruptException(), error=true)\n        throw(ComputationTimeoutError(\"Computation exceeded $timeout_seconds seconds\"))\n    end\n    \n    return fetch(task)\nend\n\nDefault timeout: 300 seconds (5 minutes) Can be disabled: Set timeout = nothing","category":"section"},{"location":"implementation/#Symbolic-Square-Root-for-Complex-Numbers","page":"Implementation Details","title":"Symbolic Square Root for Complex Numbers","text":"Julia's sqrt(::Complex) has boolean checks that fail for symbolic values. We implement it directly:\n\nfunction _symbolic_sqrt(x)\n    !(x isa Complex) && return sqrt(x)\n    \n    # For Complex{Num}, implement formula manually:\n    # sqrt(a + bi) = sqrt((r+a)/2) + i*sign(b)*sqrt((r-a)/2)\n    # where r = sqrt(a² + b²)\n    \n    a = real(x)\n    b = imag(x)\n    r = sqrt(a^2 + b^2)\n    \n    real_part = sqrt((r + a) / 2)\n    imag_part = sqrt((r - a) / 2)\n    \n    return Complex(real_part, imag_part)\nend\n\n","category":"section"},{"location":"implementation/#Performance-Considerations","page":"Implementation Details","title":"Performance Considerations","text":"","category":"section"},{"location":"implementation/#Complexity-Summary","page":"Implementation Details","title":"Complexity Summary","text":"Operation Complexity Notes\nBareiss determinant O(n^3) Polynomial expression growth\nCoefficient extraction O(n) Using derivatives\nQuadratic formula O(n^2) Expression size grows quadratically\nCubic formula O(n^3) Cardano's method\nQuartic formula O(n^4) Ferrari's method\nRREF O(mn^2 times s) s = average expression size\nNullspace O(n^3 times s) After RREF\nCirculant eigenvalues O(n^2) DFT-based\nTridiagonal eigenvalues O(n) Closed-form formula\nBlock decomposition O(k times T(nk)) k blocks of size nk","category":"section"},{"location":"implementation/#Bottlenecks","page":"Implementation Details","title":"Bottlenecks","text":"Quartic formula: Produces massive expressions for fully symbolic 4×4 matrices\nRREF: Simplification at each step can be slow for large expressions\nStructure detection: O(n⁴) for some patterns (block circulant, Kronecker)\nSymbolic simplification: Symbolics.jl simplification is not always fast","category":"section"},{"location":"implementation/#Optimization-Strategies","page":"Implementation Details","title":"Optimization Strategies","text":"For users:\n\nUse structured matrices (block-diagonal, circulant, tridiagonal)\nSubstitute numeric values for some variables\nRequest eigenvalues only (skip eigenvectors)\nUse smaller matrices (2 times 2, 3 times 3 much faster than 4 times 4)\nSet expand=false to skip polynomial expansion\n\nFor developers:\n\nAdd more special pattern detectors\nImprove expression simplification (factor perfect squares, etc.)\nCache intermediate results\nParallelize independent computations (when thread-safe)\nAdd more structural decompositions (Schur complement, etc.)","category":"section"},{"location":"implementation/#Memory-Usage","page":"Implementation Details","title":"Memory Usage","text":"Approximate memory usage for fully symbolic n times n matrices:\n\nSize Eigenvalues With Eigenvectors\n2 times 2 ~1 KB ~5 KB\n3 times 3 ~100 KB ~500 KB\n4 times 4 ~50 MB ~200 MB\n5 times 5 N/A* N/A*\n\n*5 times 5 requires special structure (not general case)","category":"section"},{"location":"implementation/#Parallelization-Challenges","page":"Implementation Details","title":"Parallelization Challenges","text":"Why we don't parallelize:\n\nSymbolics.jl uses task-local storage for hashconsing (expression deduplication), which is not thread-safe.\n\nAttempting to use Threads.@threads causes crashes:\n\n# DON'T DO THIS:\nThreads.@threads for v in vals\n    vecs = _nullspace(mat .- v .* I)  # CRASHES!\nend\n\nPotential solution: Use process-based parallelism (Distributed.jl) instead of threads.","category":"section"},{"location":"implementation/#Test-Coverage","page":"Implementation Details","title":"Test Coverage","text":"The test suite includes 172 tests covering:\n\nAll root solvers (linear through quartic)\nAll structure detectors\nAll special pattern solvers\nEdge cases (zero matrices, identity, etc.)\nError handling (timeouts, complexity errors)\n\nExecution time: 37.4 seconds\n\n","category":"section"},{"location":"implementation/#Future-Improvements","page":"Implementation Details","title":"Future Improvements","text":"","category":"section"},{"location":"implementation/#Algorithm-Enhancements","page":"Implementation Details","title":"Algorithm Enhancements","text":"Schur decomposition: For upper triangular form\nQR algorithm: Iterative eigenvalue refinement\nLanczos algorithm: For large sparse matrices\nPower method: For dominant eigenvalue","category":"section"},{"location":"implementation/#Pattern-Detection","page":"Implementation Details","title":"Pattern Detection","text":"Hamiltonian matrices: J-orthogonal structure\nHankel matrices: Related to Toeplitz\nCauchy matrices: Explicit determinant formulas\nVandermonde matrices: Closed-form determinant","category":"section"},{"location":"implementation/#Expression-Optimization","page":"Implementation Details","title":"Expression Optimization","text":"Perfect square factoring: Detect and factor (a-b)^2 + c^2\nCommon subexpression elimination: Deduplicate repeated subexpressions\nGröbner basis reduction: Polynomial ideal membership\nNumerical stability analysis: Detect ill-conditioned expressions","category":"section"},{"location":"implementation/#User-Experience","page":"Implementation Details","title":"User Experience","text":"Progress bars: For long computations\nIncremental results: Return partial results before timeout\nSymbolic assumptions: Propagate assumptions (real, positive, etc.)\nPretty printing: Better display of large expressions\n\n","category":"section"},{"location":"implementation/#References","page":"Implementation Details","title":"References","text":"","category":"section"},{"location":"implementation/#Algorithms","page":"Implementation Details","title":"Algorithms","text":"Bareiss, E.H. (1968). \"Sylvester's identity and multistep integer-preserving Gaussian elimination.\" Mathematics of Computation 22(103): 565-578.\nCardano, G. (1545). Ars Magna (The Great Art). Closed-form solution for cubic equations.\nFerrari, L. (1545). Solution of quartic equations (published in Cardano's Ars Magna).\nDavis, P.J. (1979). Circulant Matrices. Wiley-Interscience. Theory of circulant eigenvalues.\nTrench, W.F. (1999). \"Numerical solution of the eigenvalue problem for Hermitian Toeplitz matrices.\" SIAM Journal on Matrix Analysis and Applications 10(2): 135-146.","category":"section"},{"location":"implementation/#Mathematical-Background","page":"Implementation Details","title":"Mathematical Background","text":"Abel, N.H. (1826). \"Beweis der Unmöglichkeit, algebraische Gleichungen von höheren Graden als dem vierten allgemein aufzulösen.\" Proof that degree geq 5 has no general formula.\nGalois, É. (1832). \"Mémoire sur les conditions de résolubilité des équations par radicaux.\" Galois theory foundation.\nHorn, R.A. & Johnson, C.R. (2013). Matrix Analysis (2nd ed.). Cambridge University Press. Comprehensive matrix theory reference.","category":"section"},{"location":"implementation/#Implementation","page":"Implementation Details","title":"Implementation","text":"Symbolics.jl Documentation. https://symbolics.juliasymbolics.org/\nSymbolicUtils.jl. https://symbolicutils.juliasymbolics.org/\n\n","category":"section"},{"location":"implementation/#Appendix:-File-Organization","page":"Implementation Details","title":"Appendix: File Organization","text":"src/\n├── SymbolicDiagonalization.jl  # Module definition and exports\n├── charpoly.jl                 # Characteristic polynomial (Bareiss)\n├── roots.jl                    # Root solvers (degrees 1-4)\n├── rref.jl                     # RREF and nullspace computation\n└── diagonalize.jl              # Main API and pattern detection\n    ├── Public API (eigen, eigvals, symbolic_*)\n    ├── Structure Detection (_is_*, _detect_*)\n    ├── Special Pattern Solvers (_*_eigenvalues)\n    ├── Eigenvector Computation (_adjugate, _nullspace)\n    └── Utility Functions\n\nLines of code:\n\ncharpoly.jl: ~60 lines\nroots.jl: ~390 lines\nrref.jl: ~75 lines\ndiagonalize.jl: ~1495 lines\nTotal: ~2020 lines of implementation code\n\n\n\nThis implementation documentation was last updated: December 11, 2025","category":"section"},{"location":"#SymbolicDiagonalization.jl","page":"Home","title":"SymbolicDiagonalization.jl","text":"Status: Functional Prototype\n\nSymbolicDiagonalization.jl provides symbolic matrix diagonalization for Julia using Symbolics.jl with closed-form root solvers and structure detection.","category":"section"},{"location":"#Vision","page":"Home","title":"Vision","text":"The Abel-Ruffini theorem limits closed-form solutions to polynomials of degree leq 4, meaning general 5 times 5+ matrices cannot be solved symbolically. However, many real-world matrices have exploitable structure.\n\nGoal: Build automatic structure detection to solve larger symbolic problems by recognizing and exploiting special patterns (block-diagonal, persymmetric, tridiagonal, circulant, Kronecker products, etc.).\n\nCurrent state: Functional prototype with 9 special pattern solvers working for any size n. Comprehensive test coverage (172 tests, all passing). Ready for experimental use.","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using SymbolicDiagonalization\nusing LinearAlgebra\nusing Symbolics\n\n@variables a b c\nmat = [a 1 0; 0 b 1; 0 0 c]\n\nE = eigen(mat)        # Eigen object with .values and .vectors\nλ = eigvals(mat)      # eigenvalues only (faster)","category":"section"},{"location":"#API-Overview","page":"Home","title":"API Overview","text":"","category":"section"},{"location":"#LinearAlgebra-Interface-(Recommended)","page":"Home","title":"LinearAlgebra Interface (Recommended)","text":"eigen(A; kwargs...) - Returns Eigen object with .values and .vectors fields\neigvals(A; kwargs...) - Returns eigenvalues only (skips eigenvector computation)","category":"section"},{"location":"#Direct-API-(Advanced)","page":"Home","title":"Direct API (Advanced)","text":"characteristic_polynomial(A; var) → (poly, coeffs, λ)\nsymbolic_eigenvalues(A; kwargs...) → (vals, poly, λ)\nsymbolic_eigenpairs(A; kwargs...) → eigenvalue-eigenvector pairs\nsymbolic_diagonalize(A; kwargs...) → (P, D, pairs) (throws if not diagonalizable)","category":"section"},{"location":"#Common-Options","page":"Home","title":"Common Options","text":"structure - Matrix type hint: :auto, :hermitian, :symmetric, :unitary\nexpand - Expand polynomial coefficients (default: true)\nsimplify - Simplify eigenvalues/eigenvectors (default: false)\ntimeout - Maximum computation time in seconds (default: 300)\nmax_terms - Expression complexity limit (default: 10000)\ncomplexity_threshold - Warn when symbolic variable count exceeds this (default: 5)\ncheck_diagonalizable - Verify eigenvectors are independent (default: true)\nvar - Custom variable for characteristic polynomial (default: auto-generated)","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"#Block-Diagonal-Matrix","page":"Home","title":"Block-Diagonal Matrix","text":"@variables a b c d λ\nmat = [a  b  0  0;\n       b  a  0  0;\n       0  0  c  d;\n       0  0  d  c]\n\nvals = eigvals(mat)\n# Result: [a+b, a-b, c+d, c-d]","category":"section"},{"location":"#Circulant-Matrix-(Any-Size)","page":"Home","title":"Circulant Matrix (Any Size)","text":"@variables a b c\nmat = [a  b  c;\n       c  a  b;\n       b  c  a]\n\nvals = eigvals(mat)\n# Uses DFT: eigenvalues are linear combinations with roots of unity","category":"section"},{"location":"#Kronecker-Product","page":"Home","title":"Kronecker Product","text":"@variables a b c d\nA = [a 0; 0 b]\nB = [c 0; 0 d]\nmat = kron(A, B)  # 4×4 matrix\n\nvals = eigvals(mat)\n# Result: [a*c, a*d, b*c, b*d] (products of eigenvalues)","category":"section"},{"location":"#Symmetric-Toeplitz-Tridiagonal","page":"Home","title":"Symmetric Toeplitz Tridiagonal","text":"@variables a b\nmat = [a  b  0;\n       b  a  b;\n       0  b  a]\n\nvals = eigvals(mat)\n# Closed-form using cosine formula: a + 2b*cos(kπ/(n+1))","category":"section"},{"location":"#Permutation-Matrix","page":"Home","title":"Permutation Matrix","text":"# 3-cycle permutation\nmat = [0  1  0;\n       0  0  1;\n       1  0  0]\n\nvals = eigvals(mat)\n# Result: roots of unity [1, ω, ω²] where ω = exp(2πi/3)","category":"section"},{"location":"#Implementation-Details","page":"Home","title":"Implementation Details","text":"","category":"section"},{"location":"#Characteristic-Polynomial","page":"Home","title":"Characteristic Polynomial","text":"Computed via fraction-free Bareiss determinant on lambda I - A\nCoefficients extracted by differentiating at lambda = 0\nWorks with symbolic rings","category":"section"},{"location":"#Closed-Form-Root-Solvers-(Degrees-1-4)","page":"Home","title":"Closed-Form Root Solvers (Degrees 1-4)","text":"Linear, quadratic, cubic (Cardano), quartic (Ferrari)\nQuartic produces very large expressions for fully symbolic matrices\nDegrees geq 5 require structure detection or throw error","category":"section"},{"location":"#Structure-Detection-(13-Patterns-Implemented)","page":"Home","title":"Structure Detection (13 Patterns Implemented)","text":"Successfully implemented patterns:\n\nDiagonal - Trivial O(n) eigenvalue extraction\nTriangular - Diagonal elements are eigenvalues\nBlock-Diagonal - Recursive detection and solving (works with any block sizes)\nPersymmetric - Qij = Qn+1-jn+1-i, splits into half-sized eigenproblems\nCirculant - Uses DFT, works for any size n\nBlock Circulant - Block-level DFT approach\nSymmetric Toeplitz Tridiagonal - Closed-form cosine formula for any n\nAnti-Diagonal - Eigenvalues come in pm pairs\nPermutation Matrices - Eigenvalues are roots of unity\nKronecker Products - Eigenvalues are products of factor eigenvalues\nSpecial 5 times 5 pattern [b,d,b,b] - Known closed-form solution\nSpecial 5 times 5 pattern [b,b,d,b] - Known closed-form solution\nJordan Blocks - Repeated eigenvalue with known structure\n\nDetection robustness: Currently basic pattern matching. Room for improvement with more sophisticated algorithms and tolerance handling for near-patterns.","category":"section"},{"location":"#Eigenvector-Computation","page":"Home","title":"Eigenvector Computation","text":"Nullspace via RREF-based row reduction\nsymbolic_diagonalize verifies eigenvector independence\nError handling for non-diagonalizable matrices","category":"section"},{"location":"#Current-Capabilities-and-Limitations","page":"Home","title":"Current Capabilities and Limitations","text":"","category":"section"},{"location":"#What-Works-Well","page":"Home","title":"What Works Well","text":"Small matrices (leq 4 times 4): Full symbolic diagonalization using closed-form root solvers\nStructured matrices (any size): 13 special patterns with efficient O(n) to O(n^2) algorithms\nMixed symbolic/numeric: Handles partially symbolic matrices effectively\nComprehensive testing: 172 passing tests (37.4s) covering diverse scenarios","category":"section"},{"location":"#Known-Limitations","page":"Home","title":"Known Limitations","text":"General 5 times 5+ matrices: No closed-form solver (Abel-Ruffini theorem) - requires structure detection\nExpression complexity: Fully symbolic 4 times 4 quartic eigenvalues can be very large (~13.5 MB)\nSimplification: Basic simplification only; results may not be in minimal form\nPattern detection robustness: Exact pattern matching; may miss near-patterns or numerically perturbed structures","category":"section"},{"location":"#Development-Priorities","page":"Home","title":"Development Priorities","text":"","category":"section"},{"location":"#High-Priority","page":"Home","title":"High Priority","text":"Enhanced structure detection: More robust algorithms with tolerance handling for near-patterns\nAdditional patterns: Arrow matrices, general Hankel, more tridiagonal families\nExpression simplification: Deeper integration with Symbolics.jl simplification\nPerformance optimization: Caching, memoization for repeated subproblems","category":"section"},{"location":"#Medium-Priority","page":"Home","title":"Medium Priority","text":"Eigenvalue multiplicity: Better handling of repeated eigenvalues and generalized eigenvectors\nNumerical fallback: Automatic hybrid symbolic-numeric mode for borderline cases\nDocumentation: More examples, tutorials, pattern discovery guides\nSymbolic conditioning: Analyze stability and condition numbers symbolically","category":"section"},{"location":"#Long-Term-Vision","page":"Home","title":"Long-Term Vision","text":"Machine learning: Pattern recognition using trained models\nUser pattern libraries: Custom pattern registration and sharing\nSymbolic perturbation: First-order eigenvalue sensitivity analysis\nParallel processing: Multi-threaded block decomposition","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"#User-Guides","page":"Home","title":"User Guides","text":"User Guide - Installation, basic usage, workflow examples\nAPI Reference - Complete function signatures and keyword arguments\nPattern Library - All 13 implemented patterns with examples and complexity analysis\nGroup Theory Examples - Worked examples using group theory and symmetry to diagonalize n≥5 matrices","category":"section"},{"location":"#Developer-Resources","page":"Home","title":"Developer Resources","text":"Implementation Details - Algorithm descriptions, complexity analysis, performance considerations\nMathematical Background - Theory behind root solvers and pattern-specific algorithms\nContributing Guide - Development setup, testing, adding new patterns","category":"section"},{"location":"#Pattern-Discovery","page":"Home","title":"Pattern Discovery","text":"Additional resources for pattern research and exploration:\n\nResearch Summary (notes/RESEARCH_SUMMARY.md) - Pattern discovery overview\nDiscovery Methodology (notes/DISCOVERY_METHODOLOGY.md) - Pattern exploration techniques\nPattern Discoveries (notes/PATTERN_DISCOVERIES.md) - Detailed catalog of investigated patterns\nExplore Patterns Script (examples/explore_patterns.jl) - Interactive pattern exploration tool","category":"section"},{"location":"#Building-the-Documentation","page":"Home","title":"Building the Documentation","text":"From the project root:\n\njulia --project=docs docs/make.jl\n\nThis renders the documentation locally using Documenter.jl.","category":"section"},{"location":"#Viewing-the-Documentation","page":"Home","title":"Viewing the Documentation","text":"The documentation is built as static HTML in docs/build/. To view it properly with working navigation links, use a local web server:\n\n# Option 1: Use the provided script\ncd docs\n./serve.sh\n\n# Option 2: Use Python's built-in HTTP server\ncd docs/build\npython3 -m http.server 8000\n\n# Option 3: Use Julia's HTTP server\ncd docs/build\njulia -e 'using HTTP; HTTP.serve(HTTP.Files(\".\"))'\n\nThen open your browser to http://localhost:8000\n\nNote: Opening index.html directly with file:// may cause navigation links to not work properly in some browsers due to security restrictions.","category":"section"}]
}

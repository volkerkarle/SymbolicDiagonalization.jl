var documenterSearchIndex = {"docs":
[{"location":"api_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"Complete API documentation for SymbolicDiagonalization.jl.","category":"section"},{"location":"api_reference/#Table-of-Contents","page":"API Reference","title":"Table of Contents","text":"User-Facing API\nLinearAlgebra Interface\nDirect Eigenvalue API\nCharacteristic Polynomial\nRoot Solvers\nKeyword Arguments\nException Types\nInternal API\n\n","category":"section"},{"location":"api_reference/#User-Facing-API","page":"API Reference","title":"User-Facing API","text":"","category":"section"},{"location":"api_reference/#LinearAlgebra-Interface","page":"API Reference","title":"LinearAlgebra Interface","text":"The recommended interface for most users. Extends LinearAlgebra.jl with symbolic matrix support.","category":"section"},{"location":"api_reference/#LinearAlgebra.eigen","page":"API Reference","title":"LinearAlgebra.eigen","text":"eigen(A; kwargs...) → Eigen\n\nComputes eigenvalues and eigenvectors of symbolic matrix A.\n\nArguments:\n\nA::Matrix{Union{Num, Complex{Num}}} - Symbolic matrix to diagonalize\n\nKeyword Arguments: See Keyword Arguments section\n\nReturns: Eigen object with fields:\n\n.values - Vector of eigenvalues\n.vectors - Matrix of eigenvectors (as columns)\n\nExample:\n\nusing Symbolics, SymbolicDiagonalization, LinearAlgebra\n\n@variables a b c\nmat = [a 1 0; 0 b 1; 0 0 c]\n\nE = eigen(mat)\nE.values   # [a, b, c]\nE.vectors  # 3×3 eigenvector matrix\n\nNotes:\n\nUse eigvals() instead if you only need eigenvalues (faster)\nThrows error if matrix is not diagonalizable\nEigenvectors are columns of the returned matrix\n\n","category":"section"},{"location":"api_reference/#LinearAlgebra.eigvals","page":"API Reference","title":"LinearAlgebra.eigvals","text":"eigvals(A; kwargs...) → Vector\n\nComputes eigenvalues of symbolic matrix A (faster than eigen since it skips eigenvectors).\n\nArguments:\n\nA::Matrix{Union{Num, Complex{Num}}} - Symbolic matrix\n\nKeyword Arguments: See Keyword Arguments section\n\nReturns: Vector of eigenvalue expressions\n\nExample:\n\n@variables a b\nmat = [a b; b a]\n\nλ = eigvals(mat)  # [a + b, a - b]\n\nNotes:\n\nRecommended when eigenvectors not needed\nMuch faster than eigen() for large matrices\nSame structure detection and special pattern solvers\n\n","category":"section"},{"location":"api_reference/#Direct-Eigenvalue-API","page":"API Reference","title":"Direct Eigenvalue API","text":"Lower-level API for advanced users who need more control.","category":"section"},{"location":"api_reference/#symbolic_eigenvalues","page":"API Reference","title":"symbolic_eigenvalues","text":"symbolic_eigenvalues(A; kwargs...) → (values, poly, λ)\n\nComputes eigenvalues along with characteristic polynomial.\n\nArguments:\n\nA::Matrix - Symbolic matrix\n\nKeyword Arguments: See Keyword Arguments section\n\nReturns: Tuple of:\n\nvalues - Vector of eigenvalue expressions\npoly - Characteristic polynomial det(λI - A)\nλ - Symbolic variable used in polynomial\n\nExample:\n\n@variables a b\nmat = [a b; b a]\n\nvals, poly, λ = symbolic_eigenvalues(mat)\n# vals: [a+b, a-b]\n# poly: (λ - a)² - b²\n# λ: symbolic variable\n\nUse cases:\n\nNeed both eigenvalues and characteristic polynomial\nWant to manipulate polynomial directly\nNeed the eigenvalue variable for further computation\n\n","category":"section"},{"location":"api_reference/#symbolic_eigenpairs","page":"API Reference","title":"symbolic_eigenpairs","text":"symbolic_eigenpairs(A; kwargs...) → Vector{Tuple{Num, Vector{Vector{Num}}}}\n\nComputes eigenvalue-eigenvector pairs with multiplicity handling.\n\nArguments:\n\nA::Matrix - Symbolic matrix\n\nKeyword Arguments: \n\ncompute_vectors::Bool = true - Whether to compute eigenvectors\nPlus all standard kwargs\n\nReturns: Vector of tuples (eigenvalue, eigenvectors):\n\nEach eigenvalue may have multiple eigenvectors (geometric multiplicity)\nEigenvectors are vectors, not matrix columns\n\nExample:\n\n@variables a b\nmat = [a b; b a]\n\npairs = symbolic_eigenpairs(mat)\n# [(a+b, [v₁]), (a-b, [v₂])]\n\n# Access first eigenvalue and its eigenvectors\nλ₁, vecs₁ = pairs[1]\n\nUse cases:\n\nNeed explicit multiplicity information\nWant eigenvalues grouped with their eigenvectors\nNeed to handle degenerate cases\n\n","category":"section"},{"location":"api_reference/#symbolic_diagonalize","page":"API Reference","title":"symbolic_diagonalize","text":"symbolic_diagonalize(A; kwargs...) → (P, D, pairs)\n\nComputes full diagonalization A = P D P⁻¹.\n\nArguments:\n\nA::Matrix - Symbolic matrix\n\nKeyword Arguments: See Keyword Arguments section\n\nReturns: Tuple of:\n\nP - Matrix of eigenvectors (columns)\nD - Diagonal matrix of eigenvalues\npairs - Same as symbolic_eigenpairs() output\n\nExample:\n\n@variables a b\nmat = [a b; b a]\n\nP, D, pairs = symbolic_diagonalize(mat)\n# Verify: mat ≈ P * D * inv(P)\n\nThrows:\n\nArgumentError if matrix is not diagonalizable\nArgumentError if insufficient eigenvectors found\n\nUse cases:\n\nNeed explicit matrix factorization\nWant to verify diagonalizability\nNeed P and D matrices for further computation\n\n","category":"section"},{"location":"api_reference/#Characteristic-Polynomial","page":"API Reference","title":"Characteristic Polynomial","text":"","category":"section"},{"location":"api_reference/#characteristic_polynomial","page":"API Reference","title":"characteristic_polynomial","text":"characteristic_polynomial(A; var=nothing) → (poly, coeffs, λ)\n\nComputes characteristic polynomial det(λI - A) using Bareiss algorithm.\n\nArguments:\n\nA::Matrix - Symbolic matrix\nvar - Optional symbolic variable to use (auto-generated if not provided)\n\nReturns: Tuple of:\n\npoly - Polynomial expression det(λI - A)\ncoeffs - Vector of polynomial coefficients [c₀, c₁, ..., cₙ]\nλ - Symbolic variable\n\nExample:\n\n@variables a b\nmat = [a b; b a]\n\npoly, coeffs, λ = characteristic_polynomial(mat)\n# poly: λ² - 2a·λ + (a² - b²)\n# coeffs: [a² - b², -2a, 1]\n\nImplementation details:\n\nUses Bareiss fraction-free determinant for efficiency\nAvoids expression explosion from cofactor expansion\nCoefficients extracted by differentiation at λ = 0\n\nUse cases:\n\nNeed characteristic polynomial for analysis\nWant polynomial coefficients explicitly\nImplementing custom root-finding methods\n\n","category":"section"},{"location":"api_reference/#Root-Solvers","page":"API Reference","title":"Root Solvers","text":"","category":"section"},{"location":"api_reference/#symbolic_roots","page":"API Reference","title":"symbolic_roots","text":"symbolic_roots(poly, λ; expand=true, max_terms=10000) → Vector\n\nFinds symbolic roots of polynomial using closed-form formulas (degrees 1-4).\n\nArguments:\n\npoly - Polynomial expression in variable λ\nλ - Symbolic variable\nexpand::Bool = true - Whether to expand expressions\nmax_terms::Int = 10000 - Maximum expression complexity\n\nReturns: Vector of symbolic root expressions\n\nExample:\n\n@variables λ a b\npoly = λ^2 - 2a*λ + (a^2 - b^2)\n\nroots = symbolic_roots(poly, λ)\n# [a + b, a - b]\n\nSupported degrees:\n\nDegree 1: Linear formula\nDegree 2: Quadratic formula\nDegree 3: Cardano's cubic formula\nDegree 4: Ferrari's quartic formula\nDegree ≥ 5: Throws error (Abel-Ruffini theorem)\n\nThrows:\n\nArgumentError if degree ≥ 5 and no structure detected\nExpressionComplexityError if expression exceeds max_terms\n\nNotes:\n\nQuartic formula produces very large expressions\nConsider structure detection for degree ≥ 4\nFor degree 4, expressions can be ~13.5 MB each\n\n","category":"section"},{"location":"api_reference/#Rotation-Matrix-Constructors","page":"API Reference","title":"Rotation Matrix Constructors","text":"Convenience constructors for rotation matrices with clean symbolic eigenvalues.","category":"section"},{"location":"api_reference/#R2","page":"API Reference","title":"R2","text":"R2(θ) → Matrix{Num}\nrotation_matrix(θ) → Matrix{Num}\n\nConstruct a 2×2 rotation matrix (SO(2)).\n\nArguments:\n\nθ - Rotation angle (symbolic or numeric)\n\nReturns: 2×2 rotation matrix [cos(θ) -sin(θ); sin(θ) cos(θ)]\n\nExample:\n\n@variables θ\nR = R2(θ)\neigvals(R)  # [cos(θ) + im*sin(θ), cos(θ) - im*sin(θ)]\n\n","category":"section"},{"location":"api_reference/#Rx,-Ry,-Rz","page":"API Reference","title":"Rx, Ry, Rz","text":"Rx(θ) → Matrix{Num}  # Rotation around x-axis\nRy(θ) → Matrix{Num}  # Rotation around y-axis\nRz(θ) → Matrix{Num}  # Rotation around z-axis\n\nConstruct 3×3 elementary rotation matrices in SO(3).\n\nArguments:\n\nθ - Rotation angle (symbolic or numeric)\n\nReturns: 3×3 rotation matrix\n\nExample:\n\n@variables θ\neigvals(Rx(θ))  # [1, cos(θ) + im*sin(θ), cos(θ) - im*sin(θ)]\neigvals(Ry(θ))  # [1, cos(θ) + im*sin(θ), cos(θ) - im*sin(θ)]\neigvals(Rz(θ))  # [cos(θ) + im*sin(θ), cos(θ) - im*sin(θ), 1]\n\n","category":"section"},{"location":"api_reference/#so2_kron","page":"API Reference","title":"so2_kron","text":"so2_kron(angles::Vector) → Matrix{Num}\n\nConstruct the Kronecker product of SO(2) rotation matrices.\n\nArguments:\n\nangles - Vector of rotation angles [θ₁, θ₂, ..., θₖ]\n\nReturns: 2ᵏ × 2ᵏ matrix R2(θ₁) ⊗ R2(θ₂) ⊗ ... ⊗ R2(θₖ)\n\nExample:\n\n@variables α β γ\nK = so2_kron([α, β, γ])  # 8×8 matrix\nsize(K)  # (8, 8)\n\n","category":"section"},{"location":"api_reference/#so2_kron_eigenvalues","page":"API Reference","title":"so2_kron_eigenvalues","text":"so2_kron_eigenvalues(angles::Vector) → Vector\n\nCompute eigenvalues of SO(2) Kronecker products directly in clean trigonometric form.\n\nArguments:\n\nangles - Vector of rotation angles [θ₁, θ₂, ..., θₖ]\n\nReturns: Vector of 2ᵏ eigenvalues cos(±θ₁±θ₂±...±θₖ) + i·sin(±θ₁±θ₂±...±θₖ)\n\nExample:\n\n@variables α β\nvals = so2_kron_eigenvalues([α, β])\n# [cos(-α-β) + im*sin(-α-β),\n#  cos(α-β) + im*sin(α-β),\n#  cos(-α+β) + im*sin(-α+β),\n#  cos(α+β) + im*sin(α+β)]\n\nNotes:\n\nFaster than building the matrix and computing eigenvalues\nAlways produces clean form without messy symbolic expressions\nThe same clean form is automatically detected when using eigvals(so2_kron(angles))\n\n","category":"section"},{"location":"api_reference/#Trigonometric-Simplification","page":"API Reference","title":"Trigonometric Simplification","text":"","category":"section"},{"location":"api_reference/#trig_simplify","page":"API Reference","title":"trig_simplify","text":"trig_simplify(expr) → Num\n\nApply trigonometric simplification rules to a symbolic expression using SymbolicUtils.jl rule-based rewriting.\n\nArguments:\n\nexpr - Symbolic expression containing trigonometric functions\n\nReturns: Simplified expression\n\nExample:\n\n@variables θ φ\ntrig_simplify(sin(θ)^2 + cos(θ)^2)           # → 1\ntrig_simplify(cos(θ)*cos(φ) - sin(θ)*sin(φ)) # → cos(θ + φ)\ntrig_simplify(2*sin(θ)*cos(θ))               # → sin(2θ)\n\nSupported identities:\n\nPythagorean: sin^2(x) + cos^2(x) = 1\nSquared Pythagorean: sin^4(x) + 2sin^2(x)cos^2(x) + cos^4(x) = 1\nAngle addition: cos(a)cos(b) - sin(a)sin(b) = cos(a+b)\nAngle subtraction: cos(a)cos(b) + sin(a)sin(b) = cos(a-b)\nDouble angle: 2sin(x)cos(x) = sin(2x), cos^2(x) - sin^2(x) = cos(2x)\n\nUse cases:\n\nSimplifying eigenvalues of rotation matrices\nCleaning up trigonometric expressions in physics problems\nPost-processing SO(2) Kronecker product eigenvalues\n\n","category":"section"},{"location":"api_reference/#aggressive_simplify","page":"API Reference","title":"aggressive_simplify","text":"aggressive_simplify(expr) → Num\n\nApply aggressive simplification combining trigonometric, algebraic, and sqrt-trig rules.\n\nKey feature: Transforms sqrt(1 - cos(θ)^2) → sin(θ) and sqrt(1 - sin(θ)^2) → cos(θ).\n\nExample:\n\n@variables θ\naggressive_simplify(sqrt(1 - cos(θ)^2))  # → sin(θ)\naggressive_simplify(sqrt(1 - sin(θ)^2))  # → cos(θ)\naggressive_simplify(sin(θ)^2 + cos(θ)^2) # → 1\n\n","category":"section"},{"location":"api_reference/#simplify_eigenvalue","page":"API Reference","title":"simplify_eigenvalue","text":"simplify_eigenvalue(expr) → Complex{Num}\n\nSpecialized simplification for eigenvalue expressions. Handles real and imaginary parts separately.\n\nExample:\n\n@variables θ\nexpr = cos(θ) + im*sqrt(1 - cos(θ)^2)\nsimplify_eigenvalue(expr)  # → cos(θ) + im*sin(θ)\n\n","category":"section"},{"location":"api_reference/#simplify_eigenvalues","page":"API Reference","title":"simplify_eigenvalues","text":"simplify_eigenvalues(vals::Vector) → Vector\n\nApply simplify_eigenvalue to a vector of eigenvalues.\n\nExample:\n\n@variables θ\nvals = [cos(θ) + im*sqrt(1 - cos(θ)^2), cos(θ) - im*sqrt(1 - cos(θ)^2)]\nsimplify_eigenvalues(vals)  # → [cos(θ) + im*sin(θ), cos(θ) - im*sin(θ)]\n\n","category":"section"},{"location":"api_reference/#Keyword-Arguments","page":"API Reference","title":"Keyword Arguments","text":"All main functions (eigen, eigvals, symbolic_eigenvalues, etc.) accept these keyword arguments:","category":"section"},{"location":"api_reference/#var::Union{Nothing,-Num}","page":"API Reference","title":"var::Union{Nothing, Num}","text":"Default: nothing (auto-generate)\n\nSymbolic variable to use for eigenvalue. If nothing, a fresh variable is created.\n\nExample:\n\n@variables λ\nvals = eigvals(mat, var=λ)\n\nUse cases: \n\nNeed specific variable name\nIntegrating with existing symbolic expressions\nWant to control variable scope\n\n","category":"section"},{"location":"api_reference/#structure::Symbol","page":"API Reference","title":"structure::Symbol","text":"Default: :auto\n\nHint about matrix structure for optimization.\n\nOptions:\n\n:auto - Automatic structure detection (default)\n:hermitian - Hermitian matrix (A† = A)\n:symmetric - Real symmetric (Aᵀ = A)\n:unitary - Unitary matrix (A† = A⁻¹)\n:general - No structure assumptions\n:diagonal - Diagonal matrix (hint to skip detection)\n:triangular - Triangular matrix (hint to skip detection)\n:none - Skip all structure detection entirely\n\nExample:\n\n# Tell solver that matrix is Hermitian\nvals = eigvals(hermitian_mat, structure=:hermitian)\n\nNotes:\n\nProviding correct hint can speed up computation\nIncorrect hint may give wrong results\n:auto is safe but may be slower\n:none skips detection entirely (fastest, but no pattern optimizations)\n\n","category":"section"},{"location":"api_reference/#expand::Bool","page":"API Reference","title":"expand::Bool","text":"Default: true\n\nWhether to expand polynomial expressions.\n\nOptions:\n\ntrue - Expand products and powers\nfalse - Keep factored form when possible\n\nExample:\n\n# Factored form (if available)\nvals = eigvals(mat, expand=false)\n\nUse cases:\n\nFactored form may be simpler\nExpanded form needed for numerical evaluation\nDebugging expression structure\n\n","category":"section"},{"location":"api_reference/#complexity_threshold::Int","page":"API Reference","title":"complexity_threshold::Int","text":"Default: 5\n\nWarn if matrix contains more than this many symbolic variables.\n\nExample:\n\n# Suppress warning for 10-variable matrix\nvals = eigvals(large_mat, complexity_threshold=10)\n\nPurpose: Prevent accidentally running huge symbolic computations that may timeout or produce enormous expressions.\n\nRecommendation: \n\nKeep ≤ 5 for general matrices\nCan increase for structured matrices\nSet to Inf to disable warnings\n\n","category":"section"},{"location":"api_reference/#timeout::Int","page":"API Reference","title":"timeout::Int","text":"Default: 300 (5 minutes)\n\nMaximum computation time in seconds.\n\nExample:\n\n# Allow only 60 seconds\nvals = eigvals(mat, timeout=60)\n\nThrows: ComputationTimeoutError if exceeded\n\nUse cases:\n\nPrevent runaway computations\nTesting with time limits\nInteractive use with quick feedback\n\n","category":"section"},{"location":"api_reference/#max_terms::Int","page":"API Reference","title":"max_terms::Int","text":"Default: 10000\n\nMaximum number of terms allowed in symbolic expressions.\n\nExample:\n\n# Allow more complex expressions\nvals = eigvals(mat, max_terms=50000)\n\nThrows: ExpressionComplexityError if exceeded\n\nPurpose: Prevent expression explosion (especially in quartic formula)\n\nRecommendation:\n\nKeep default for most cases\nIncrease for structured matrices\nWatch memory usage if increasing\n\n","category":"section"},{"location":"api_reference/#Exception-Types","page":"API Reference","title":"Exception Types","text":"","category":"section"},{"location":"api_reference/#ExpressionComplexityError","page":"API Reference","title":"ExpressionComplexityError","text":"Thrown when symbolic expression exceeds complexity limit.\n\nFields:\n\nmessage::String - Error message with details and suggestions for resolution\n\nExample:\n\ntry\n    vals = eigvals(huge_mat, max_terms=1000)\ncatch e\n    if e isa ExpressionComplexityError\n        println(\"Expression too complex: $(e.message)\")\n    end\nend\n\nCommon causes:\n\nFully symbolic 4×4 matrices (quartic formula)\nLack of detected structure\nNested radical expressions\n\nSolutions:\n\nAdd structure to matrix\nUse partial numeric substitution\nIncrease max_terms (watch memory!)\nUse numerical methods instead\n\n","category":"section"},{"location":"api_reference/#ComputationTimeoutError","page":"API Reference","title":"ComputationTimeoutError","text":"Thrown when computation exceeds time limit.\n\nFields:\n\nmessage::String - Error message with details and suggestions for resolution\n\nExample:\n\ntry\n    vals = eigvals(mat, timeout=30)\ncatch e\n    if e isa ComputationTimeoutError\n        println(\"Timed out: $(e.message)\")\n    end\nend\n\nCommon causes:\n\nVery large symbolic matrices\nComplex expression simplification\nExpensive structure detection\n\nSolutions:\n\nIncrease timeout\nSimplify matrix structure\nUse numerical methods\nPre-substitute some variables\n\n","category":"section"},{"location":"api_reference/#Internal-API","page":"API Reference","title":"Internal API","text":"These functions are not exported but may be useful for advanced users or contributors.","category":"section"},{"location":"api_reference/#Structure-Detection","page":"API Reference","title":"Structure Detection","text":"","category":"section"},{"location":"api_reference/#_detect_structure(mat)","page":"API Reference","title":"_detect_structure(mat)","text":"Automatically detects matrix structure (diagonal, triangular, block-diagonal, etc.)","category":"section"},{"location":"api_reference/#_is_diagonal(mat)","page":"API Reference","title":"_is_diagonal(mat)","text":"Tests if matrix is diagonal","category":"section"},{"location":"api_reference/#_is_triangular(mat)","page":"API Reference","title":"_is_triangular(mat)","text":"Tests if matrix is upper or lower triangular","category":"section"},{"location":"api_reference/#_is_hermitian(mat)","page":"API Reference","title":"_is_hermitian(mat)","text":"Tests if matrix is Hermitian (A† = A)","category":"section"},{"location":"api_reference/#_is_symmetric(mat)","page":"API Reference","title":"_is_symmetric(mat)","text":"Tests if matrix is real symmetric","category":"section"},{"location":"api_reference/#_is_persymmetric(mat)","page":"API Reference","title":"_is_persymmetric(mat)","text":"Tests if matrix has persymmetric structure Q[i,j] = Q[n+1-j,n+1-i]\n\n","category":"section"},{"location":"api_reference/#Special-Pattern-Detectors","page":"API Reference","title":"Special Pattern Detectors","text":"","category":"section"},{"location":"api_reference/#_is_circulant(mat)","page":"API Reference","title":"_is_circulant(mat)","text":"Tests if matrix is circulant (each row cyclic shift of previous)","category":"section"},{"location":"api_reference/#_is_block_circulant(mat)","page":"API Reference","title":"_is_block_circulant(mat)","text":"Tests if matrix is block circulant, returns (true, n_blocks, block_size, blocks) or (false, ...)","category":"section"},{"location":"api_reference/#_is_kronecker_product(mat)","page":"API Reference","title":"_is_kronecker_product(mat)","text":"Tests if matrix is Kronecker product, returns (true, A, B, m, n) or (false, ...)","category":"section"},{"location":"api_reference/#_is_toeplitz_tridiagonal(mat)","page":"API Reference","title":"_is_toeplitz_tridiagonal(mat)","text":"Tests if matrix is symmetric Toeplitz tridiagonal","category":"section"},{"location":"api_reference/#_is_antidiagonal(mat)","page":"API Reference","title":"_is_antidiagonal(mat)","text":"Tests if matrix is symmetric anti-diagonal","category":"section"},{"location":"api_reference/#_is_permutation_matrix(mat)","page":"API Reference","title":"_is_permutation_matrix(mat)","text":"Tests if matrix is a permutation matrix","category":"section"},{"location":"api_reference/#_detect_special_5x5_tridiagonal(mat)","page":"API Reference","title":"_detect_special_5x5_tridiagonal(mat)","text":"Tests for special 5×5 patterns with known eigenvalues","category":"section"},{"location":"api_reference/#_is_symbolic_orthogonal(mat)","page":"API Reference","title":"_is_symbolic_orthogonal(mat)","text":"Tests if a symbolic matrix is orthogonal (M'*M = I) using trig simplification","category":"section"},{"location":"api_reference/#_try_so2_kronecker_decomposition(mat,-k)","page":"API Reference","title":"_try_so2_kronecker_decomposition(mat, k)","text":"Attempts to detect and decompose SO(2) Kronecker products R(θ₁) ⊗ R(θ₂) ⊗ ... ⊗ R(θₖ)\n\n","category":"section"},{"location":"api_reference/#Special-Pattern-Solvers","page":"API Reference","title":"Special Pattern Solvers","text":"","category":"section"},{"location":"api_reference/#_circulant_eigenvalues(mat)","page":"API Reference","title":"_circulant_eigenvalues(mat)","text":"Computes eigenvalues of circulant matrix using DFT","category":"section"},{"location":"api_reference/#_block_circulant_eigenvalues(mat,-n_blocks,-block_size,-blocks;-...)","page":"API Reference","title":"_block_circulant_eigenvalues(mat, n_blocks, block_size, blocks; ...)","text":"Computes eigenvalues of block circulant matrix","category":"section"},{"location":"api_reference/#_kronecker_eigenvalues(A,-B,-m,-n;-...)","page":"API Reference","title":"_kronecker_eigenvalues(A, B, m, n; ...)","text":"Computes eigenvalues of Kronecker product A ⊗ B","category":"section"},{"location":"api_reference/#_toeplitz_tridiagonal_eigenvalues(n,-a,-b,-c)","page":"API Reference","title":"_toeplitz_tridiagonal_eigenvalues(n, a, b, c)","text":"Computes eigenvalues of symmetric Toeplitz tridiagonal","category":"section"},{"location":"api_reference/#_antidiagonal_eigenvalues(mat)","page":"API Reference","title":"_antidiagonal_eigenvalues(mat)","text":"Computes eigenvalues of symmetric anti-diagonal matrix","category":"section"},{"location":"api_reference/#_compute_permutation_eigenvalues(A)","page":"API Reference","title":"_compute_permutation_eigenvalues(A)","text":"Computes eigenvalues of permutation matrix via cycle decomposition","category":"section"},{"location":"api_reference/#_issymzero_trig(expr)","page":"API Reference","title":"_issymzero_trig(expr)","text":"Tests if expression is symbolically zero, using trigonometric simplification\n\n","category":"section"},{"location":"api_reference/#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"","category":"section"},{"location":"api_reference/#_block_split(mat)","page":"API Reference","title":"_block_split(mat)","text":"Detects and splits block-diagonal structure","category":"section"},{"location":"api_reference/#_persymmetric_split(mat)","page":"API Reference","title":"_persymmetric_split(mat)","text":"Splits persymmetric matrix into half-sized problems","category":"section"},{"location":"api_reference/#_count_symbolic_vars(A)","page":"API Reference","title":"_count_symbolic_vars(A)","text":"Counts number of unique symbolic variables in matrix","category":"section"},{"location":"api_reference/#_check_complexity(A;-threshold,-quiet)","page":"API Reference","title":"_check_complexity(A; threshold, quiet)","text":"Checks if matrix exceeds complexity threshold, optionally warns\n\n","category":"section"},{"location":"api_reference/#Usage-Examples","page":"API Reference","title":"Usage Examples","text":"","category":"section"},{"location":"api_reference/#Example-1:-Basic-Eigenvalues","page":"API Reference","title":"Example 1: Basic Eigenvalues","text":"using Symbolics, SymbolicDiagonalization, LinearAlgebra\n\n@variables a b c\nmat = [a 0 0; 0 b 0; 0 0 c]\n\nλ = eigvals(mat)  # [a, b, c]","category":"section"},{"location":"api_reference/#Example-2:-With-Structure-Hint","page":"API Reference","title":"Example 2: With Structure Hint","text":"@variables a b\nH = [a b; conj(b) a]  # Hermitian\n\nE = eigen(H, structure=:hermitian)","category":"section"},{"location":"api_reference/#Example-3:-Error-Handling","page":"API Reference","title":"Example 3: Error Handling","text":"@variables a b c d e\nmat = [a b c d e;\n       b a c d e;\n       c c a d e;\n       d d d a e;\n       e e e e a]\n\ntry\n    λ = eigvals(mat, timeout=60, max_terms=5000)\ncatch e\n    if e isa ComputationTimeoutError\n        println(\"Computation timed out\")\n    elseif e isa ExpressionComplexityError\n        println(\"Expression too complex\")\n    else\n        rethrow(e)\n    end\nend","category":"section"},{"location":"api_reference/#Example-4:-Characteristic-Polynomial","page":"API Reference","title":"Example 4: Characteristic Polynomial","text":"@variables a b\nmat = [a b; b a]\n\npoly, coeffs, λ = characteristic_polynomial(mat)\n# poly = λ² - 2a·λ + (a² - b²)\n\n# Now solve manually if desired\nroots = symbolic_roots(poly, λ)","category":"section"},{"location":"api_reference/#Example-5:-Full-Diagonalization","page":"API Reference","title":"Example 5: Full Diagonalization","text":"@variables a b\nmat = [a b; b a]\n\nP, D, pairs = symbolic_diagonalize(mat)\n\n# Verify: mat ≈ P * D * inv(P)\n# P contains eigenvectors as columns\n# D is diagonal with eigenvalues\n\n","category":"section"},{"location":"api_reference/#See-Also","page":"API Reference","title":"See Also","text":"User Guide - Practical examples and workflows\nPattern Library - Special patterns and their eigenvalues\nImplementation - Algorithm details\nMathematical Background - Theory and proofs","category":"section"},{"location":"mathematical_background/#Mathematical-Background","page":"Mathematical Background","title":"Mathematical Background","text":"Mathematical foundations for symbolic matrix diagonalization.","category":"section"},{"location":"mathematical_background/#The-Eigenvalue-Problem","page":"Mathematical Background","title":"The Eigenvalue Problem","text":"Given matrix mathbfA, find lambda and mathbfv such that: mathbfAmathbfv = lambdamathbfv\n\nThis requires: det(lambdamathbfI - mathbfA) = 0\n\nThe characteristic polynomial is degree n, so eigenvalues are polynomial roots.","category":"section"},{"location":"mathematical_background/#The-Abel-Ruffini-Theorem","page":"Mathematical Background","title":"The Abel-Ruffini Theorem","text":"Theorem (1824): No general algebraic formula exists for polynomial roots of degree geq 5.\n\nDegree Method Status\n1 Linear lambda = -c_0\n2 Quadratic lambda = frac-b pm sqrtb^2-4c2\n3 Cardano Nested radicals\n4 Ferrari Reduces to cubic + quadratics\n≥5 None Impossible in general\n\nImplication: Generic n times n matrices with n geq 5 cannot have symbolic eigenvalues.\n\nException: Specific polynomials with special structure (e.g., lambda^5 - 1 = 0) may still be solvable.","category":"section"},{"location":"mathematical_background/#Why-Structure-Enables-Solutions","page":"Mathematical Background","title":"Why Structure Enables Solutions","text":"Matrices with structure have special Galois groups:\n\nStructure Galois Group Solvable?\nCirculant Cyclic mathbbZ_n Always\nDihedral symmetry Dihedral D_n Always\nGeneric matrix Symmetric S_n No (n geq 5)","category":"section"},{"location":"mathematical_background/#Closed-Form-Root-Formulas","page":"Mathematical Background","title":"Closed-Form Root Formulas","text":"","category":"section"},{"location":"mathematical_background/#Quadratic-(ax2-bx-c-0)","page":"Mathematical Background","title":"Quadratic (ax^2 + bx + c = 0)","text":"x = frac-b pm sqrtb^2 - 4ac2a","category":"section"},{"location":"mathematical_background/#Cubic-(x3-px-q-0,-depressed-form)","page":"Mathematical Background","title":"Cubic (x^3 + px + q = 0, depressed form)","text":"x = sqrt3-fracq2 + sqrtfracq^24 + fracp^327 + sqrt3-fracq2 - sqrtfracq^24 + fracp^327","category":"section"},{"location":"mathematical_background/#Quartic","page":"Mathematical Background","title":"Quartic","text":"Reduces to solving a cubic resolvent, then two quadratics. Expressions are very large (~13.5 MB for fully symbolic 4×4).","category":"section"},{"location":"mathematical_background/#Pattern-Specific-Theory","page":"Mathematical Background","title":"Pattern-Specific Theory","text":"","category":"section"},{"location":"mathematical_background/#Circulant-Matrices","page":"Mathematical Background","title":"Circulant Matrices","text":"Why closed-form exists: All circulant matrices are polynomials in the shift operator mathbfS. The DFT matrix diagonalizes mathbfS, hence all circulants.\n\nlambda_k = sum_j=0^n-1 c_j omega^jk quad omega = e^2pi in","category":"section"},{"location":"mathematical_background/#Symmetric-Toeplitz-Tridiagonal","page":"Mathematical Background","title":"Symmetric Toeplitz Tridiagonal","text":"Why closed-form exists: Known eigenvector basis (discrete sine transform). Eigenvalue equation reduces to trigonometric identity.\n\nlambda_k = a + 2bcosleft(frackpin+1right)","category":"section"},{"location":"mathematical_background/#Kronecker-Products","page":"Mathematical Background","title":"Kronecker Products","text":"Why closed-form exists: Tensor product structure factorizes eigenspaces.\n\nlambda(mathbfA otimes mathbfB) = lambda_i(mathbfA) cdot lambda_j(mathbfB)","category":"section"},{"location":"mathematical_background/#Permutation-Matrices","page":"Mathematical Background","title":"Permutation Matrices","text":"Why closed-form exists: Finite order implies eigenvalues are roots of unity. Cycle structure determines which roots appear.","category":"section"},{"location":"mathematical_background/#Group-Theory-Foundations","page":"Mathematical Background","title":"Group Theory Foundations","text":"","category":"section"},{"location":"mathematical_background/#Representation-Theory","page":"Mathematical Background","title":"Representation Theory","text":"When mathbfA commutes with symmetry group G:\n\nEigenvectors organize into irreducible representations\nEigenvalues within an irrep are equal (degeneracy)\nCharacter tables predict eigenspace dimensions","category":"section"},{"location":"mathematical_background/#Key-Groups","page":"Mathematical Background","title":"Key Groups","text":"Group Structure Application\nmathbbZ_n Cyclic rotations Circulant matrices\nD_n Rotation + reflection Polygon graphs\nS_n All permutations Generic case (bad)","category":"section"},{"location":"mathematical_background/#Strongly-Regular-Graphs","page":"Mathematical Background","title":"Strongly Regular Graphs","text":"Parameters (n k lambda mu) determine exactly 3 eigenvalues:\n\nlambda_1 = k\nlambda_23 = frac(lambda-mu) pm sqrt(lambda-mu)^2 + 4(k-mu)2\n\nExample: Petersen graph (10301) → 3 1^(5) -2^(4)","category":"section"},{"location":"mathematical_background/#Hypercube-Graphs","page":"Mathematical Background","title":"Hypercube Graphs","text":"n\n\n-dimensional hypercube Q_n: lambda_k = n - 2k quad textmultiplicity  binomnk","category":"section"},{"location":"mathematical_background/#Pattern-Discovery-Principles","page":"Mathematical Background","title":"Pattern Discovery Principles","text":"A pattern has closed-form eigenvalues when:\n\nKnown diagonalizing transform (e.g., DFT for circulants)\nReducible structure (e.g., block-diagonal splits problem)\nTensor product structure (eigenvalues are products)\nSymmetry constraints (representation theory)\nSolvable Galois group (cyclic, dihedral, etc.)","category":"section"},{"location":"mathematical_background/#References","page":"Mathematical Background","title":"References","text":"Horn & Johnson, Matrix Analysis (2012)\nDavis, Circulant Matrices (1979)\nGodsil & Royle, Algebraic Graph Theory (2001)\nSerre, Linear Representations of Finite Groups (1977)","category":"section"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"Guide for contributing to SymbolicDiagonalization.jl.","category":"section"},{"location":"contributing/#Setup","page":"Contributing","title":"Setup","text":"cd SymbolicDiagonalization.jl\njulia --project=.\n\nusing Pkg\nPkg.instantiate()\nPkg.test()","category":"section"},{"location":"contributing/#Code-Style","page":"Contributing","title":"Code Style","text":"Functions: snake_case, prefix private with _\nTypes: PascalCase\nClarity over cleverness: Readable code is maintainable\nDocument intent: Comments explain why, not what","category":"section"},{"location":"contributing/#Docstrings","page":"Contributing","title":"Docstrings","text":"\"\"\"\n    function_name(arg1; kwarg1=default)\n\nBrief description.\n\n# Arguments\n- `arg1`: Description\n\n# Returns\nDescription of return value\n\n# Examples\n\njulia result = function_name(input)\n\n\"\"\"","category":"section"},{"location":"contributing/#Testing","page":"Contributing","title":"Testing","text":"# Run all tests\nPkg.test()\n\n# Run specific file\ninclude(\"test/test_patterns.jl\")","category":"section"},{"location":"contributing/#Test-Requirements","page":"Contributing","title":"Test Requirements","text":"All new functions must have tests\nTest both detection (true/false positives) and correctness (Av = λv)\nTest edge cases: 1×1, repeated eigenvalues, etc.","category":"section"},{"location":"contributing/#Adding-a-Pattern","page":"Contributing","title":"Adding a Pattern","text":"","category":"section"},{"location":"contributing/#1.-Detection","page":"Contributing","title":"1. Detection","text":"Add _is_pattern(mat) in appropriate src/patterns/*.jl:\n\nfunction _is_my_pattern(mat)\n    # Return nothing if not detected\n    # Return detection info if detected\nend","category":"section"},{"location":"contributing/#2.-Solver","page":"Contributing","title":"2. Solver","text":"Add _my_pattern_eigenvalues(mat, info):\n\nfunction _my_pattern_eigenvalues(mat, info)\n    # Return vector of eigenvalues\nend","category":"section"},{"location":"contributing/#3.-Integration","page":"Contributing","title":"3. Integration","text":"Add to detection cascade in src/diagonalize.jl:\n\n# In symbolic_eigenvalues_core:\ninfo = _is_my_pattern(mat)\nif !isnothing(info)\n    return _my_pattern_eigenvalues(mat, info), nothing, nothing\nend","category":"section"},{"location":"contributing/#4.-Tests","page":"Contributing","title":"4. Tests","text":"Add to test/test_patterns.jl:\n\n@testset \"MyPattern\" begin\n    @test _is_my_pattern(valid_matrix) !== nothing\n    @test _is_my_pattern(invalid_matrix) === nothing\n    \n    vals = eigvals(valid_matrix)\n    @test length(vals) == n\n    # Verify eigenvalue equation\nend","category":"section"},{"location":"contributing/#5.-Documentation","page":"Contributing","title":"5. Documentation","text":"Add section to docs/src/pattern_library.md.","category":"section"},{"location":"contributing/#Building-Docs","page":"Contributing","title":"Building Docs","text":"julia --project=docs docs/make.jl\n\n# Serve locally (required for working navigation)\ncd docs/build && python3 -m http.server 8000","category":"section"},{"location":"contributing/#Git-Workflow","page":"Contributing","title":"Git Workflow","text":"Branch: feature/pattern-name, fix/description\nCommit: type(scope): description (feat, fix, docs, test)\nAll tests must pass before merge","category":"section"},{"location":"contributing/#Questions","page":"Contributing","title":"Questions","text":"Open an issue with:\n\nClear problem description\nMinimal reproducible example\nJulia version (versioninfo())","category":"section"},{"location":"contributing/#License","page":"Contributing","title":"License","text":"Contributions are MIT licensed.","category":"section"},{"location":"user_guide/#User-Guide","page":"User Guide","title":"User Guide","text":"Practical guide to using SymbolicDiagonalization.jl effectively.","category":"section"},{"location":"user_guide/#Installation","page":"User Guide","title":"Installation","text":"using Pkg\nPkg.add(\"SymbolicDiagonalization\")\n\nOr from the repository:\n\ncd SymbolicDiagonalization.jl\njulia --project -e 'using Pkg; Pkg.instantiate()'","category":"section"},{"location":"user_guide/#Basic-Usage","page":"User Guide","title":"Basic Usage","text":"using Symbolics\nusing SymbolicDiagonalization\n\n@variables a b c d\n\n# Create a symbolic matrix\nM = [a b; b a]\n\n# Eigenvalues only (faster)\neigvals(M)  # [a+b, a-b]\n\n# Eigenvalues + eigenvectors\nE = eigen(M)\nE.values    # eigenvalues\nE.vectors   # eigenvectors as columns","category":"section"},{"location":"user_guide/#Common-Workflows","page":"User Guide","title":"Common Workflows","text":"","category":"section"},{"location":"user_guide/#Small-Matrices-(-44)","page":"User Guide","title":"Small Matrices (≤ 4×4)","text":"Direct closed-form solution via root formulas:\n\n@variables a b c d\nM = [a b 0 0; b a 0 0; 0 0 c d; 0 0 d c]\n\neigvals(M)  # [a+b, a-b, c+d, c-d]","category":"section"},{"location":"user_guide/#Block-Diagonal-Matrices","page":"User Guide","title":"Block-Diagonal Matrices","text":"Automatically detected and solved recursively:\n\n@variables a b c d e f\nM = [a b 0 0 0 0;\n     b a 0 0 0 0;\n     0 0 c d 0 0;\n     0 0 d c 0 0;\n     0 0 0 0 e f;\n     0 0 0 0 f e]\n\neigvals(M)  # Solves three 2×2 blocks","category":"section"},{"location":"user_guide/#Circulant-Matrices","page":"User Guide","title":"Circulant Matrices","text":"DFT-based solution for any size:\n\n@variables a b c d\nC = [a b c d; d a b c; c d a b; b c d a]\n\neigvals(C)  # Works for 100×100 too","category":"section"},{"location":"user_guide/#Tridiagonal-Matrices","page":"User Guide","title":"Tridiagonal Matrices","text":"Closed-form cosine formula:\n\n@variables a b\nn = 5\nT = diagm(0 => fill(a, n), 1 => fill(b, n-1), -1 => fill(b, n-1))\n\neigvals(T)  # λₖ = a + 2b·cos(kπ/(n+1))","category":"section"},{"location":"user_guide/#Kronecker-Products","page":"User Guide","title":"Kronecker Products","text":"Products of factor eigenvalues:\n\n@variables a b c d\nA = [a 0; 0 b]\nB = [c 0; 0 d]\nK = kron(A, B)  # 4×4\n\neigvals(K)  # [ac, ad, bc, bd]","category":"section"},{"location":"user_guide/#SO(2)-Rotation-Kronecker-Products","page":"User Guide","title":"SO(2) Rotation Kronecker Products","text":"Kronecker products of SO(2) rotation matrices are automatically detected and produce clean trigonometric eigenvalues using angle addition formulas:\n\n@variables θ φ\nR(x) = [cos(x) -sin(x); sin(x) cos(x)]  # SO(2) rotation matrix\n\nK = kron(R(θ), R(φ))\neigvals(K)\n# [cos(θ + φ) + im*sin(θ + φ),   # e^{i(θ+φ)}\n#  cos(θ - φ) + im*sin(θ - φ),   # e^{i(θ-φ)}\n#  cos(θ - φ) - im*sin(θ - φ),   # e^{-i(θ-φ)}\n#  cos(θ + φ) - im*sin(θ + φ)]   # e^{-i(θ+φ)}\n\nThe same-angle case R(θ) ⊗ R(θ) automatically simplifies using double-angle formulas:\n\neigvals(kron(R(θ), R(θ)))\n# [cos(2θ) + im*sin(2θ),   # e^{2iθ}\n#  1,                       # θ - θ = 0\n#  1,                       # -(θ - θ) = 0\n#  cos(2θ) - im*sin(2θ)]   # e^{-2iθ}\n\nThis works recursively for nested SO(2) Kronecker products.","category":"section"},{"location":"user_guide/#SU(2)-Kronecker-Products","page":"User Guide","title":"SU(2) Kronecker Products","text":"SU(2) is the group of 2×2 unitary matrices with determinant 1. In quantum mechanics, SU(2) describes spin-1/2 systems. The package provides Pauli matrices and SU(2) rotation constructors:\n\n@variables α β\n\n# Pauli matrices\nσx()  # [0 1; 1 0]\nσy()  # [0 -im; im 0]\nσz()  # [1 0; 0 -1]\n\n# SU(2) rotation matrices (spin-1/2 representation)\nUx(θ)  # exp(-i θ σx/2)\nUy(θ)  # exp(-i θ σy/2) - same form as SO(2) but with half-angle\nUz(θ)  # diagonal: [e^{-iθ/2}, e^{iθ/2}]\n\n# SU(2) ⊗ SU(2) Kronecker product\nK = su2_kron([α, β])  # 4×4 matrix\neigvals(K)\n# [cos((α+β)/2) + im*sin((α+β)/2),   # e^{i(α+β)/2}\n#  cos((α-β)/2) + im*sin((α-β)/2),   # e^{i(α-β)/2}\n#  cos((α-β)/2) - im*sin((α-β)/2),   # e^{-i(α-β)/2}\n#  cos((α+β)/2) - im*sin((α+β)/2)]   # e^{-i(α+β)/2}\n\nThe key difference from SO(2) is the half-angle: SU(2) uses θ/2 instead of θ.","category":"section"},{"location":"user_guide/#SU(3)-Kronecker-Products","page":"User Guide","title":"SU(3) Kronecker Products","text":"SU(3) is the group of 3×3 unitary matrices with determinant 1. It's fundamental in particle physics (color charge in QCD). The package provides Gell-Mann matrices and diagonal SU(3) constructors:\n\n@variables α₁ α₂ β₁ β₂\n\n# Gell-Mann matrices (8 generators of SU(3))\ngellmann_matrices()  # Returns [λ1, λ2, ..., λ8]\n\n# Diagonal SU(3) matrix (Cartan subalgebra)\n# U = diag(e^{iα₁}, e^{iα₂}, e^{-i(α₁+α₂)})  # det = 1\nU = su3_diagonal_trig(α₁, α₂)\n\n# SU(3) ⊗ SU(3) Kronecker product (9×9 diagonal matrix)\nK = su3_kron((α₁, α₂), (β₁, β₂))\neigvals(K)\n# 9 eigenvalues of the form cos(θ) + im*sin(θ) where θ is:\n# α₁+β₁, α₁+β₂, α₁-(β₁+β₂), α₂+β₁, α₂+β₂, α₂-(β₁+β₂),\n# -(α₁+α₂)+β₁, -(α₁+α₂)+β₂, -(α₁+α₂)-(β₁+β₂)\n\nDirect eigenvalue computation without building the matrix:\n\nsu3_kron_eigenvalues((α₁, α₂), (β₁, β₂))  # Returns 9 eigenvalues directly","category":"section"},{"location":"user_guide/#Simplifying-Eigenvalue-Expressions","page":"User Guide","title":"Simplifying Eigenvalue Expressions","text":"The package provides aggressive simplification functions for cleaning up symbolic eigenvalue expressions, particularly those involving trigonometric functions.","category":"section"},{"location":"user_guide/#Key-Simplification-Functions","page":"User Guide","title":"Key Simplification Functions","text":"using SymbolicDiagonalization: aggressive_simplify, simplify_eigenvalue, simplify_eigenvalues\n\n@variables θ\n\n# aggressive_simplify: Combines trig, algebraic, and sqrt-trig rules\naggressive_simplify(sqrt(1 - cos(θ)^2))  # → sin(θ)\naggressive_simplify(sqrt(1 - sin(θ)^2))  # → cos(θ)\naggressive_simplify(sin(θ)^2 + cos(θ)^2) # → 1\n\n# simplify_eigenvalue: Specialized for eigenvalue expressions\n# Handles complex parts separately for clean output\nexpr = cos(θ) + im*sqrt(1 - cos(θ)^2)\nsimplify_eigenvalue(expr)  # → cos(θ) + im*sin(θ)\n\n# simplify_eigenvalues: Apply to a vector of eigenvalues\nvals = [cos(θ) + im*sqrt(1 - cos(θ)^2), cos(θ) - im*sqrt(1 - cos(θ)^2)]\nsimplify_eigenvalues(vals)  # → [cos(θ) + im*sin(θ), cos(θ) - im*sin(θ)]","category":"section"},{"location":"user_guide/#When-to-Use","page":"User Guide","title":"When to Use","text":"Automatic: Block-diagonal SO(4), SO(3), and SO(2) matrices automatically use these simplifications\nManual: When working with custom matrices that produce sqrt(1 - cos²θ) or similar expressions","category":"section"},{"location":"user_guide/#Simplification-Rules-Applied","page":"User Guide","title":"Simplification Rules Applied","text":"Rule Before After\nPythagorean sin²θ + cos²θ 1\nSqrt-trig sqrt(1 - cos²θ) sin(θ)\nSqrt-trig sqrt(1 - sin²θ) cos(θ)\nAlgebraic sqrt(x)^2 x\nAlgebraic sqrt(a)*sqrt(b) sqrt(a*b)","category":"section"},{"location":"user_guide/#Nested-Kronecker-Products","page":"User Guide","title":"Nested Kronecker Products","text":"Arbitrary-depth Kronecker products are handled recursively. The eigenvalues of A_1 otimes A_2 otimes cdots otimes A_n are all products: lambda_i_1 i_2 ldots i_n = lambda_i_1(A_1) cdot lambda_i_2(A_2) cdots lambda_i_n(A_n)\n\nusing SymbolicDiagonalization, Symbolics\n\n# Create 5 independent 2×2 symmetric matrices (15 parameters total)\nmatrices = Matrix{Num}[]\nfor i in 1:5\n    a = Symbolics.variable(Symbol(\"a$i\"))\n    b = Symbolics.variable(Symbol(\"b$i\"))\n    c = Symbolics.variable(Symbol(\"c$i\"))\n    push!(matrices, [a b; b c])\nend\n\n# Build 32×32 Kronecker product\nK = reduce(kron, matrices)\n\n# Solve symbolically - returns 32 eigenvalues\nvals, vecs, pairs = symbolic_eigenvalues(K; timeout=120)\n\nThis scales efficiently to very large matrices:\n\nDepth Matrix Size Parameters Time\n5 32×32 15 ~12s\n7 128×128 21 ~23s\n10 1024×1024 30 ~33s","category":"section"},{"location":"user_guide/#Full-6-Parameter-33-Symmetric-Matrices","page":"User Guide","title":"Full 6-Parameter 3×3 Symmetric Matrices","text":"The package handles the most general 3×3 symmetric matrix with 6 independent parameters:\n\n@variables a b c d e f\nA = [a b c; b d e; c e f]\n\n# Uses diagonal shift optimization internally\nvals, vecs, pairs = symbolic_eigenvalues(A; timeout=600)\n\nThis employs a diagonal shift optimization: shift by f cdot I, solve a 5-variable problem, then back-substitute. The resulting eigenvalue expressions are large but exact.","category":"section"},{"location":"user_guide/#Performance-Tips","page":"User Guide","title":"Performance Tips","text":"Tip Example\nUse structure hints eigvals(M, structure=:hermitian)\nEigenvalues only eigvals(M) vs eigen(M)\nPartial substitution substitute(M, Dict(c => 0))\nIncrease timeout eigvals(M, timeout=600)\nDisable expansion eigvals(M, expand=false)","category":"section"},{"location":"user_guide/#Troubleshooting","page":"User Guide","title":"Troubleshooting","text":"","category":"section"},{"location":"user_guide/#\"Cannot-solve-degree-n-5-without-structure\"","page":"User Guide","title":"\"Cannot solve degree n ≥ 5 without structure\"","text":"Matrix is 5×5+ with no detected structure. Solutions:\n\nAdd zeros to create block structure\nCheck for circulant, tridiagonal, or Kronecker patterns\nSubstitute numeric values for some variables\nUse numerical methods via LinearAlgebra.eigvals on Float64 matrix","category":"section"},{"location":"user_guide/#Expression-Complexity-Error","page":"User Guide","title":"Expression Complexity Error","text":"Expressions exceed term limit. Solutions:\n\nIncrease limit: eigvals(M, max_terms=50000)\nAdd structure (zeros, blocks)\nDisable expansion: eigvals(M, expand=false)","category":"section"},{"location":"user_guide/#Computation-Timeout","page":"User Guide","title":"Computation Timeout","text":"Exceeded time limit. Solutions:\n\nIncrease timeout: eigvals(M, timeout=900)\nSimplify matrix (fewer variables, more structure)\nUse partial numeric substitution","category":"section"},{"location":"user_guide/#Memory-Issues","page":"User Guide","title":"Memory Issues","text":"Fully symbolic 4×4 quartic produces very large expressions. Solutions:\n\nAdd structure to avoid quartic formula\nUse block decomposition\nPartial numeric substitution","category":"section"},{"location":"user_guide/#Verification","page":"User Guide","title":"Verification","text":"# Verify diagonalization\nP, D, pairs = symbolic_diagonalize(M)\nusing Symbolics: simplify\n@assert all(iszero, simplify.(M - P * D * inv(P)))\n\n# Verify numerically\nM_test = substitute(M, Dict(a=>1, b=>2))\nλ_sym = substitute.(eigvals(M), Ref(Dict(a=>1, b=>2)))\nλ_num = LinearAlgebra.eigvals(Float64.(M_test))\n@assert isapprox(sort(real.(λ_sym)), sort(λ_num))","category":"section"},{"location":"user_guide/#Robust-Numerical-Evaluation","page":"User Guide","title":"Robust Numerical Evaluation","text":"For complex eigenvalue expressions (e.g., 6-parameter matrices), use the internal _evaluate_symbolic_expr function which handles floating-point edge cases:\n\nusing SymbolicDiagonalization, Symbolics, LinearAlgebra\n\n@variables a b c d e f\nA = [a b c; b d e; c e f]\nvals, _, _ = symbolic_eigenvalues(A; timeout=600)\n\n# Test values\ntest_vals = Dict(a => 1.0, b => 0.5, c => 0.3, d => 2.0, e => 0.4, f => 3.0)\n\n# Robust evaluation (handles sqrt of tiny negative numbers)\ncomputed = [real(SymbolicDiagonalization._evaluate_symbolic_expr(v, test_vals)) \n            for v in vals]\n\n# Compare to numerical eigenvalues\nA_num = Float64[1.0 0.5 0.3; 0.5 2.0 0.4; 0.3 0.4 3.0]\ntrue_eigs = eigvals(Symmetric(A_num))\n\n@assert isapprox(sort(computed), sort(true_eigs), atol=1e-10)\n\nThis function uses Complex{Float64} arithmetic internally to avoid NaN from sqrt of tiny negative numbers caused by floating-point precision issues.","category":"section"},{"location":"user_guide/#Physical-Examples","page":"User Guide","title":"Physical Examples","text":"","category":"section"},{"location":"user_guide/#Vibrating-String","page":"User Guide","title":"Vibrating String","text":"@variables k m\nn = 5\nK = diagm(0 => fill(2k, n), 1 => fill(-k, n-1), -1 => fill(-k, n-1))\nλ = eigvals(K)  # ωₖ² = λₖ/m","category":"section"},{"location":"user_guide/#Tight-Binding-Model","page":"User Guide","title":"Tight-Binding Model","text":"@variables t ε\nn = 4\nH = diagm(0 => fill(ε, n), 1 => fill(-t, n-1), -1 => fill(-t, n-1))\nE = eigvals(H)  # Eₖ = ε - 2t·cos(kπ/(n+1))","category":"section"},{"location":"user_guide/#Cycle-Graph-Laplacian","page":"User Guide","title":"Cycle Graph Laplacian","text":"@variables d\nL = [2d -d 0 0 0 -d; -d 2d -d 0 0 0; 0 -d 2d -d 0 0;\n     0 0 -d 2d -d 0; 0 0 0 -d 2d -d; -d 0 0 0 -d 2d]\nλ = eigvals(L)  # λₖ = 2d(1 - cos(2πk/n))","category":"section"},{"location":"user_guide/#See-Also","page":"User Guide","title":"See Also","text":"API Reference - Complete function signatures\nPattern Library - All 16+ patterns with details\nMathematical Background - Theory","category":"section"},{"location":"pattern_library/#Pattern-Library","page":"Pattern Library","title":"Pattern Library","text":"Catalog of matrix patterns with closed-form eigenvalue solutions.","category":"section"},{"location":"pattern_library/#Quick-Reference","page":"Pattern Library","title":"Quick Reference","text":"Pattern Formula/Method Complexity\nDiagonal Direct: lambda_i = d_i O(n)\nTriangular Diagonal entries O(n)\nBlock-diagonal Union of block eigenvalues sum O(n_i)\nCirculant DFT: lambda_k = sum c_j omega^jk O(n)\nSym. Toeplitz tridiag lambda_k = a + 2bcos(kpi(n+1)) O(n)\nKronecker A otimes B Products: lambda_i(A) cdot lambda_j(B) O(m+n)\nNested Kronecker A_1 otimes cdots otimes A_k Product of all factors O(sum n_i)\nSO(2) Kronecker R(theta) otimes R(phi) e^pm i(theta pm phi) O(1)\nSU(2) Kronecker U(alpha) otimes U(beta) e^pm i(alpha pm beta)2 O(1)\nSU(3) Kronecker U(alpha_1alpha_2) otimes U(beta_1beta_2) Phase sums O(1)\nSO(n) for n ≤ 4 Trace-based symbolic formulas O(1)\nPermutation Roots of unity from cycle structure O(n)\nPersymmetric Half-size decomposition O(n2)\nAnti-diagonal pm pairs O(n)\nJordan block Single eigenvalue lambda with multiplicity n O(1)\n\n","category":"section"},{"location":"pattern_library/#Basic-Patterns","page":"Pattern Library","title":"Basic Patterns","text":"","category":"section"},{"location":"pattern_library/#Diagonal","page":"Pattern Library","title":"Diagonal","text":"Eigenvalues: Diagonal entries d_1 d_2 ldots d_n\n\n@variables a b c\nD = [a 0 0; 0 b 0; 0 0 c]\neigvals(D)  # [a, b, c]","category":"section"},{"location":"pattern_library/#Triangular","page":"Pattern Library","title":"Triangular","text":"Eigenvalues: Diagonal entries (upper or lower triangular)\n\n@variables a b c\nU = [a 1 2; 0 b 3; 0 0 c]\neigvals(U)  # [a, b, c]","category":"section"},{"location":"pattern_library/#Jordan-Blocks","page":"Pattern Library","title":"Jordan Blocks","text":"Eigenvalues: lambda with algebraic multiplicity n, geometric multiplicity 1\n\n@variables λ\nJ = [λ 1 0; 0 λ 1; 0 0 λ]\neigvals(J)  # [λ, λ, λ]\n\nNote: Not diagonalizable for n  1.\n\n","category":"section"},{"location":"pattern_library/#Structure-Based-Patterns","page":"Pattern Library","title":"Structure-Based Patterns","text":"","category":"section"},{"location":"pattern_library/#Block-Diagonal","page":"Pattern Library","title":"Block-Diagonal","text":"Eigenvalues: lambda(B) = lambda(A_1) cup lambda(A_2) cup cdots\n\n@variables a b c d\nB = [a b 0 0; b a 0 0; 0 0 c d; 0 0 d c]\neigvals(B)  # [a+b, a-b, c+d, c-d]\n\nReduces degree-n problem to smaller independent problems.","category":"section"},{"location":"pattern_library/#Persymmetric","page":"Pattern Library","title":"Persymmetric","text":"Definition: Qij = Qn+1-j n+1-i (symmetric about anti-diagonal)\n\nSplits into two half-sized eigenvalue problems via transformation with flip matrix.\n\n@variables a b c d e f\nP = [a b c d; b e f c; c f e b; d c b a]\neigvals(P)  # Solves two 2×2 problems\n\n","category":"section"},{"location":"pattern_library/#Symmetry-Based-Patterns","page":"Pattern Library","title":"Symmetry-Based Patterns","text":"","category":"section"},{"location":"pattern_library/#Circulant-Matrices","page":"Pattern Library","title":"Circulant Matrices","text":"Definition: Each row is cyclic shift of previous row\n\nEigenvalues (any size n): lambda_k = sum_j=0^n-1 c_j omega^jk quad omega = e^2pi in\n\n@variables a b c\nC = [a b c; c a b; b c a]\neigvals(C)  # DFT of first row\n\nWorks for arbitrarily large n - bypasses Abel-Ruffini.","category":"section"},{"location":"pattern_library/#Block-Circulant","page":"Pattern Library","title":"Block Circulant","text":"Block-level circulant structure. Eigenvalues from n problems of size k: lambda(BC) = bigcup_m=0^n-1 lambdaleft(sum_j A_j omega^mjright)\n\nRequires block size k leq 4 for closed form.","category":"section"},{"location":"pattern_library/#Anti-Diagonal","page":"Pattern Library","title":"Anti-Diagonal","text":"Definition: Non-zero only on anti-diagonal with symmetry\n\nEigenvalues: Come in pm pairs (center unpaired for odd n)\n\n@variables a b c\nA = [0 0 0 0 a; 0 0 0 b 0; 0 0 c 0 0; 0 b 0 0 0; a 0 0 0 0]\neigvals(A)  # {c, ±a, ±b}\n\n","category":"section"},{"location":"pattern_library/#Tensor-Product-Patterns","page":"Pattern Library","title":"Tensor Product Patterns","text":"","category":"section"},{"location":"pattern_library/#Kronecker-Products","page":"Pattern Library","title":"Kronecker Products","text":"Eigenvalues: All products of factor eigenvalues lambda(A otimes B) = lambda_i(A) cdot lambda_j(B)\n\n@variables a b c d\nA = [a 0; 0 b]\nB = [c 0; 0 d]\nK = kron(A, B)\neigvals(K)  # [ac, ad, bc, bd]\n\nReduces (mn) times (mn) to m times m and n times n problems.","category":"section"},{"location":"pattern_library/#Nested-Kronecker-Products","page":"Pattern Library","title":"Nested Kronecker Products","text":"Eigenvalues: For A_1 otimes A_2 otimes cdots otimes A_k, all products of factor eigenvalues: lambda(A_1 otimes cdots otimes A_k) = lambda_i_1(A_1) cdot lambda_i_2(A_2) cdots lambda_i_k(A_k)\n\nusing Symbolics\n\n# Create 5 independent 2×2 symmetric matrices\nmatrices = Matrix{Num}[]\nfor i in 1:5\n    a = Symbolics.variable(Symbol(\"a$i\"))\n    b = Symbolics.variable(Symbol(\"b$i\"))\n    c = Symbolics.variable(Symbol(\"c$i\"))\n    push!(matrices, [a b; b c])\nend\n\n# Build 32×32 matrix with 15 parameters\nK = reduce(kron, matrices)\neigvals(K)  # 32 eigenvalues as products\n\nPerformance: Recursive detection and solving handles arbitrary depth efficiently:\n\nDepth Matrix Size Parameters Eigenvalues Time\n3 8×8 9 8 ~12s\n5 32×32 15 32 ~12s\n7 128×128 21 128 ~23s\n10 1024×1024 30 1024 ~33s\n\nThe algorithm recursively factors K = A otimes B, solves each factor independently, then forms all pairwise products. This bypasses the exponential complexity of direct symbolic computation on the full matrix.","category":"section"},{"location":"pattern_library/#SO(2)-Kronecker-Products","page":"Pattern Library","title":"SO(2) Kronecker Products","text":"Definition: Kronecker product of SO(2) rotation matrices R(theta) = beginpmatrix costheta  -sintheta  sintheta  costheta endpmatrix\n\nEigenvalues for R(theta) otimes R(phi): lambda = e^pm i(theta pm phi) = cos(theta pm phi) pm i sin(theta pm phi)\n\nThe four eigenvalues are:\n\ncos(theta + phi) + isin(theta + phi)\ncos(theta + phi) - isin(theta + phi)\ncos(theta - phi) + isin(theta - phi)\ncos(theta - phi) - isin(theta - phi)\n\nConvenience constructors: Use R2(θ) to create rotation matrices and so2_kron(angles) for Kronecker products:\n\n@variables α β γ\n\n# 2-fold: 4×4 matrix\nK2 = so2_kron([α, β])\neigvals(K2)\n# [cos(-α - β) + im*sin(-α - β), cos(α - β) + im*sin(α - β),\n#  cos(-α + β) + im*sin(-α + β), cos(α + β) + im*sin(α + β)]\n\n# 3-fold: 8×8 matrix with 8 clean eigenvalues\nK3 = so2_kron([α, β, γ])\neigvals(K3)  # cos(±α ± β ± γ) + i·sin(±α ± β ± γ) for all 8 sign combinations\n\nDirect eigenvalue computation: For faster computation without building the matrix:\n\nso2_kron_eigenvalues([α, β, γ])  # Returns 8 eigenvalues directly\n\nSame-angle case: R(theta) otimes R(theta) uses double-angle formulas:\n\neigvals(kron(R2(θ), R2(θ)))\n# [cos(2θ) + im*sin(2θ), 1, 1, cos(2θ) - im*sin(2θ)]\n\nImplementation: Uses direct extraction of (cos, sin) pairs from matrix entries, avoiding the sqrt(cos²) problem that produces messy symbolic expressions.\n\nNesting: Works recursively for R(theta_1) otimes R(theta_2) otimes cdots otimes R(theta_k) with 2^k clean eigenvalues.\n\n","category":"section"},{"location":"pattern_library/#Lie-Group-Patterns","page":"Pattern Library","title":"Lie Group Patterns","text":"","category":"section"},{"location":"pattern_library/#SO(n)-Rotation-Matrices","page":"Pattern Library","title":"SO(n) Rotation Matrices","text":"Definition: Orthogonal matrices with determinant +1 (special orthogonal group)\n\nEigenvalue Structure:\n\nAll eigenvalues lie on the unit circle: lambda = 1\nThey come in conjugate pairs: e^pm itheta_j\nOdd dimensions have eigenvalue 1 (rotation axis)\n\nSymbolic closed-form solutions for n leq 4:\n\nDimension Eigenvalues Notes\nSO(2) costheta pm isintheta Direct extraction\nSO(3) 1 costheta pm isintheta Trace-based\nSO(4) costheta_1 pm isintheta_1 costheta_2 pm isintheta_2 Block-diagonal preferred\n\nNote: SO(5)+ are not supported symbolically. For numeric SO(n) matrices, use LinearAlgebra.eigvals().\n\nBlock-diagonal detection: For SO(4) matrices that are block-diagonal (two independent SO(2) rotations), the package prioritizes block-diagonal detection to produce the cleanest eigenvalues.\n\n# Symbolic SO(3) rotation\n@variables θ\nR3 = [cos(θ) -sin(θ) 0; sin(θ) cos(θ) 0; 0 0 1]\neigvals(R3)  # [1, cos(θ) + im*sin(θ), cos(θ) - im*sin(θ)]\n\n# Block-diagonal SO(4) - cleanest output\n@variables θ φ\nR4 = [cos(θ) -sin(θ) 0 0; sin(θ) cos(θ) 0 0; 0 0 cos(φ) -sin(φ); 0 0 sin(φ) cos(φ)]\neigvals(R4)  # [cos(θ) + im*sin(θ), cos(θ) - im*sin(θ), cos(φ) + im*sin(φ), cos(φ) - im*sin(φ)]","category":"section"},{"location":"pattern_library/#Other-Supported-Lie-Groups","page":"Pattern Library","title":"Other Supported Lie Groups","text":"Group Dimension Description Eigenvalue Property\nSU(2) 2×2 Special unitary e^pm itheta2 with half-angles\nSU(3) 3×3 Special unitary Product = 1, 2 independent angles\nSp(2) 2×2 Symplectic (≅ SL(2)) Reciprocal pairs\nSp(4) 4×4 Symplectic Reciprocal pairs","category":"section"},{"location":"pattern_library/#SU(2)-Kronecker-Products","page":"Pattern Library","title":"SU(2) Kronecker Products","text":"Definition: Kronecker product of SU(2) rotation matrices (spin-1/2)\n\nSU(2) rotations are parameterized by half-angles due to the spin-1/2 representation: U_z(theta) = beginpmatrix e^-itheta2  0  0  e^itheta2 endpmatrix\n\nEigenvalues for U_z(alpha) otimes U_z(beta): lambda = e^pm i(alpha pm beta)2 = cosleft(fracalpha pm beta2right) pm i sinleft(fracalpha pm beta2right)\n\n@variables α β\n\n# SU(2) rotation constructors\nUz(α)  # diagonal SU(2) rotation\n\n# 2-fold Kronecker product\nK = su2_kron([α, β])\neigvals(K)\n# [cos((α+β)/2) + im*sin((α+β)/2),\n#  cos((α-β)/2) + im*sin((α-β)/2),\n#  cos((α-β)/2) - im*sin((α-β)/2),\n#  cos((α+β)/2) - im*sin((α+β)/2)]\n\nDirect eigenvalue computation:\n\nsu2_kron_eigenvalues([α, β])  # Returns 4 eigenvalues directly","category":"section"},{"location":"pattern_library/#SU(3)-Kronecker-Products","page":"Pattern Library","title":"SU(3) Kronecker Products","text":"Definition: Kronecker product of diagonal SU(3) matrices (Cartan subalgebra)\n\nDiagonal SU(3) matrices have 2 independent angles (constraint: det = 1): U(alpha_1 alpha_2) = beginpmatrix e^ialpha_1  0  0  0  e^ialpha_2  0  0  0  e^-i(alpha_1+alpha_2) endpmatrix\n\nEigenvalues for U(alpha_1 alpha_2) otimes U(beta_1 beta_2) (9 total): All combinations of phase sums from the diagonal elements.\n\n@variables α₁ α₂ β₁ β₂\n\n# SU(3) diagonal constructor\nU = su3_diagonal_trig(α₁, α₂)\n\n# 9×9 Kronecker product\nK = su3_kron((α₁, α₂), (β₁, β₂))\neigvals(K)\n# [cos(α₁ + β₁) + im*sin(α₁ + β₁),\n#  cos(α₁ + β₂) + im*sin(α₁ + β₂),\n#  ... 9 eigenvalues total]\n\nDirect eigenvalue computation:\n\nsu3_kron_eigenvalues((α₁, α₂), (β₁, β₂))  # Returns 9 eigenvalues directly\n\n","category":"section"},{"location":"pattern_library/#Tridiagonal-Patterns","page":"Pattern Library","title":"Tridiagonal Patterns","text":"","category":"section"},{"location":"pattern_library/#Symmetric-Toeplitz-Tridiagonal","page":"Pattern Library","title":"Symmetric Toeplitz Tridiagonal","text":"Definition: Constant diagonals a (main), b (off-diagonal)\n\nEigenvalues (any size n): lambda_k = a + 2bcosleft(frackpin+1right) quad k = 1 ldots n\n\nEigenvectors: v_k(j) = sin(jkpi(n+1))\n\n@variables a b\nT = [a b 0 0; b a b 0; 0 b a b; 0 0 b a]\neigvals(T)","category":"section"},{"location":"pattern_library/#Special-55-Patterns","page":"Pattern Library","title":"Special 5×5 Patterns","text":"Two patterns with closed-form solutions discovered empirically:\n\nPattern [b,d,b,b]:\n\n[a b 0 0 0; b a d 0 0; 0 d a b 0; 0 0 b a b; 0 0 0 b a]\n\nPattern [b,b,d,b]:\n\n[a b 0 0 0; b a b 0 0; 0 b a d 0; 0 0 d a b; 0 0 0 b a]\n\nBoth have identical eigenvalues: a pm sqrt2b^2 + d^2 a pm b a\n\n","category":"section"},{"location":"pattern_library/#Permutation-Patterns","page":"Pattern Library","title":"Permutation Patterns","text":"","category":"section"},{"location":"pattern_library/#Permutation-Matrices","page":"Pattern Library","title":"Permutation Matrices","text":"Definition: Exactly one 1 per row/column, rest zeros\n\nEigenvalues: Roots of unity from cycle decomposition\n\nk\n-cycle contributes: 1 omega omega^2 ldots omega^k-1 where omega = e^2pi ik\n\n# 3-cycle (1→2→3→1)\nP = [0 1 0; 0 0 1; 1 0 0]\neigvals(P)  # {1, ω, ω²} where ω = e^{2πi/3}\n\n","category":"section"},{"location":"pattern_library/#Graph-Patterns","page":"Pattern Library","title":"Graph Patterns","text":"","category":"section"},{"location":"pattern_library/#Dihedral-Symmetry","page":"Pattern Library","title":"Dihedral Symmetry","text":"Matrices commuting with rotation and reflection. Eigenspaces decompose by representation theory, often reducing to quadratic equations.","category":"section"},{"location":"pattern_library/#Strongly-Regular-Graphs","page":"Pattern Library","title":"Strongly Regular Graphs","text":"Parameters (n k lambda mu) determine exactly 3 distinct eigenvalues:\n\nlambda_1 = k\nlambda_23 = frac(lambda-mu) pm sqrt(lambda-mu)^2 + 4(k-mu)2\n\nExample: Petersen graph (10301) → eigenvalues 3 1^(5) -2^(4)","category":"section"},{"location":"pattern_library/#Hypercube-Q_n","page":"Pattern Library","title":"Hypercube Q_n","text":"Eigenvalues: lambda_k = n - 2k with multiplicity binomnk\n\n# Q_3 (8×8 cube adjacency)\neigvals(Q3)  # [3, 1, 1, 1, -1, -1, -1, -3]","category":"section"},{"location":"pattern_library/#BCCB-(Block-Circulant-with-Circulant-Blocks)","page":"Pattern Library","title":"BCCB (Block-Circulant with Circulant Blocks)","text":"Diagonalized by 2D DFT. Common in image processing and 2D convolution.\n\n","category":"section"},{"location":"pattern_library/#Detection-Notes","page":"Pattern Library","title":"Detection Notes","text":"Pattern Detection Method\nDiagonal All off-diagonal zero\nTriangular Zeros above/below diagonal\nBlock-diagonal Connected components of non-zero structure\nCirculant Row i = cyclic shift of row i-1\nToeplitz tridiag Constant diagonals, symmetric\nKronecker Block scaling pattern\nSO(2) Kronecker Block structure + orthogonality + trig pattern\nSO(n) A^T A = I and det(A) = 1\nPermutation Exactly one 1 per row/column\n\n","category":"section"},{"location":"pattern_library/#Adding-New-Patterns","page":"Pattern Library","title":"Adding New Patterns","text":"Verify numerically (multiple test cases)\nVerify symbolically (characteristic polynomial)\nExplain mathematical basis\nImplement detector and solver\nAdd tests and documentation\n\nSee Contributing for details.","category":"section"},{"location":"group_theory_examples/#Group-Theory-Examples","page":"Group Theory Examples","title":"Group Theory Examples","text":"Worked examples showing how group theory enables symbolic diagonalization of matrices with n geq 5.","category":"section"},{"location":"group_theory_examples/#Pentagon-Graph-(Dihedral-D_5)","page":"Group Theory Examples","title":"Pentagon Graph (Dihedral D_5)","text":"Problem: 5×5 adjacency matrix - normally requires degree-5 polynomial (unsolvable by radicals).\n\nA = [0 1 0 0 1; 1 0 1 0 0; 0 1 0 1 0; 0 0 1 0 1; 1 0 0 1 0]\neigvals(A)  # [2, φ, φ, -1/φ, -1/φ] where φ = (1+√5)/2\n\nWhy it works: D_5 symmetry (5 rotations + 5 reflections) forces factorization into degree 1 + 2 + 2 polynomials. The golden ratio appears from pentagonal geometry.\n\nApplication: Cyclopentadienyl anion (C₅H₅⁻) molecular orbitals.\n\n","category":"section"},{"location":"group_theory_examples/#Petersen-Graph-(Strongly-Regular)","page":"Group Theory Examples","title":"Petersen Graph (Strongly Regular)","text":"Problem: 10×10 adjacency matrix - degree-10 polynomial.\n\nParameters: (n k lambda mu) = (10 3 0 1)\n\nEigenvalues (from formula, no polynomial solving):\n\nlambda_1 = 3\n(multiplicity 1)\nlambda_2 = 1\n(multiplicity 5)\nlambda_3 = -2\n(multiplicity 4)\n\nWhy it works: Strong regularity constrains to exactly 3 distinct eigenvalues: lambda_23 = frac(lambda-mu) pm sqrt(lambda-mu)^2 + 4(k-mu)2\n\n","category":"section"},{"location":"group_theory_examples/#Hypercube-Q_n","page":"Group Theory Examples","title":"Hypercube Q_n","text":"Problem: 2^n times 2^n adjacency matrix (exponentially large).\n\nEigenvalues (closed-form): lambda_k = n - 2k quad textmultiplicity  binomnk\n\nExamples:\n\nQ_3\n(8×8): 3 1^(3) -1^(3) -3\nQ_4\n(16×16): 4 2^(4) 0^(6) -2^(4) -4\nQ_5\n(32×32): 5 3^(5) 1^(10) -1^(10) -3^(5) -5\n\nWhy it works: Cayley graph of (mathbbZ_2)^n, diagonalized by Walsh-Hadamard basis.\n\n","category":"section"},{"location":"group_theory_examples/#Benzene-(Circulant)","page":"Group Theory Examples","title":"Benzene (Circulant)","text":"Problem: 6×6 Hückel Hamiltonian for π-electrons.\n\n@variables α β\nH = [α β 0 0 0 β; β α β 0 0 0; 0 β α β 0 0; \n     0 0 β α β 0; 0 0 0 β α β; β 0 0 0 β α]\n\nEigenvalues (DFT formula): lambda_k = alpha + 2betacos(2pi k6) quad k = 0 ldots 5\n\nExplicitly: alpha + 2beta (alpha + beta)^(2) (alpha - beta)^(2) alpha - 2beta\n\nApplication: Explains aromatic stability - filled bonding orbitals.\n\n","category":"section"},{"location":"group_theory_examples/#Quantum-Spin-j-Systems","page":"Group Theory Examples","title":"Quantum Spin-j Systems","text":"Problem: (2j+1) times (2j+1) angular momentum matrices.\n\nEigenvalues (from SU(2) representation theory): -j -j+1 ldots j-1 j\n\nAlways equally spaced by 1, regardless of which component (J_x, J_y, or J_z).\n\nExample: Spin-5/2 (6×6 matrix) has eigenvalues -52 -32 -12 12 32 52.\n\nWhy it works: SU(2) Lie algebra structure determines spectrum completely.\n\n","category":"section"},{"location":"group_theory_examples/#Solvable-Degree-5-Polynomials","page":"Group Theory Examples","title":"Solvable Degree-5 Polynomials","text":"While generic quintics are unsolvable, special cases work:\n\nType Example Galois Group Method\nPure power lambda^5 - a = 0 mathbbZ_5 Roots of unity\nReducible (lambda^2+1)(lambda^3-2)=0 Product Factor and solve\nDihedral Special quintics D_5 Resolvent + quadratics\n\nPure quintic: lambda^5 = a gives lambda_k = sqrt5a cdot e^2pi ik5\n\n","category":"section"},{"location":"group_theory_examples/#Key-Insight","page":"Group Theory Examples","title":"Key Insight","text":"Symmetry constrains eigenvalue structure.\n\nSymmetry Effect\nCyclic mathbbZ_n DFT diagonalizes (circulant)\nDihedral D_n Factorizes into small pieces\nStrong regularity Only 3 eigenvalues\nTensor product Eigenvalues multiply\nSU(2) Equally spaced spectrum\n\nThese transform intractable problems into closed-form solutions.","category":"section"},{"location":"implementation/#Implementation-Details","page":"Implementation Details","title":"Implementation Details","text":"Technical overview of algorithms and architecture.","category":"section"},{"location":"implementation/#Architecture","page":"Implementation Details","title":"Architecture","text":"Input Matrix\n    ↓\nStructure Detection\n    ↓ (pattern found?)\n    ├─ Yes → Pattern-Specific Solver\n    └─ No  → Characteristic Polynomial → Root Solver (degree ≤ 4)\n                                              ↓\n                                        Eigenvectors (if requested)","category":"section"},{"location":"implementation/#File-Organization","page":"Implementation Details","title":"File Organization","text":"src/\n├── SymbolicDiagonalization.jl  # Module, exports\n├── charpoly.jl                 # Characteristic polynomial (Bareiss)\n├── roots.jl                    # Root solvers (degrees 1-4)\n├── rref.jl                     # RREF, nullspace\n├── structure.jl                # Structure detection, utilities\n├── diagonalize.jl              # Public API\n└── patterns/\n    ├── circulant.jl            # Circulant, block circulant\n    ├── graphs.jl               # Hypercube, strongly regular\n    ├── kronecker.jl            # Kronecker products\n    ├── permutation.jl          # Permutation matrices\n    └── tridiagonal.jl          # Toeplitz tridiagonal, special 5×5","category":"section"},{"location":"implementation/#Key-Algorithms","page":"Implementation Details","title":"Key Algorithms","text":"","category":"section"},{"location":"implementation/#Characteristic-Polynomial","page":"Implementation Details","title":"Characteristic Polynomial","text":"Algorithm: Bareiss (fraction-free Gaussian elimination)\n\nWhy: Standard elimination causes expression explosion; Bareiss keeps expressions polynomial-sized.\n\nCoefficient extraction: Taylor series at λ=0 using derivatives (avoids polynomial division).","category":"section"},{"location":"implementation/#Root-Solvers","page":"Implementation Details","title":"Root Solvers","text":"Degree Method Notes\n1 Direct x = -c_0c_1\n2 Quadratic Standard formula with discriminant simplification\n3 Cardano Depress → compute cube roots → back-substitute\n4 Ferrari Resolve cubic → decompose into quadratics\n\nQuartic warning: Produces ~13.5 MB expressions for fully symbolic 4×4 matrices.","category":"section"},{"location":"implementation/#Structure-Detection","page":"Implementation Details","title":"Structure Detection","text":"Detection order (most specific first):\n\nDiagonal / Triangular\nBlock-diagonal (greedy connected components)\nCirculant / Block circulant\nToeplitz tridiagonal\nPermutation matrix\nKronecker product\nAnti-diagonal / Persymmetric\nSpecial 5×5 patterns\n\nAll detection uses _issymzero(x) which conservatively returns false if zero cannot be proven.","category":"section"},{"location":"implementation/#Pattern-Solvers","page":"Implementation Details","title":"Pattern Solvers","text":"Pattern Algorithm Complexity\nCirculant DFT of first row O(n^2)\nToeplitz tridiagonal Cosine formula O(n)\nKronecker Solve factors, multiply O(T(m) + T(n))\nPermutation Cycle decomposition → roots of unity O(n)\nBlock-diagonal Solve blocks recursively sum O(n_i)","category":"section"},{"location":"implementation/#Eigenvector-Computation","page":"Implementation Details","title":"Eigenvector Computation","text":"Two methods:\n\nAdjugate (n ≤ 3): Columns of adj(A - λI) are in nullspace\nRREF nullspace (general): Row reduce A - λI, extract free variables","category":"section"},{"location":"implementation/#Expression-Management","page":"Implementation Details","title":"Expression Management","text":"","category":"section"},{"location":"implementation/#Problem","page":"Implementation Details","title":"Problem","text":"Symbolic expressions grow exponentially without management.","category":"section"},{"location":"implementation/#Solutions","page":"Implementation Details","title":"Solutions","text":"Aggressive simplification: Applied after every intermediate step\nComplexity limits: max_terms parameter (default 10,000)\nTimeout: timeout parameter (default 300s)","category":"section"},{"location":"implementation/#Symbolic-Square-Root","page":"Implementation Details","title":"Symbolic Square Root","text":"Custom implementation for Complex{Num} since Julia's sqrt has boolean checks that fail symbolically:\n\nsqrt(a + bi) = sqrt((r+a)/2) + i·sqrt((r-a)/2)  where r = |a + bi|","category":"section"},{"location":"implementation/#Performance","page":"Implementation Details","title":"Performance","text":"","category":"section"},{"location":"implementation/#Complexity","page":"Implementation Details","title":"Complexity","text":"Operation Complexity\nBareiss determinant O(n^3)\nRoot solving O(textexpr_size^textdegree)\nRREF O(n^3 times textexpr_size)\nCirculant eigenvalues O(n^2)\nTridiagonal eigenvalues O(n)","category":"section"},{"location":"implementation/#Memory-(fully-symbolic-matrices)","page":"Implementation Details","title":"Memory (fully symbolic matrices)","text":"Size Eigenvalues\n2×2 ~1 KB\n3×3 ~100 KB\n4×4 ~50 MB","category":"section"},{"location":"implementation/#Threading","page":"Implementation Details","title":"Threading","text":"Not supported: Symbolics.jl uses task-local storage that is not thread-safe. Use process-based parallelism (Distributed.jl) if needed.","category":"section"},{"location":"implementation/#Extending","page":"Implementation Details","title":"Extending","text":"","category":"section"},{"location":"implementation/#Adding-a-Pattern","page":"Implementation Details","title":"Adding a Pattern","text":"Add detection function _is_pattern(mat) returning nothing or detection info\nAdd solver _pattern_eigenvalues(mat, info)\nAdd to detection cascade in diagonalize.jl\nAdd tests in test/test_patterns.jl\n\nSee Contributing for details.","category":"section"},{"location":"#SymbolicDiagonalization.jl","page":"Home","title":"SymbolicDiagonalization.jl","text":"Symbolic matrix diagonalization for Julia using Symbolics.jl.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Closed-form eigenvalue solvers for degrees 1-4 (linear, quadratic, Cardano, Ferrari)\nAutomatic structure detection for larger matrices (16+ patterns)\nLie group detection (SO(2)-SO(4), SU(2), SU(3), Sp(2), Sp(4)) with symbolic eigenvalues\nAggressive trigonometric simplification (sqrt(1-cos²θ) → sin(θ))\nSO(2) Kronecker products with automatic trig simplification\nDiagonal shift optimization for full 6-parameter 3×3 symmetric matrices\nNested Kronecker products (A₁ ⊗ A₂ ⊗ ... ⊗ Aₙ) - scales to 1024×1024 with 30 parameters\nDrop-in LinearAlgebra interface: eigen(), eigvals()","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"SymbolicDiagonalization\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using SymbolicDiagonalization\nusing Symbolics\nusing LinearAlgebra\n\n@variables a b c\nmat = [a 1 0; 0 b 1; 0 0 c]\n\nE = eigen(mat)        # Eigen object with .values and .vectors\nE.values\n\neigvals(mat)          # eigenvalues only","category":"section"},{"location":"#Highlights","page":"Home","title":"Highlights","text":"","category":"section"},{"location":"#Full-6-Parameter-33-Symmetric-Matrices","page":"Home","title":"Full 6-Parameter 3×3 Symmetric Matrices","text":"@variables a b c d e f\nA = [a b c; b d e; c e f]  # 6 independent parameters\neigvals(A)  # Works via diagonal shift optimization (~107s)","category":"section"},{"location":"#Nested-Kronecker-Products","page":"Home","title":"Nested Kronecker Products","text":"# 10-fold Kronecker product: 1024×1024 matrix with 30 parameters!\nmatrices = [[Symbolics.variable(Symbol(\"a$i\")) Symbolics.variable(Symbol(\"b$i\"));\n             Symbolics.variable(Symbol(\"b$i\")) Symbolics.variable(Symbol(\"c$i\"))] for i in 1:10]\nK = reduce(kron, matrices)\neigvals(K)  # 1024 symbolic eigenvalues in ~33 seconds","category":"section"},{"location":"#SO(2)-Rotation-Kronecker-Products","page":"Home","title":"SO(2) Rotation Kronecker Products","text":"When Kronecker products of SO(2) rotation matrices are detected, eigenvalues are  automatically simplified to clean trigonometric form:\n\n@variables θ φ\nR(x) = [cos(x) -sin(x); sin(x) cos(x)]\n\neigvals(kron(R(θ), R(φ)))\n# [cos(θ+φ) + im*sin(θ+φ), cos(θ-φ) + im*sin(θ-φ),\n#  cos(θ-φ) - im*sin(θ-φ), cos(θ+φ) - im*sin(θ+φ)]\n\neigvals(kron(R(θ), R(θ)))  # Same-angle case\n# [cos(2θ) + im*sin(2θ), 1, 1, cos(2θ) - im*sin(2θ)]","category":"section"},{"location":"#Supported-Patterns","page":"Home","title":"Supported Patterns","text":"For matrices larger than 4×4, the package detects and exploits special structure:\n\nPattern Description\nDiagonal Direct extraction\nTriangular Diagonal elements\nBlock-diagonal Recursive solving\nCirculant DFT-based (any size n)\nSymmetric Toeplitz tridiagonal Cosine formula (any size n)\nKronecker products A ⊗ B Product of factor eigenvalues\nNested Kronecker A₁ ⊗ A₂ ⊗ ... ⊗ Aₙ Recursive decomposition (any depth)\nSO(2) Kronecker R(θ) ⊗ R(φ) Clean trig form: cos(θ±φ) + i·sin(θ±φ)\nPermutation Roots of unity from cycle structure\nPersymmetric Half-size decomposition\n\nSee Pattern Library for the complete list with examples.","category":"section"},{"location":"#Performance","page":"Home","title":"Performance","text":"Matrix Size Parameters Time\n3×3 symmetric (full) 3×3 6 ~107s\n3×3 ⊗ 2×2 Kronecker 6×6 9 ~165s\n2×2^⊗5 nested Kronecker 32×32 15 ~12s\n2×2^⊗10 nested Kronecker 1024×1024 30 ~33s","category":"section"},{"location":"#Limitations","page":"Home","title":"Limitations","text":"General 5×5+ matrices: No closed-form solution exists (Abel-Ruffini theorem) - requires exploitable structure\nExpression size: Fully symbolic 4×4 quartics can produce large expressions\nSimplification: Results may not be in minimal form","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"Getting Started\n\nUser Guide - Installation, workflows, troubleshooting\nAPI Reference - Complete function signatures\n\nPatterns & Theory\n\nPattern Library - All 16+ patterns with examples\nMathematical Background - Theory and algorithms\nGroup Theory Examples - Symmetry-based approaches\n\nDevelopment\n\nImplementation Details - Internals and algorithms\nContributing - Development setup and guidelines","category":"section"}]
}

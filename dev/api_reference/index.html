<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · SymbolicDiagonalization</title><meta name="title" content="API Reference · SymbolicDiagonalization"/><meta property="og:title" content="API Reference · SymbolicDiagonalization"/><meta property="twitter:title" content="API Reference · SymbolicDiagonalization"/><meta name="description" content="Documentation for SymbolicDiagonalization."/><meta property="og:description" content="Documentation for SymbolicDiagonalization."/><meta property="twitter:description" content="Documentation for SymbolicDiagonalization."/><meta property="og:url" content="https://volkerkarle.github.io/SymbolicDiagonalization.jl/api_reference/"/><meta property="twitter:url" content="https://volkerkarle.github.io/SymbolicDiagonalization.jl/api_reference/"/><link rel="canonical" href="https://volkerkarle.github.io/SymbolicDiagonalization.jl/api_reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SymbolicDiagonalization</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../user_guide/">User Guide</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Table-of-Contents"><span>Table of Contents</span></a></li><li><a class="tocitem" href="#User-Facing-API"><span>User-Facing API</span></a></li><li><a class="tocitem" href="#Keyword-Arguments"><span>Keyword Arguments</span></a></li><li><a class="tocitem" href="#Exception-Types"><span>Exception Types</span></a></li><li><a class="tocitem" href="#Internal-API"><span>Internal API</span></a></li><li><a class="tocitem" href="#Usage-Examples"><span>Usage Examples</span></a></li><li><a class="tocitem" href="#See-Also"><span>See Also</span></a></li></ul></li><li><a class="tocitem" href="../pattern_library/">Pattern Library</a></li><li><a class="tocitem" href="../implementation/">Implementation Details</a></li><li><a class="tocitem" href="../mathematical_background/">Mathematical Background</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/volkerkarle/SymbolicDiagonalization.jl/blob/main/docs/src/api_reference.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>Complete API documentation for <code>SymbolicDiagonalization.jl</code>.</p><h2 id="Table-of-Contents"><a class="docs-heading-anchor" href="#Table-of-Contents">Table of Contents</a><a id="Table-of-Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Table-of-Contents" title="Permalink"></a></h2><ul><li><a href="#user-facing-api">User-Facing API</a><ul><li><a href="#linearalgebra-interface">LinearAlgebra Interface</a></li><li><a href="#direct-eigenvalue-api">Direct Eigenvalue API</a></li><li><a href="#characteristic-polynomial">Characteristic Polynomial</a></li><li><a href="#root-solvers">Root Solvers</a></li></ul></li><li><a href="#keyword-arguments">Keyword Arguments</a></li><li><a href="#exception-types">Exception Types</a></li><li><a href="#internal-api">Internal API</a></li></ul><hr/><h2 id="User-Facing-API"><a class="docs-heading-anchor" href="#User-Facing-API">User-Facing API</a><a id="User-Facing-API-1"></a><a class="docs-heading-anchor-permalink" href="#User-Facing-API" title="Permalink"></a></h2><h3 id="LinearAlgebra-Interface"><a class="docs-heading-anchor" href="#LinearAlgebra-Interface">LinearAlgebra Interface</a><a id="LinearAlgebra-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#LinearAlgebra-Interface" title="Permalink"></a></h3><p>The recommended interface for most users. Extends <code>LinearAlgebra.jl</code> with symbolic matrix support.</p><h4 id="LinearAlgebra.eigen"><a class="docs-heading-anchor" href="#LinearAlgebra.eigen"><code>LinearAlgebra.eigen</code></a><a id="LinearAlgebra.eigen-1"></a><a class="docs-heading-anchor-permalink" href="#LinearAlgebra.eigen" title="Permalink"></a></h4><pre><code class="language-julia hljs">eigen(A; kwargs...) → Eigen</code></pre><p>Computes eigenvalues and eigenvectors of symbolic matrix A.</p><p><strong>Arguments</strong>:</p><ul><li><code>A::Matrix{Union{Num, Complex{Num}}}</code> - Symbolic matrix to diagonalize</li></ul><p><strong>Keyword Arguments</strong>: See <a href="#keyword-arguments">Keyword Arguments</a> section</p><p><strong>Returns</strong>: <code>Eigen</code> object with fields:</p><ul><li><code>.values</code> - Vector of eigenvalues</li><li><code>.vectors</code> - Matrix of eigenvectors (as columns)</li></ul><p><strong>Example</strong>:</p><pre><code class="language-julia hljs">using Symbolics, SymbolicDiagonalization, LinearAlgebra

@variables a b c
mat = [a 1 0; 0 b 1; 0 0 c]

E = eigen(mat)
E.values   # [a, b, c]
E.vectors  # 3×3 eigenvector matrix</code></pre><p><strong>Notes</strong>:</p><ul><li>Use <code>eigvals()</code> instead if you only need eigenvalues (faster)</li><li>Throws error if matrix is not diagonalizable</li><li>Eigenvectors are columns of the returned matrix</li></ul><hr/><h4 id="LinearAlgebra.eigvals"><a class="docs-heading-anchor" href="#LinearAlgebra.eigvals"><code>LinearAlgebra.eigvals</code></a><a id="LinearAlgebra.eigvals-1"></a><a class="docs-heading-anchor-permalink" href="#LinearAlgebra.eigvals" title="Permalink"></a></h4><pre><code class="language-julia hljs">eigvals(A; kwargs...) → Vector</code></pre><p>Computes eigenvalues of symbolic matrix A (faster than <code>eigen</code> since it skips eigenvectors).</p><p><strong>Arguments</strong>:</p><ul><li><code>A::Matrix{Union{Num, Complex{Num}}}</code> - Symbolic matrix</li></ul><p><strong>Keyword Arguments</strong>: See <a href="#keyword-arguments">Keyword Arguments</a> section</p><p><strong>Returns</strong>: Vector of eigenvalue expressions</p><p><strong>Example</strong>:</p><pre><code class="language-julia hljs">@variables a b
mat = [a b; b a]

λ = eigvals(mat)  # [a + b, a - b]</code></pre><p><strong>Notes</strong>:</p><ul><li>Recommended when eigenvectors not needed</li><li>Much faster than <code>eigen()</code> for large matrices</li><li>Same structure detection and special pattern solvers</li></ul><hr/><h3 id="Direct-Eigenvalue-API"><a class="docs-heading-anchor" href="#Direct-Eigenvalue-API">Direct Eigenvalue API</a><a id="Direct-Eigenvalue-API-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-Eigenvalue-API" title="Permalink"></a></h3><p>Lower-level API for advanced users who need more control.</p><h4 id="symbolic_eigenvalues"><a class="docs-heading-anchor" href="#symbolic_eigenvalues"><code>symbolic_eigenvalues</code></a><a id="symbolic_eigenvalues-1"></a><a class="docs-heading-anchor-permalink" href="#symbolic_eigenvalues" title="Permalink"></a></h4><pre><code class="language-julia hljs">symbolic_eigenvalues(A; kwargs...) → (values, poly, λ)</code></pre><p>Computes eigenvalues along with characteristic polynomial.</p><p><strong>Arguments</strong>:</p><ul><li><code>A::Matrix</code> - Symbolic matrix</li></ul><p><strong>Keyword Arguments</strong>: See <a href="#keyword-arguments">Keyword Arguments</a> section</p><p><strong>Returns</strong>: Tuple of:</p><ul><li><code>values</code> - Vector of eigenvalue expressions</li><li><code>poly</code> - Characteristic polynomial det(λI - A)</li><li><code>λ</code> - Symbolic variable used in polynomial</li></ul><p><strong>Example</strong>:</p><pre><code class="language-julia hljs">@variables a b
mat = [a b; b a]

vals, poly, λ = symbolic_eigenvalues(mat)
# vals: [a+b, a-b]
# poly: (λ - a)² - b²
# λ: symbolic variable</code></pre><p><strong>Use cases</strong>:</p><ul><li>Need both eigenvalues and characteristic polynomial</li><li>Want to manipulate polynomial directly</li><li>Need the eigenvalue variable for further computation</li></ul><hr/><h4 id="symbolic_eigenpairs"><a class="docs-heading-anchor" href="#symbolic_eigenpairs"><code>symbolic_eigenpairs</code></a><a id="symbolic_eigenpairs-1"></a><a class="docs-heading-anchor-permalink" href="#symbolic_eigenpairs" title="Permalink"></a></h4><pre><code class="language-julia hljs">symbolic_eigenpairs(A; kwargs...) → Vector{Tuple{Num, Vector{Vector{Num}}}}</code></pre><p>Computes eigenvalue-eigenvector pairs with multiplicity handling.</p><p><strong>Arguments</strong>:</p><ul><li><code>A::Matrix</code> - Symbolic matrix</li></ul><p><strong>Keyword Arguments</strong>: </p><ul><li><code>compute_vectors::Bool = true</code> - Whether to compute eigenvectors</li><li>Plus all <a href="#keyword-arguments">standard kwargs</a></li></ul><p><strong>Returns</strong>: Vector of tuples <code>(eigenvalue, eigenvectors)</code>:</p><ul><li>Each eigenvalue may have multiple eigenvectors (geometric multiplicity)</li><li>Eigenvectors are vectors, not matrix columns</li></ul><p><strong>Example</strong>:</p><pre><code class="language-julia hljs">@variables a b
mat = [a b; b a]

pairs = symbolic_eigenpairs(mat)
# [(a+b, [v₁]), (a-b, [v₂])]

# Access first eigenvalue and its eigenvectors
λ₁, vecs₁ = pairs[1]</code></pre><p><strong>Use cases</strong>:</p><ul><li>Need explicit multiplicity information</li><li>Want eigenvalues grouped with their eigenvectors</li><li>Need to handle degenerate cases</li></ul><hr/><h4 id="symbolic_diagonalize"><a class="docs-heading-anchor" href="#symbolic_diagonalize"><code>symbolic_diagonalize</code></a><a id="symbolic_diagonalize-1"></a><a class="docs-heading-anchor-permalink" href="#symbolic_diagonalize" title="Permalink"></a></h4><pre><code class="language-julia hljs">symbolic_diagonalize(A; kwargs...) → (P, D, pairs)</code></pre><p>Computes full diagonalization A = P D P⁻¹.</p><p><strong>Arguments</strong>:</p><ul><li><code>A::Matrix</code> - Symbolic matrix</li></ul><p><strong>Keyword Arguments</strong>: See <a href="#keyword-arguments">Keyword Arguments</a> section</p><p><strong>Returns</strong>: Tuple of:</p><ul><li><code>P</code> - Matrix of eigenvectors (columns)</li><li><code>D</code> - Diagonal matrix of eigenvalues</li><li><code>pairs</code> - Same as <code>symbolic_eigenpairs()</code> output</li></ul><p><strong>Example</strong>:</p><pre><code class="language-julia hljs">@variables a b
mat = [a b; b a]

P, D, pairs = symbolic_diagonalize(mat)
# Verify: mat ≈ P * D * inv(P)</code></pre><p><strong>Throws</strong>:</p><ul><li><code>ArgumentError</code> if matrix is not diagonalizable</li><li><code>ArgumentError</code> if insufficient eigenvectors found</li></ul><p><strong>Use cases</strong>:</p><ul><li>Need explicit matrix factorization</li><li>Want to verify diagonalizability</li><li>Need P and D matrices for further computation</li></ul><hr/><h3 id="Characteristic-Polynomial"><a class="docs-heading-anchor" href="#Characteristic-Polynomial">Characteristic Polynomial</a><a id="Characteristic-Polynomial-1"></a><a class="docs-heading-anchor-permalink" href="#Characteristic-Polynomial" title="Permalink"></a></h3><h4 id="characteristic_polynomial"><a class="docs-heading-anchor" href="#characteristic_polynomial"><code>characteristic_polynomial</code></a><a id="characteristic_polynomial-1"></a><a class="docs-heading-anchor-permalink" href="#characteristic_polynomial" title="Permalink"></a></h4><pre><code class="language-julia hljs">characteristic_polynomial(A; var=nothing) → (poly, coeffs, λ)</code></pre><p>Computes characteristic polynomial det(λI - A) using Bareiss algorithm.</p><p><strong>Arguments</strong>:</p><ul><li><code>A::Matrix</code> - Symbolic matrix</li><li><code>var</code> - Optional symbolic variable to use (auto-generated if not provided)</li></ul><p><strong>Returns</strong>: Tuple of:</p><ul><li><code>poly</code> - Polynomial expression det(λI - A)</li><li><code>coeffs</code> - Vector of polynomial coefficients [c₀, c₁, ..., cₙ]</li><li><code>λ</code> - Symbolic variable</li></ul><p><strong>Example</strong>:</p><pre><code class="language-julia hljs">@variables a b
mat = [a b; b a]

poly, coeffs, λ = characteristic_polynomial(mat)
# poly: λ² - 2a·λ + (a² - b²)
# coeffs: [a² - b², -2a, 1]</code></pre><p><strong>Implementation details</strong>:</p><ul><li>Uses <strong>Bareiss fraction-free determinant</strong> for efficiency</li><li>Avoids expression explosion from cofactor expansion</li><li>Coefficients extracted by differentiation at λ = 0</li></ul><p><strong>Use cases</strong>:</p><ul><li>Need characteristic polynomial for analysis</li><li>Want polynomial coefficients explicitly</li><li>Implementing custom root-finding methods</li></ul><hr/><h3 id="Root-Solvers"><a class="docs-heading-anchor" href="#Root-Solvers">Root Solvers</a><a id="Root-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Root-Solvers" title="Permalink"></a></h3><h4 id="symbolic_roots"><a class="docs-heading-anchor" href="#symbolic_roots"><code>symbolic_roots</code></a><a id="symbolic_roots-1"></a><a class="docs-heading-anchor-permalink" href="#symbolic_roots" title="Permalink"></a></h4><pre><code class="language-julia hljs">symbolic_roots(poly, λ; expand=true, max_terms=10000) → Vector</code></pre><p>Finds symbolic roots of polynomial using closed-form formulas (degrees 1-4).</p><p><strong>Arguments</strong>:</p><ul><li><code>poly</code> - Polynomial expression in variable λ</li><li><code>λ</code> - Symbolic variable</li><li><code>expand::Bool = true</code> - Whether to expand expressions</li><li><code>max_terms::Int = 10000</code> - Maximum expression complexity</li></ul><p><strong>Returns</strong>: Vector of symbolic root expressions</p><p><strong>Example</strong>:</p><pre><code class="language-julia hljs">@variables λ a b
poly = λ^2 - 2a*λ + (a^2 - b^2)

roots = symbolic_roots(poly, λ)
# [a + b, a - b]</code></pre><p><strong>Supported degrees</strong>:</p><ul><li><strong>Degree 1</strong>: Linear formula</li><li><strong>Degree 2</strong>: Quadratic formula</li><li><strong>Degree 3</strong>: Cardano&#39;s cubic formula</li><li><strong>Degree 4</strong>: Ferrari&#39;s quartic formula</li><li><strong>Degree ≥ 5</strong>: Throws error (Abel-Ruffini theorem)</li></ul><p><strong>Throws</strong>:</p><ul><li><code>ArgumentError</code> if degree ≥ 5 and no structure detected</li><li><code>ExpressionComplexityError</code> if expression exceeds <code>max_terms</code></li></ul><p><strong>Notes</strong>:</p><ul><li>Quartic formula produces very large expressions</li><li>Consider structure detection for degree ≥ 4</li><li>For degree 4, expressions can be ~13.5 MB each</li></ul><hr/><h2 id="Keyword-Arguments"><a class="docs-heading-anchor" href="#Keyword-Arguments">Keyword Arguments</a><a id="Keyword-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Keyword-Arguments" title="Permalink"></a></h2><p>All main functions (<code>eigen</code>, <code>eigvals</code>, <code>symbolic_eigenvalues</code>, etc.) accept these keyword arguments:</p><h3 id="var::Union{Nothing,-Num}"><a class="docs-heading-anchor" href="#var::Union{Nothing,-Num}"><code>var::Union{Nothing, Num}</code></a><a id="var::Union{Nothing,-Num}-1"></a><a class="docs-heading-anchor-permalink" href="#var::Union{Nothing,-Num}" title="Permalink"></a></h3><p><strong>Default</strong>: <code>nothing</code> (auto-generate)</p><p>Symbolic variable to use for eigenvalue. If <code>nothing</code>, a fresh variable is created.</p><p><strong>Example</strong>:</p><pre><code class="language-julia hljs">@variables λ
vals = eigvals(mat, var=λ)</code></pre><p><strong>Use cases</strong>: </p><ul><li>Need specific variable name</li><li>Integrating with existing symbolic expressions</li><li>Want to control variable scope</li></ul><hr/><h3 id="structure::Symbol"><a class="docs-heading-anchor" href="#structure::Symbol"><code>structure::Symbol</code></a><a id="structure::Symbol-1"></a><a class="docs-heading-anchor-permalink" href="#structure::Symbol" title="Permalink"></a></h3><p><strong>Default</strong>: <code>:auto</code></p><p>Hint about matrix structure for optimization.</p><p><strong>Options</strong>:</p><ul><li><code>:auto</code> - Automatic structure detection (default)</li><li><code>:hermitian</code> - Hermitian matrix (A† = A)</li><li><code>:symmetric</code> - Real symmetric (Aᵀ = A)</li><li><code>:unitary</code> - Unitary matrix (A† = A⁻¹)</li><li><code>:general</code> - No structure assumptions</li></ul><p><strong>Example</strong>:</p><pre><code class="language-julia hljs"># Tell solver that matrix is Hermitian
vals = eigvals(hermitian_mat, structure=:hermitian)</code></pre><p><strong>Notes</strong>:</p><ul><li>Providing correct hint can speed up computation</li><li>Incorrect hint may give wrong results</li><li><code>:auto</code> is safe but may be slower</li></ul><hr/><h3 id="expand::Bool"><a class="docs-heading-anchor" href="#expand::Bool"><code>expand::Bool</code></a><a id="expand::Bool-1"></a><a class="docs-heading-anchor-permalink" href="#expand::Bool" title="Permalink"></a></h3><p><strong>Default</strong>: <code>true</code></p><p>Whether to expand polynomial expressions.</p><p><strong>Options</strong>:</p><ul><li><code>true</code> - Expand products and powers</li><li><code>false</code> - Keep factored form when possible</li></ul><p><strong>Example</strong>:</p><pre><code class="language-julia hljs"># Factored form (if available)
vals = eigvals(mat, expand=false)</code></pre><p><strong>Use cases</strong>:</p><ul><li>Factored form may be simpler</li><li>Expanded form needed for numerical evaluation</li><li>Debugging expression structure</li></ul><hr/><h3 id="complexity_threshold::Int"><a class="docs-heading-anchor" href="#complexity_threshold::Int"><code>complexity_threshold::Int</code></a><a id="complexity_threshold::Int-1"></a><a class="docs-heading-anchor-permalink" href="#complexity_threshold::Int" title="Permalink"></a></h3><p><strong>Default</strong>: <code>5</code></p><p>Warn if matrix contains more than this many symbolic variables.</p><p><strong>Example</strong>:</p><pre><code class="language-julia hljs"># Suppress warning for 10-variable matrix
vals = eigvals(large_mat, complexity_threshold=10)</code></pre><p><strong>Purpose</strong>: Prevent accidentally running huge symbolic computations that may timeout or produce enormous expressions.</p><p><strong>Recommendation</strong>: </p><ul><li>Keep ≤ 5 for general matrices</li><li>Can increase for structured matrices</li><li>Set to <code>Inf</code> to disable warnings</li></ul><hr/><h3 id="timeout::Int"><a class="docs-heading-anchor" href="#timeout::Int"><code>timeout::Int</code></a><a id="timeout::Int-1"></a><a class="docs-heading-anchor-permalink" href="#timeout::Int" title="Permalink"></a></h3><p><strong>Default</strong>: <code>300</code> (5 minutes)</p><p>Maximum computation time in seconds.</p><p><strong>Example</strong>:</p><pre><code class="language-julia hljs"># Allow only 60 seconds
vals = eigvals(mat, timeout=60)</code></pre><p><strong>Throws</strong>: <code>ComputationTimeoutError</code> if exceeded</p><p><strong>Use cases</strong>:</p><ul><li>Prevent runaway computations</li><li>Testing with time limits</li><li>Interactive use with quick feedback</li></ul><hr/><h3 id="max_terms::Int"><a class="docs-heading-anchor" href="#max_terms::Int"><code>max_terms::Int</code></a><a id="max_terms::Int-1"></a><a class="docs-heading-anchor-permalink" href="#max_terms::Int" title="Permalink"></a></h3><p><strong>Default</strong>: <code>10000</code></p><p>Maximum number of terms allowed in symbolic expressions.</p><p><strong>Example</strong>:</p><pre><code class="language-julia hljs"># Allow more complex expressions
vals = eigvals(mat, max_terms=50000)</code></pre><p><strong>Throws</strong>: <code>ExpressionComplexityError</code> if exceeded</p><p><strong>Purpose</strong>: Prevent expression explosion (especially in quartic formula)</p><p><strong>Recommendation</strong>:</p><ul><li>Keep default for most cases</li><li>Increase for structured matrices</li><li>Watch memory usage if increasing</li></ul><hr/><h2 id="Exception-Types"><a class="docs-heading-anchor" href="#Exception-Types">Exception Types</a><a id="Exception-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Exception-Types" title="Permalink"></a></h2><h3 id="ExpressionComplexityError"><a class="docs-heading-anchor" href="#ExpressionComplexityError"><code>ExpressionComplexityError</code></a><a id="ExpressionComplexityError-1"></a><a class="docs-heading-anchor-permalink" href="#ExpressionComplexityError" title="Permalink"></a></h3><p>Thrown when symbolic expression exceeds complexity limit.</p><p><strong>Fields</strong>:</p><ul><li><code>msg::String</code> - Error message</li><li><code>terms::Int</code> - Number of terms encountered</li><li><code>limit::Int</code> - Configured limit</li></ul><p><strong>Example</strong>:</p><pre><code class="language-julia hljs">try
    vals = eigvals(huge_mat, max_terms=1000)
catch e
    if e isa ExpressionComplexityError
        println(&quot;Expression too complex: $(e.terms) terms (limit: $(e.limit))&quot;)
    end
end</code></pre><p><strong>Common causes</strong>:</p><ul><li>Fully symbolic 4×4 matrices (quartic formula)</li><li>Lack of detected structure</li><li>Nested radical expressions</li></ul><p><strong>Solutions</strong>:</p><ul><li>Add structure to matrix</li><li>Use partial numeric substitution</li><li>Increase <code>max_terms</code> (watch memory!)</li><li>Use numerical methods instead</li></ul><hr/><h3 id="ComputationTimeoutError"><a class="docs-heading-anchor" href="#ComputationTimeoutError"><code>ComputationTimeoutError</code></a><a id="ComputationTimeoutError-1"></a><a class="docs-heading-anchor-permalink" href="#ComputationTimeoutError" title="Permalink"></a></h3><p>Thrown when computation exceeds time limit.</p><p><strong>Fields</strong>:</p><ul><li><code>msg::String</code> - Error message</li><li><code>timeout::Int</code> - Configured timeout in seconds</li></ul><p><strong>Example</strong>:</p><pre><code class="language-julia hljs">try
    vals = eigvals(mat, timeout=30)
catch e
    if e isa ComputationTimeoutError
        println(&quot;Timed out after $(e.timeout) seconds&quot;)
    end
end</code></pre><p><strong>Common causes</strong>:</p><ul><li>Very large symbolic matrices</li><li>Complex expression simplification</li><li>Expensive structure detection</li></ul><p><strong>Solutions</strong>:</p><ul><li>Increase timeout</li><li>Simplify matrix structure</li><li>Use numerical methods</li><li>Pre-substitute some variables</li></ul><hr/><h2 id="Internal-API"><a class="docs-heading-anchor" href="#Internal-API">Internal API</a><a id="Internal-API-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-API" title="Permalink"></a></h2><p>These functions are not exported but may be useful for advanced users or contributors.</p><h3 id="Structure-Detection"><a class="docs-heading-anchor" href="#Structure-Detection">Structure Detection</a><a id="Structure-Detection-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-Detection" title="Permalink"></a></h3><h4 id="_detect_structure(mat)"><a class="docs-heading-anchor" href="#_detect_structure(mat)"><code>_detect_structure(mat)</code></a><a id="_detect_structure(mat)-1"></a><a class="docs-heading-anchor-permalink" href="#_detect_structure(mat)" title="Permalink"></a></h4><p>Automatically detects matrix structure (diagonal, triangular, block-diagonal, etc.)</p><h4 id="_is_diagonal(mat)"><a class="docs-heading-anchor" href="#_is_diagonal(mat)"><code>_is_diagonal(mat)</code></a><a id="_is_diagonal(mat)-1"></a><a class="docs-heading-anchor-permalink" href="#_is_diagonal(mat)" title="Permalink"></a></h4><p>Tests if matrix is diagonal</p><h4 id="_is_triangular(mat)"><a class="docs-heading-anchor" href="#_is_triangular(mat)"><code>_is_triangular(mat)</code></a><a id="_is_triangular(mat)-1"></a><a class="docs-heading-anchor-permalink" href="#_is_triangular(mat)" title="Permalink"></a></h4><p>Tests if matrix is upper or lower triangular</p><h4 id="_is_hermitian(mat)"><a class="docs-heading-anchor" href="#_is_hermitian(mat)"><code>_is_hermitian(mat)</code></a><a id="_is_hermitian(mat)-1"></a><a class="docs-heading-anchor-permalink" href="#_is_hermitian(mat)" title="Permalink"></a></h4><p>Tests if matrix is Hermitian (A† = A)</p><h4 id="_is_symmetric(mat)"><a class="docs-heading-anchor" href="#_is_symmetric(mat)"><code>_is_symmetric(mat)</code></a><a id="_is_symmetric(mat)-1"></a><a class="docs-heading-anchor-permalink" href="#_is_symmetric(mat)" title="Permalink"></a></h4><p>Tests if matrix is real symmetric</p><h4 id="_is_persymmetric(mat)"><a class="docs-heading-anchor" href="#_is_persymmetric(mat)"><code>_is_persymmetric(mat)</code></a><a id="_is_persymmetric(mat)-1"></a><a class="docs-heading-anchor-permalink" href="#_is_persymmetric(mat)" title="Permalink"></a></h4><p>Tests if matrix has persymmetric structure Q[i,j] = Q[n+1-j,n+1-i]</p><hr/><h3 id="Special-Pattern-Detectors"><a class="docs-heading-anchor" href="#Special-Pattern-Detectors">Special Pattern Detectors</a><a id="Special-Pattern-Detectors-1"></a><a class="docs-heading-anchor-permalink" href="#Special-Pattern-Detectors" title="Permalink"></a></h3><h4 id="_is_circulant(mat)"><a class="docs-heading-anchor" href="#_is_circulant(mat)"><code>_is_circulant(mat)</code></a><a id="_is_circulant(mat)-1"></a><a class="docs-heading-anchor-permalink" href="#_is_circulant(mat)" title="Permalink"></a></h4><p>Tests if matrix is circulant (each row cyclic shift of previous)</p><h4 id="_is_block_circulant(mat)"><a class="docs-heading-anchor" href="#_is_block_circulant(mat)"><code>_is_block_circulant(mat)</code></a><a id="_is_block_circulant(mat)-1"></a><a class="docs-heading-anchor-permalink" href="#_is_block_circulant(mat)" title="Permalink"></a></h4><p>Tests if matrix is block circulant, returns <code>(true, n_blocks, block_size, blocks)</code> or <code>(false, ...)</code></p><h4 id="_is_kronecker_product(mat)"><a class="docs-heading-anchor" href="#_is_kronecker_product(mat)"><code>_is_kronecker_product(mat)</code></a><a id="_is_kronecker_product(mat)-1"></a><a class="docs-heading-anchor-permalink" href="#_is_kronecker_product(mat)" title="Permalink"></a></h4><p>Tests if matrix is Kronecker product, returns <code>(true, A, B, m, n)</code> or <code>(false, ...)</code></p><h4 id="_is_toeplitz_tridiagonal(mat)"><a class="docs-heading-anchor" href="#_is_toeplitz_tridiagonal(mat)"><code>_is_toeplitz_tridiagonal(mat)</code></a><a id="_is_toeplitz_tridiagonal(mat)-1"></a><a class="docs-heading-anchor-permalink" href="#_is_toeplitz_tridiagonal(mat)" title="Permalink"></a></h4><p>Tests if matrix is symmetric Toeplitz tridiagonal</p><h4 id="_is_antidiagonal(mat)"><a class="docs-heading-anchor" href="#_is_antidiagonal(mat)"><code>_is_antidiagonal(mat)</code></a><a id="_is_antidiagonal(mat)-1"></a><a class="docs-heading-anchor-permalink" href="#_is_antidiagonal(mat)" title="Permalink"></a></h4><p>Tests if matrix is symmetric anti-diagonal</p><h4 id="_is_permutation_matrix(mat)"><a class="docs-heading-anchor" href="#_is_permutation_matrix(mat)"><code>_is_permutation_matrix(mat)</code></a><a id="_is_permutation_matrix(mat)-1"></a><a class="docs-heading-anchor-permalink" href="#_is_permutation_matrix(mat)" title="Permalink"></a></h4><p>Tests if matrix is a permutation matrix</p><h4 id="_detect_special_5x5_tridiagonal(mat)"><a class="docs-heading-anchor" href="#_detect_special_5x5_tridiagonal(mat)"><code>_detect_special_5x5_tridiagonal(mat)</code></a><a id="_detect_special_5x5_tridiagonal(mat)-1"></a><a class="docs-heading-anchor-permalink" href="#_detect_special_5x5_tridiagonal(mat)" title="Permalink"></a></h4><p>Tests for special 5×5 patterns with known eigenvalues</p><hr/><h3 id="Special-Pattern-Solvers"><a class="docs-heading-anchor" href="#Special-Pattern-Solvers">Special Pattern Solvers</a><a id="Special-Pattern-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Special-Pattern-Solvers" title="Permalink"></a></h3><h4 id="_circulant_eigenvalues(mat)"><a class="docs-heading-anchor" href="#_circulant_eigenvalues(mat)"><code>_circulant_eigenvalues(mat)</code></a><a id="_circulant_eigenvalues(mat)-1"></a><a class="docs-heading-anchor-permalink" href="#_circulant_eigenvalues(mat)" title="Permalink"></a></h4><p>Computes eigenvalues of circulant matrix using DFT</p><h4 id="_block_circulant_eigenvalues(mat,-n_blocks,-block_size,-blocks;-...)"><a class="docs-heading-anchor" href="#_block_circulant_eigenvalues(mat,-n_blocks,-block_size,-blocks;-...)"><code>_block_circulant_eigenvalues(mat, n_blocks, block_size, blocks; ...)</code></a><a id="_block_circulant_eigenvalues(mat,-n_blocks,-block_size,-blocks;-...)-1"></a><a class="docs-heading-anchor-permalink" href="#_block_circulant_eigenvalues(mat,-n_blocks,-block_size,-blocks;-...)" title="Permalink"></a></h4><p>Computes eigenvalues of block circulant matrix</p><h4 id="_kronecker_eigenvalues(A,-B,-m,-n;-...)"><a class="docs-heading-anchor" href="#_kronecker_eigenvalues(A,-B,-m,-n;-...)"><code>_kronecker_eigenvalues(A, B, m, n; ...)</code></a><a id="_kronecker_eigenvalues(A,-B,-m,-n;-...)-1"></a><a class="docs-heading-anchor-permalink" href="#_kronecker_eigenvalues(A,-B,-m,-n;-...)" title="Permalink"></a></h4><p>Computes eigenvalues of Kronecker product A ⊗ B</p><h4 id="_toeplitz_tridiagonal_eigenvalues(n,-a,-b,-c)"><a class="docs-heading-anchor" href="#_toeplitz_tridiagonal_eigenvalues(n,-a,-b,-c)"><code>_toeplitz_tridiagonal_eigenvalues(n, a, b, c)</code></a><a id="_toeplitz_tridiagonal_eigenvalues(n,-a,-b,-c)-1"></a><a class="docs-heading-anchor-permalink" href="#_toeplitz_tridiagonal_eigenvalues(n,-a,-b,-c)" title="Permalink"></a></h4><p>Computes eigenvalues of symmetric Toeplitz tridiagonal</p><h4 id="_antidiagonal_eigenvalues(mat)"><a class="docs-heading-anchor" href="#_antidiagonal_eigenvalues(mat)"><code>_antidiagonal_eigenvalues(mat)</code></a><a id="_antidiagonal_eigenvalues(mat)-1"></a><a class="docs-heading-anchor-permalink" href="#_antidiagonal_eigenvalues(mat)" title="Permalink"></a></h4><p>Computes eigenvalues of symmetric anti-diagonal matrix</p><h4 id="_compute_permutation_eigenvalues(A)"><a class="docs-heading-anchor" href="#_compute_permutation_eigenvalues(A)"><code>_compute_permutation_eigenvalues(A)</code></a><a id="_compute_permutation_eigenvalues(A)-1"></a><a class="docs-heading-anchor-permalink" href="#_compute_permutation_eigenvalues(A)" title="Permalink"></a></h4><p>Computes eigenvalues of permutation matrix via cycle decomposition</p><hr/><h3 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h3><h4 id="_block_split(mat)"><a class="docs-heading-anchor" href="#_block_split(mat)"><code>_block_split(mat)</code></a><a id="_block_split(mat)-1"></a><a class="docs-heading-anchor-permalink" href="#_block_split(mat)" title="Permalink"></a></h4><p>Detects and splits block-diagonal structure</p><h4 id="_persymmetric_split(mat)"><a class="docs-heading-anchor" href="#_persymmetric_split(mat)"><code>_persymmetric_split(mat)</code></a><a id="_persymmetric_split(mat)-1"></a><a class="docs-heading-anchor-permalink" href="#_persymmetric_split(mat)" title="Permalink"></a></h4><p>Splits persymmetric matrix into half-sized problems</p><h4 id="_count_symbolic_vars(A)"><a class="docs-heading-anchor" href="#_count_symbolic_vars(A)"><code>_count_symbolic_vars(A)</code></a><a id="_count_symbolic_vars(A)-1"></a><a class="docs-heading-anchor-permalink" href="#_count_symbolic_vars(A)" title="Permalink"></a></h4><p>Counts number of unique symbolic variables in matrix</p><h4 id="_check_complexity(A;-threshold,-quiet)"><a class="docs-heading-anchor" href="#_check_complexity(A;-threshold,-quiet)"><code>_check_complexity(A; threshold, quiet)</code></a><a id="_check_complexity(A;-threshold,-quiet)-1"></a><a class="docs-heading-anchor-permalink" href="#_check_complexity(A;-threshold,-quiet)" title="Permalink"></a></h4><p>Checks if matrix exceeds complexity threshold, optionally warns</p><hr/><h2 id="Usage-Examples"><a class="docs-heading-anchor" href="#Usage-Examples">Usage Examples</a><a id="Usage-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-Examples" title="Permalink"></a></h2><h3 id="Example-1:-Basic-Eigenvalues"><a class="docs-heading-anchor" href="#Example-1:-Basic-Eigenvalues">Example 1: Basic Eigenvalues</a><a id="Example-1:-Basic-Eigenvalues-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Basic-Eigenvalues" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Symbolics, SymbolicDiagonalization, LinearAlgebra

@variables a b c
mat = [a 0 0; 0 b 0; 0 0 c]

λ = eigvals(mat)  # [a, b, c]</code></pre><h3 id="Example-2:-With-Structure-Hint"><a class="docs-heading-anchor" href="#Example-2:-With-Structure-Hint">Example 2: With Structure Hint</a><a id="Example-2:-With-Structure-Hint-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-With-Structure-Hint" title="Permalink"></a></h3><pre><code class="language-julia hljs">@variables a b
H = [a b; conj(b) a]  # Hermitian

E = eigen(H, structure=:hermitian)</code></pre><h3 id="Example-3:-Error-Handling"><a class="docs-heading-anchor" href="#Example-3:-Error-Handling">Example 3: Error Handling</a><a id="Example-3:-Error-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-Error-Handling" title="Permalink"></a></h3><pre><code class="language-julia hljs">@variables a b c d e
mat = [a b c d e;
       b a c d e;
       c c a d e;
       d d d a e;
       e e e e a]

try
    λ = eigvals(mat, timeout=60, max_terms=5000)
catch e
    if e isa ComputationTimeoutError
        println(&quot;Computation timed out&quot;)
    elseif e isa ExpressionComplexityError
        println(&quot;Expression too complex&quot;)
    else
        rethrow(e)
    end
end</code></pre><h3 id="Example-4:-Characteristic-Polynomial"><a class="docs-heading-anchor" href="#Example-4:-Characteristic-Polynomial">Example 4: Characteristic Polynomial</a><a id="Example-4:-Characteristic-Polynomial-1"></a><a class="docs-heading-anchor-permalink" href="#Example-4:-Characteristic-Polynomial" title="Permalink"></a></h3><pre><code class="language-julia hljs">@variables a b
mat = [a b; b a]

poly, coeffs, λ = characteristic_polynomial(mat)
# poly = λ² - 2a·λ + (a² - b²)

# Now solve manually if desired
roots = symbolic_roots(poly, λ)</code></pre><h3 id="Example-5:-Full-Diagonalization"><a class="docs-heading-anchor" href="#Example-5:-Full-Diagonalization">Example 5: Full Diagonalization</a><a id="Example-5:-Full-Diagonalization-1"></a><a class="docs-heading-anchor-permalink" href="#Example-5:-Full-Diagonalization" title="Permalink"></a></h3><pre><code class="language-julia hljs">@variables a b
mat = [a b; b a]

P, D, pairs = symbolic_diagonalize(mat)

# Verify: mat ≈ P * D * inv(P)
# P contains eigenvectors as columns
# D is diagonal with eigenvalues</code></pre><hr/><h2 id="See-Also"><a class="docs-heading-anchor" href="#See-Also">See Also</a><a id="See-Also-1"></a><a class="docs-heading-anchor-permalink" href="#See-Also" title="Permalink"></a></h2><ul><li><a href="../user_guide/">User Guide</a> - Practical examples and workflows</li><li><a href="../pattern_library/">Pattern Library</a> - Special patterns and their eigenvalues</li><li><a href="../implementation/">Implementation</a> - Algorithm details</li><li><a href="../mathematical_background/">Mathematical Background</a> - Theory and proofs</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../user_guide/">« User Guide</a><a class="docs-footer-nextpage" href="../pattern_library/">Pattern Library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 11 December 2025 18:46">Thursday 11 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

# ============================================================================
# Finite Groups: Coxeter and Weyl Groups (Reflection Groups)
# ============================================================================
#
# Coxeter groups are generated by reflections and have beautiful eigenvalue
# structure due to their root system organization.
#
# Key types implemented:
#
# 1. CARTAN MATRICES (Weyl groups)
#    The Cartan matrix encodes the root system structure. For simply-laced
#    types (ADE), the Cartan matrix is 2I - A where A is the adjacency matrix
#    of the Dynkin diagram.
#    
#    Type Aₙ: Dynkin diagram is a path graph → tridiagonal Cartan matrix
#    Type Dₙ: Branching at one end
#    Type Eₙ: Exceptional types E₆, E₇, E₈
#
# 2. COXETER MATRICES
#    The Coxeter matrix M has entries m_{ij} where (s_i s_j)^{m_{ij}} = 1.
#    For Weyl groups: m_{ij} ∈ {1, 2, 3, 4, 6}
#
# 3. REFLECTION MATRICES
#    Individual reflections s_i have eigenvalues {1, 1, ..., 1, -1}.
#    Products of reflections (Coxeter elements) have eigenvalues e^{2πi·mⱼ/h}
#    where h is the Coxeter number and mⱼ are the exponents.
#
# Eigenvalue formulas:
#   - Cartan matrix of type Aₙ: λₖ = 2 - 2cos(πk/(n+1)) = 4sin²(πk/2(n+1))
#   - Coxeter element: eigenvalues are e^{2πi·mⱼ/h} for exponents mⱼ
#
# ============================================================================

# ============================================================================
# Cartan Matrices (Type A, D, E)
# ============================================================================

"""
    _cartan_matrix_A(n)

Return the Cartan matrix of type Aₙ (n×n matrix).

The Cartan matrix of type Aₙ is tridiagonal:
```
[ 2 -1  0  ...  0  0]
[-1  2 -1  ...  0  0]
[ 0 -1  2  ...  0  0]
[...            ...]
[ 0  0  0  ... -1  2]
```

This corresponds to the root system of SL(n+1) / SU(n+1).
"""
function _cartan_matrix_A(n::Int)
    C = zeros(Int, n, n)
    for i in 1:n
        C[i, i] = 2
        if i > 1
            C[i, i-1] = -1
        end
        if i < n
            C[i, i+1] = -1
        end
    end
    return C
end

"""
    _cartan_matrix_B(n)

Return the Cartan matrix of type Bₙ (n×n matrix, n ≥ 2).

Type Bₙ corresponds to SO(2n+1). The Dynkin diagram has a double bond
at one end (short root → long root):
```
○=>=○-○-...-○
1   2 3     n
```

The Cartan matrix has C[1,2] = -2 and C[2,1] = -1 (asymmetric bond).
"""
function _cartan_matrix_B(n::Int)
    n >= 2 || error("Type B requires n ≥ 2")
    
    C = zeros(Int, n, n)
    
    # Diagonal entries are all 2
    for i in 1:n
        C[i, i] = 2
    end
    
    # Chain with single bonds from 2 to n
    for i in 2:n-1
        C[i, i+1] = -1
        C[i+1, i] = -1
    end
    
    # Double bond between 1 and 2 (asymmetric)
    C[1, 2] = -2  # Short root sees long root with factor 2
    C[2, 1] = -1  # Long root sees short root with factor 1
    
    return C
end

"""
    _cartan_matrix_C(n)

Return the Cartan matrix of type Cₙ (n×n matrix, n ≥ 2).

Type Cₙ corresponds to Sp(2n). The Dynkin diagram has a double bond
at one end (long root → short root):
```
○-○-...-○=<=○
1 2     n-1 n
```

The Cartan matrix has C[n-1,n] = -1 and C[n,n-1] = -2 (asymmetric bond).
"""
function _cartan_matrix_C(n::Int)
    n >= 2 || error("Type C requires n ≥ 2")
    
    C = zeros(Int, n, n)
    
    # Diagonal entries are all 2
    for i in 1:n
        C[i, i] = 2
    end
    
    # Chain with single bonds from 1 to n-1
    for i in 1:n-2
        C[i, i+1] = -1
        C[i+1, i] = -1
    end
    
    # Double bond between n-1 and n (asymmetric)
    C[n-1, n] = -1  # Long root sees short root with factor 1
    C[n, n-1] = -2  # Short root sees long root with factor 2
    
    return C
end

"""
    _cartan_matrix_D(n)

Return the Cartan matrix of type Dₙ (n×n matrix, n ≥ 4).

The Dynkin diagram of Dₙ is a path with a fork at one end:
```
    ○ (n-1)
   /
○-○-○-...-○
1 2 3    n-2 \\
              ○ (n)
```

The Cartan matrix has the Aₙ₋₂ pattern plus connections to two end nodes.
"""
function _cartan_matrix_D(n::Int)
    n >= 4 || error("Type D requires n ≥ 4")
    
    C = zeros(Int, n, n)
    
    # Diagonal entries are all 2
    for i in 1:n
        C[i, i] = 2
    end
    
    # Chain from 1 to n-2 (type Aₙ₋₂ pattern)
    for i in 1:n-3
        C[i, i+1] = -1
        C[i+1, i] = -1
    end
    
    # Fork: node n-2 connects to both n-1 and n
    C[n-2, n-1] = -1
    C[n-1, n-2] = -1
    C[n-2, n] = -1
    C[n, n-2] = -1
    
    return C
end

"""
    _cartan_matrix_E(n)

Return the Cartan matrix of type Eₙ (n ∈ {6, 7, 8}).

The Dynkin diagram of Eₙ has a chain with one branch:
```
        ○ (branch node)
        |
○-○-○-○-○-○-...
1 2 3 4 5 6 ...
```

For E₆: 6 nodes, branch at node 3
For E₇: 7 nodes, branch at node 3  
For E₈: 8 nodes, branch at node 3
"""
function _cartan_matrix_E(n::Int)
    n in (6, 7, 8) || error("Type E requires n ∈ {6, 7, 8}")
    
    C = zeros(Int, n, n)
    
    # Diagonal entries are all 2
    for i in 1:n
        C[i, i] = 2
    end
    
    # Main chain: 1-2-3-4-5-... 
    # For E₆: chain is 1-2-3-4-5, with 6 branching from 3
    # For E₇: chain is 1-2-3-4-5-6, with 7 branching from 3
    # For E₈: chain is 1-2-3-4-5-6-7, with 8 branching from 3
    
    for i in 1:n-2
        C[i, i+1] = -1
        C[i+1, i] = -1
    end
    
    # Remove the connection that would make it Aₙ₋₁
    # and add the branch from node 3 to node n
    if n >= 6
        # Remove edge between n-1 and n (we'll connect n to the branch point)
        C[n-1, n] = 0
        C[n, n-1] = 0
        
        # Branch: node 3 connects to node n
        C[3, n] = -1
        C[n, 3] = -1
    end
    
    return C
end

"""
    _cartan_matrix_F4()

Return the Cartan matrix of type F₄ (4×4 matrix).

The Dynkin diagram of F₄ has a double bond in the middle:
```
○-○=>=○-○
1 2   3 4
```

F₄ is the automorphism group of the exceptional Jordan algebra.
"""
function _cartan_matrix_F4()
    C = [
         2  -1   0   0;
        -1   2  -2   0;
         0  -1   2  -1;
         0   0  -1   2
    ]
    return C
end

"""
    _cartan_matrix_G2()

Return the Cartan matrix of type G₂ (2×2 matrix).

The Dynkin diagram of G₂ has a triple bond:
```
○≡>○
1  2
```

G₂ is the automorphism group of the octonions.
"""
function _cartan_matrix_G2()
    C = [
         2  -3;
        -1   2
    ]
    return C
end

"""
    _is_cartan_matrix_A(mat)

Check if a matrix is a Cartan matrix of type Aₙ.

Type Aₙ Cartan matrix is characterized by:
- Symmetric tridiagonal
- Diagonal entries = 2
- Off-diagonal entries = -1
- No other non-zero entries

Returns n if it's type Aₙ, `nothing` otherwise.
"""
function _is_cartan_matrix_A(mat)
    n = size(mat, 1)
    n == size(mat, 2) || return nothing
    n >= 1 || return nothing
    
    for i in 1:n
        for j in 1:n
            expected = if i == j
                2
            elseif abs(i - j) == 1
                -1
            else
                0
            end
            if !_issymzero(mat[i, j] - expected)
                return nothing
            end
        end
    end
    
    return n
end

"""
    _is_cartan_matrix_B(mat)

Check if a matrix is a Cartan matrix of type Bₙ (n ≥ 2).

Returns n if it's type Bₙ, `nothing` otherwise.
"""
function _is_cartan_matrix_B(mat)
    n = size(mat, 1)
    n == size(mat, 2) || return nothing
    n >= 2 || return nothing
    
    expected = _cartan_matrix_B(n)
    
    for i in 1:n
        for j in 1:n
            if !_issymzero(mat[i, j] - expected[i, j])
                return nothing
            end
        end
    end
    
    return n
end

"""
    _is_cartan_matrix_C(mat)

Check if a matrix is a Cartan matrix of type Cₙ (n ≥ 2).

Returns n if it's type Cₙ, `nothing` otherwise.
"""
function _is_cartan_matrix_C(mat)
    n = size(mat, 1)
    n == size(mat, 2) || return nothing
    n >= 2 || return nothing
    
    expected = _cartan_matrix_C(n)
    
    for i in 1:n
        for j in 1:n
            if !_issymzero(mat[i, j] - expected[i, j])
                return nothing
            end
        end
    end
    
    return n
end

"""
    _is_cartan_matrix_F4(mat)

Check if a matrix is the Cartan matrix of type F₄.

Returns 4 if it's F₄, `nothing` otherwise.
"""
function _is_cartan_matrix_F4(mat)
    size(mat) == (4, 4) || return nothing
    
    expected = _cartan_matrix_F4()
    
    for i in 1:4
        for j in 1:4
            if !_issymzero(mat[i, j] - expected[i, j])
                return nothing
            end
        end
    end
    
    return 4
end

"""
    _is_cartan_matrix_G2(mat)

Check if a matrix is the Cartan matrix of type G₂.

Returns 2 if it's G₂, `nothing` otherwise.
"""
function _is_cartan_matrix_G2(mat)
    size(mat) == (2, 2) || return nothing
    
    expected = _cartan_matrix_G2()
    
    for i in 1:2
        for j in 1:2
            if !_issymzero(mat[i, j] - expected[i, j])
                return nothing
            end
        end
    end
    
    return 2
end

"""
    _is_cartan_matrix_D(mat)

Check if a matrix is a Cartan matrix of type Dₙ (n ≥ 4).

Type Dₙ Cartan matrix has the forked structure.

Returns n if it's type Dₙ, `nothing` otherwise.
"""
function _is_cartan_matrix_D(mat)
    n = size(mat, 1)
    n == size(mat, 2) || return nothing
    n >= 4 || return nothing
    
    expected = _cartan_matrix_D(n)
    
    for i in 1:n
        for j in 1:n
            if !_issymzero(mat[i, j] - expected[i, j])
                return nothing
            end
        end
    end
    
    return n
end

"""
    _is_cartan_matrix_E(mat)

Check if a matrix is a Cartan matrix of type Eₙ (n ∈ {6, 7, 8}).

Returns n if it's type Eₙ, `nothing` otherwise.
"""
function _is_cartan_matrix_E(mat)
    n = size(mat, 1)
    n == size(mat, 2) || return nothing
    n in (6, 7, 8) || return nothing
    
    expected = _cartan_matrix_E(n)
    
    for i in 1:n
        for j in 1:n
            if !_issymzero(mat[i, j] - expected[i, j])
                return nothing
            end
        end
    end
    
    return n
end

"""
    _cartan_eigenvalues_A(n)

Compute symbolic eigenvalues of the type Aₙ Cartan matrix.

The eigenvalues are:
    λₖ = 4·sin²(πk / 2(n+1)) = 2 - 2·cos(πk / (n+1))

for k = 1, 2, ..., n.

These are all positive (Cartan matrices are positive definite for finite types).
"""
function _cartan_eigenvalues_A(n::Int)
    eigenvalues = Vector{Any}(undef, n)
    
    for k in 1:n
        # λₖ = 4·sin²(πk / 2(n+1)) = 2 - 2·cos(πk/(n+1))
        # Keep symbolic: use Symbolics.Num to prevent π from being evaluated
        angle = Symbolics.Num(k) * Symbolics.Num(π) / Symbolics.Num(n + 1)
        λ = 2 - 2 * cos(angle)
        eigenvalues[k] = λ
    end
    
    return eigenvalues
end

"""
    _cartan_eigenvalues_G2()

Compute symbolic eigenvalues of the type G₂ Cartan matrix.

G₂ eigenvalues: 2 ± √3 (from characteristic polynomial λ² - 4λ + 1 = 0).

This is one of the few Cartan matrices with a simple closed-form formula.
"""
function _cartan_eigenvalues_G2()
    # Exact closed form: eigenvalues of [2 -3; -1 2]
    # det(λI - C) = (λ-2)² - 3 = λ² - 4λ + 1
    # λ = 2 ± √3
    return [2 - sqrt(3), 2 + sqrt(3)]
end

# ============================================================================
# Coxeter Elements and Exponents
# ============================================================================

"""
    _coxeter_number(type, n)

Return the Coxeter number h for the given type.

The Coxeter number is the order of a Coxeter element.

| Type | Coxeter number h |
|------|-----------------|
| Aₙ   | n + 1           |
| Bₙ   | 2n              |
| Cₙ   | 2n              |
| Dₙ   | 2(n-1)          |
| E₆   | 12              |
| E₇   | 18              |
| E₈   | 30              |
| F₄   | 12              |
| G₂   | 6               |
"""
function _coxeter_number(type::Symbol, n::Int)
    if type == :A
        return n + 1
    elseif type == :B || type == :C
        return 2n
    elseif type == :D
        return 2(n - 1)
    elseif type == :E
        n == 6 && return 12
        n == 7 && return 18
        n == 8 && return 30
        error("E type requires n ∈ {6, 7, 8}")
    elseif type == :F
        n == 4 || error("F type requires n = 4")
        return 12
    elseif type == :G
        n == 2 || error("G type requires n = 2")
        return 6
    else
        error("Unknown Coxeter type: $type")
    end
end

"""
    _coxeter_exponents(type, n)

Return the exponents for the given Coxeter group type.

The exponents m₁, m₂, ..., mₙ determine the degrees of fundamental invariants
(degrees are mⱼ + 1) and the eigenvalues of a Coxeter element (e^{2πi·mⱼ/h}).

| Type | Exponents                    |
|------|------------------------------|
| Aₙ   | 1, 2, 3, ..., n              |
| Bₙ   | 1, 3, 5, ..., 2n-1           |
| Cₙ   | 1, 3, 5, ..., 2n-1           |
| Dₙ   | 1, 3, 5, ..., 2n-3, n-1      |
| E₆   | 1, 4, 5, 7, 8, 11            |
| E₇   | 1, 5, 7, 9, 11, 13, 17       |
| E₈   | 1, 7, 11, 13, 17, 19, 23, 29 |
| F₄   | 1, 5, 7, 11                  |
| G₂   | 1, 5                         |
"""
function _coxeter_exponents(type::Symbol, n::Int)
    if type == :A
        return collect(1:n)
    elseif type == :B || type == :C
        return collect(1:2:2n-1)  # 1, 3, 5, ..., 2n-1
    elseif type == :D
        # 1, 3, 5, ..., 2n-3, n-1
        exps = collect(1:2:2n-3)
        push!(exps, n - 1)
        return sort(exps)
    elseif type == :E
        n == 6 && return [1, 4, 5, 7, 8, 11]
        n == 7 && return [1, 5, 7, 9, 11, 13, 17]
        n == 8 && return [1, 7, 11, 13, 17, 19, 23, 29]
        error("E type requires n ∈ {6, 7, 8}")
    elseif type == :F
        n == 4 || error("F type requires n = 4")
        return [1, 5, 7, 11]
    elseif type == :G
        n == 2 || error("G type requires n = 2")
        return [1, 5]
    else
        error("Unknown Coxeter type: $type")
    end
end

"""
    _coxeter_element_eigenvalues(type, n)

Compute eigenvalues of a Coxeter element for the given type.

A Coxeter element is a product of all simple reflections (one for each node
of the Dynkin diagram) in some order. All Coxeter elements are conjugate,
so their eigenvalues are the same.

Eigenvalues: e^{2πi·mⱼ/h} for j = 1, ..., n

where mⱼ are the exponents and h is the Coxeter number.
"""
function _coxeter_element_eigenvalues(type::Symbol, n::Int)
    h = _coxeter_number(type, n)
    exponents = _coxeter_exponents(type, n)
    
    eigenvalues = Vector{ComplexF64}(undef, n)
    for (j, m) in enumerate(exponents)
        θ = 2π * m / h
        eigenvalues[j] = cos(θ) + im * sin(θ)
    end
    
    return eigenvalues
end

# ============================================================================
# Reflection Matrices
# ============================================================================

"""
    _is_reflection_matrix(mat)

Check if a matrix is a reflection (orthogonal with determinant -1).

A reflection in ℝⁿ has eigenvalues {1, 1, ..., 1, -1} (n-1 ones and one -1).

Returns `true` if mat is a reflection matrix.
"""
function _is_reflection_matrix(mat)
    n = size(mat, 1)
    n == size(mat, 2) || return false
    
    # Check orthogonality: M^T M = I
    if !all(_issymzero, mat' * mat - I(n))
        return false
    end
    
    # Check determinant = -1
    d = det(mat)
    if !_issymzero(d + 1)
        return false
    end
    
    return true
end

"""
    _reflection_eigenvalues(n)

Return eigenvalues of a reflection matrix in dimension n.

A reflection has n-1 eigenvalues equal to 1 and one eigenvalue equal to -1.
"""
function _reflection_eigenvalues(n::Int)
    eigenvalues = ones(Int, n)
    eigenvalues[n] = -1
    return eigenvalues
end

"""
    _householder_reflection(v)

Construct a Householder reflection matrix for vector v.

The Householder matrix is:
    H = I - 2·v·vᵀ / (vᵀ·v)

This reflects vectors across the hyperplane perpendicular to v.
"""
function _householder_reflection(v)
    n = length(v)
    v_normalized = v / sqrt(sum(v .^ 2))
    H = Matrix{eltype(v)}(I, n, n) - 2 * v_normalized * v_normalized'
    return H
end

# ============================================================================
# Weyl Group Detection (via Cartan matrix structure)
# ============================================================================

"""
    _detect_cartan_type_symbolic(mat)

Detect if a matrix is a Cartan matrix with a closed-form symbolic eigenvalue formula.

Only types A and G₂ have simple closed-form eigenvalue formulas:
- Type Aₙ: λₖ = 2 - 2·cos(πk/(n+1))
- Type G₂: λ = 2 ± √3

Returns (type, n) where type ∈ {:A, :G} and n is the rank,
or `nothing` if not a Cartan matrix with symbolic support.

Note: Other Cartan types (B, C, D, E, F₄) exist but their eigenvalues
require solving higher-degree polynomials without simple closed forms.
Use the matrix constructors (cartan_matrix_B, etc.) if you need them.
"""
function _detect_cartan_type_symbolic(mat)
    n = size(mat, 1)
    n == size(mat, 2) || return nothing
    
    # Type G₂ (2×2): λ = 2 ± √3
    if n == 2 && !isnothing(_is_cartan_matrix_G2(mat))
        return (:G, 2)
    end
    
    # Type Aₙ: λₖ = 2 - 2·cos(πk/(n+1))
    if !isnothing(_is_cartan_matrix_A(mat))
        return (:A, n)
    end
    
    return nothing
end

"""
    _detect_cartan_type(mat)

Detect if a matrix is a Cartan matrix and return its type.

Returns (type, n) where type ∈ {:A, :B, :C, :D, :E, :F, :G} and n is the rank,
or `nothing` if not a Cartan matrix of a recognized type.

Note: This detects all Cartan types, but only types A and G₂ have
symbolic eigenvalue formulas. Use `_detect_cartan_type_symbolic` for
automatic diagonalization.
"""
function _detect_cartan_type(mat)
    n = size(mat, 1)
    n == size(mat, 2) || return nothing
    
    # Check fixed-size exceptional types first
    if n == 2 && !isnothing(_is_cartan_matrix_G2(mat))
        return (:G, 2)
    end
    
    if n == 4 && !isnothing(_is_cartan_matrix_F4(mat))
        return (:F, 4)
    end
    
    # Check type A (most common simply-laced)
    if !isnothing(_is_cartan_matrix_A(mat))
        return (:A, n)
    end
    
    # Check type B (non-simply-laced, SO(2n+1))
    if n >= 2 && !isnothing(_is_cartan_matrix_B(mat))
        return (:B, n)
    end
    
    # Check type C (non-simply-laced, Sp(2n))
    if n >= 2 && !isnothing(_is_cartan_matrix_C(mat))
        return (:C, n)
    end
    
    # Check type D (simply-laced, SO(2n))
    if n >= 4 && !isnothing(_is_cartan_matrix_D(mat))
        return (:D, n)
    end
    
    # Check type E (exceptional simply-laced)
    if n in (6, 7, 8) && !isnothing(_is_cartan_matrix_E(mat))
        return (:E, n)
    end
    
    return nothing
end

"""
    _cartan_eigenvalues(type, n)

Compute symbolic eigenvalues for a Cartan matrix of the given type.

Only types A and G₂ are supported (they have closed-form formulas).
"""
function _cartan_eigenvalues(type::Symbol, n::Int)
    if type == :A
        return _cartan_eigenvalues_A(n)
    elseif type == :G
        return _cartan_eigenvalues_G2()
    else
        error("No symbolic eigenvalue formula for Cartan type $type. " *
              "Only types A and G₂ have closed-form solutions.")
    end
end

# ============================================================================
# Graph Laplacians (related to Coxeter groups)
# ============================================================================

"""
    _is_path_laplacian(mat)

Check if a matrix is the Laplacian of a path graph Pₙ.

The path Laplacian is tridiagonal with:
- Diagonal: [1, 2, 2, ..., 2, 1] (degree of each vertex)
- Off-diagonal: -1

This is related to the type Aₙ₋₁ Cartan matrix.

Returns n (number of vertices) if it's a path Laplacian, `nothing` otherwise.
"""
function _is_path_laplacian(mat)
    n = size(mat, 1)
    n == size(mat, 2) || return nothing
    n >= 2 || return nothing
    
    for i in 1:n
        for j in 1:n
            if i == j
                # Degree: 1 for endpoints, 2 for interior
                expected = (i == 1 || i == n) ? 1 : 2
            elseif abs(i - j) == 1
                expected = -1
            else
                expected = 0
            end
            
            if !_issymzero(mat[i, j] - expected)
                return nothing
            end
        end
    end
    
    return n
end

"""
    _path_laplacian_eigenvalues(n)

Compute eigenvalues of the path graph Pₙ Laplacian.

Eigenvalues: λₖ = 2 - 2·cos(πk/n) = 4·sin²(πk/2n) for k = 0, 1, ..., n-1

Note: λ₀ = 0 (constant eigenvector).
"""
function _path_laplacian_eigenvalues(n::Int)
    eigenvalues = Vector{Any}(undef, n)
    
    for k in 0:n-1
        # λₖ = 2 - 2·cos(πk/n)
        # Keep symbolic: use Symbolics.Num to prevent π from being evaluated
        if k == 0
            eigenvalues[k + 1] = 0  # Exact zero for k=0
        else
            angle = Symbolics.Num(k) * Symbolics.Num(π) / Symbolics.Num(n)
            eigenvalues[k + 1] = 2 - 2 * cos(angle)
        end
    end
    
    return eigenvalues
end

"""
    _is_cycle_laplacian(mat)

Check if a matrix is the Laplacian of a cycle graph Cₙ.

The cycle Laplacian is circulant with first row [2, -1, 0, ..., 0, -1].

Returns n if it's a cycle Laplacian, `nothing` otherwise.
"""
function _is_cycle_laplacian(mat)
    n = size(mat, 1)
    n == size(mat, 2) || return nothing
    n >= 3 || return nothing
    
    for i in 1:n
        for j in 1:n
            diff = mod(abs(i - j), n)
            diff = min(diff, n - diff)  # Distance on cycle
            
            if diff == 0
                expected = 2
            elseif diff == 1
                expected = -1
            else
                expected = 0
            end
            
            if !_issymzero(mat[i, j] - expected)
                return nothing
            end
        end
    end
    
    return n
end

"""
    _cycle_laplacian_eigenvalues(n)

Compute eigenvalues of the cycle graph Cₙ Laplacian.

Eigenvalues: λₖ = 2 - 2·cos(2πk/n) = 4·sin²(πk/n) for k = 0, 1, ..., n-1

Note: λ₀ = 0 (constant eigenvector).
"""
function _cycle_laplacian_eigenvalues(n::Int)
    eigenvalues = Vector{Any}(undef, n)
    
    for k in 0:n-1
        # λₖ = 2 - 2·cos(2πk/n)
        # Keep symbolic: use Symbolics.Num to prevent π from being evaluated
        if k == 0
            eigenvalues[k + 1] = 0  # Exact zero for k=0
        else
            angle = Symbolics.Num(2) * Symbolics.Num(k) * Symbolics.Num(π) / Symbolics.Num(n)
            eigenvalues[k + 1] = 2 - 2 * cos(angle)
        end
    end
    
    return eigenvalues
end

# ============================================================================
# Symbolic Eigenvalue Functions for Cartan Matrices
# ============================================================================

"""
    _cartan_eigenvalues_A_symbolic(n)

Compute symbolic eigenvalues of type Aₙ Cartan matrix.

Returns expressions in terms of cos(πk/(n+1)).
"""
function _cartan_eigenvalues_A_symbolic(n::Int)
    eigenvalues = Vector{Any}(undef, n)
    
    for k in 1:n
        # λₖ = 2 - 2·cos(πk/(n+1))
        # For small n, use exact values
        if n == 1
            eigenvalues[1] = 2  # cos(π/2) = 0
        elseif n == 2
            # cos(π/3) = 1/2, cos(2π/3) = -1/2
            eigenvalues[1] = 1  # 2 - 2*(1/2)
            eigenvalues[2] = 3  # 2 - 2*(-1/2)
        elseif n == 3
            # cos(π/4) = √2/2, cos(π/2) = 0, cos(3π/4) = -√2/2
            eigenvalues[1] = 2 - sqrt(2)
            eigenvalues[2] = 2
            eigenvalues[3] = 2 + sqrt(2)
        else
            # Fall back to numeric
            θ = π * k / (n + 1)
            eigenvalues[k] = 2 - 2 * cos(θ)
        end
    end
    
    return eigenvalues
end

# ============================================================================
# Public API Functions
# ============================================================================

"""
    cartan_matrix_A(n::Int) -> Matrix{Int}

Construct the Cartan matrix of type Aₙ (n×n matrix).

The Cartan matrix of type Aₙ is tridiagonal with 2 on diagonal and -1 on
off-diagonals. It corresponds to the root system of SL(n+1) / SU(n+1).

# Examples
```julia
julia> cartan_matrix_A(3)
3×3 Matrix{Int64}:
  2  -1   0
 -1   2  -1
  0  -1   2
```
"""
cartan_matrix_A(n::Int) = _cartan_matrix_A(n)

"""
    cartan_matrix_B(n::Int) -> Matrix{Int}

Construct the Cartan matrix of type Bₙ (n×n matrix, n ≥ 2).

Type Bₙ corresponds to SO(2n+1). The Dynkin diagram has a double bond
at one end (short to long root). The Cartan matrix is non-symmetric.

# Examples
```julia
julia> cartan_matrix_B(3)
3×3 Matrix{Int64}:
  2  -2   0
 -1   2  -1
  0  -1   2
```
"""
cartan_matrix_B(n::Int) = _cartan_matrix_B(n)

"""
    cartan_matrix_C(n::Int) -> Matrix{Int}

Construct the Cartan matrix of type Cₙ (n×n matrix, n ≥ 2).

Type Cₙ corresponds to Sp(2n). The Dynkin diagram has a double bond
at one end (long to short root). The Cartan matrix is non-symmetric.

# Examples
```julia
julia> cartan_matrix_C(3)
3×3 Matrix{Int64}:
  2  -1   0
 -1   2  -1
  0  -2   2
```
"""
cartan_matrix_C(n::Int) = _cartan_matrix_C(n)

"""
    cartan_matrix_D(n::Int) -> Matrix{Int}

Construct the Cartan matrix of type Dₙ (n×n matrix, n ≥ 4).

The Dynkin diagram of Dₙ is a path with a fork at one end, corresponding
to the root system of SO(2n).

# Examples
```julia
julia> cartan_matrix_D(4)
4×4 Matrix{Int64}:
  2  -1   0   0
 -1   2  -1  -1
  0  -1   2   0
  0  -1   0   2
```
"""
cartan_matrix_D(n::Int) = _cartan_matrix_D(n)

"""
    cartan_matrix_E(n::Int) -> Matrix{Int}

Construct the Cartan matrix of type Eₙ (n ∈ {6, 7, 8}).

These are the exceptional simply-laced root systems.

# Examples
```julia
julia> cartan_matrix_E(6)
6×6 Matrix{Int64}:
  2  -1   0   0   0   0
 -1   2  -1   0   0   0
  0  -1   2  -1   0  -1
  0   0  -1   2  -1   0
  0   0   0  -1   2   0
  0   0  -1   0   0   2
```
"""
cartan_matrix_E(n::Int) = _cartan_matrix_E(n)

"""
    cartan_matrix_F4() -> Matrix{Int}

Construct the Cartan matrix of type F₄ (4×4 matrix).

F₄ is an exceptional non-simply-laced root system with a double bond
in the middle. It is the automorphism group of the exceptional Jordan algebra.

# Examples
```julia
julia> cartan_matrix_F4()
4×4 Matrix{Int64}:
  2  -1   0   0
 -1   2  -2   0
  0  -1   2  -1
  0   0  -1   2
```
"""
cartan_matrix_F4() = _cartan_matrix_F4()

"""
    cartan_matrix_G2() -> Matrix{Int}

Construct the Cartan matrix of type G₂ (2×2 matrix).

G₂ is an exceptional non-simply-laced root system with a triple bond.
It is the automorphism group of the octonions.

# Examples
```julia
julia> cartan_matrix_G2()
2×2 Matrix{Int64}:
  2  -3
 -1   2
```
"""
cartan_matrix_G2() = _cartan_matrix_G2()

"""
    coxeter_number(type::Symbol, n::Int) -> Int

Return the Coxeter number h for the given Coxeter group type.

The Coxeter number is the order of a Coxeter element.

# Arguments
- `type`: One of `:A`, `:B`, `:C`, `:D`, `:E`, `:F`, `:G`
- `n`: The rank of the group

# Examples
```julia
julia> coxeter_number(:A, 4)
5

julia> coxeter_number(:E, 8)
30
```
"""
coxeter_number(type::Symbol, n::Int) = _coxeter_number(type, n)

"""
    coxeter_exponents(type::Symbol, n::Int) -> Vector{Int}

Return the exponents for the given Coxeter group type.

The exponents determine the degrees of fundamental invariants (degrees = mⱼ + 1)
and the eigenvalues of a Coxeter element (e^{2πi·mⱼ/h}).

# Arguments
- `type`: One of `:A`, `:B`, `:C`, `:D`, `:E`, `:F`, `:G`
- `n`: The rank of the group

# Examples
```julia
julia> coxeter_exponents(:A, 4)
4-element Vector{Int64}:
 1
 2
 3
 4

julia> coxeter_exponents(:E, 6)
6-element Vector{Int64}:
 1
 4
 5
 7
 8
 11
```
"""
coxeter_exponents(type::Symbol, n::Int) = _coxeter_exponents(type, n)

"""
    coxeter_element_eigenvalues(type::Symbol, n::Int) -> Vector{ComplexF64}

Compute eigenvalues of a Coxeter element for the given type.

A Coxeter element is a product of all simple reflections. Its eigenvalues are
e^{2πi·mⱼ/h} where mⱼ are the exponents and h is the Coxeter number.

# Arguments
- `type`: One of `:A`, `:B`, `:C`, `:D`, `:E`, `:F`, `:G`
- `n`: The rank of the group

# Examples
```julia
julia> coxeter_element_eigenvalues(:A, 2)
2-element Vector{ComplexF64}:
 0.5 + 0.8660254037844387im
 -0.5 + 0.8660254037844387im
```
"""
coxeter_element_eigenvalues(type::Symbol, n::Int) = _coxeter_element_eigenvalues(type, n)

"""
    path_laplacian(n::Int) -> Matrix{Int}

Construct the Laplacian matrix of the path graph Pₙ with n vertices.

The path Laplacian is tridiagonal with degrees on diagonal (1 for endpoints,
2 for interior vertices) and -1 on off-diagonals.

# Examples
```julia
julia> path_laplacian(4)
4×4 Matrix{Int64}:
  1  -1   0   0
 -1   2  -1   0
  0  -1   2  -1
  0   0  -1   1
```
"""
function path_laplacian(n::Int)
    n >= 2 || error("Path graph requires n ≥ 2")
    L = zeros(Int, n, n)
    for i in 1:n
        L[i, i] = (i == 1 || i == n) ? 1 : 2
        if i > 1
            L[i, i-1] = -1
        end
        if i < n
            L[i, i+1] = -1
        end
    end
    return L
end

"""
    cycle_laplacian(n::Int) -> Matrix{Int}

Construct the Laplacian matrix of the cycle graph Cₙ with n vertices.

The cycle Laplacian is circulant with 2 on diagonal and -1 for adjacent vertices.

# Examples
```julia
julia> cycle_laplacian(4)
4×4 Matrix{Int64}:
  2  -1   0  -1
 -1   2  -1   0
  0  -1   2  -1
 -1   0  -1   2
```
"""
function cycle_laplacian(n::Int)
    n >= 3 || error("Cycle graph requires n ≥ 3")
    L = zeros(Int, n, n)
    for i in 1:n
        L[i, i] = 2
        L[i, mod(i, n) + 1] = -1
        L[i, mod(i - 2, n) + 1] = -1
    end
    return L
end

"""
    householder_reflection(v) -> Matrix

Construct a Householder reflection matrix for vector v.

The Householder matrix is H = I - 2·v·vᵀ / (vᵀ·v), which reflects vectors
across the hyperplane perpendicular to v.

# Examples
```julia
julia> H = householder_reflection([1.0, 0.0, 0.0])
3×3 Matrix{Float64}:
 -1.0  0.0  0.0
  0.0  1.0  0.0
  0.0  0.0  1.0
```
"""
householder_reflection(v) = _householder_reflection(v)
